##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    16/Feb/2023  22:41:17 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \ssl_work.c                                          #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \ssl_work.c -D NEWSGOLD -D ELKA -D DEBUG -lCN        #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\List\ -la D:\Users\alfinant\Documents\ #
#                       Siemens\Dev\IAR\VK.ELF_C\Release_ELKA\List\ -o       #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\Obj\ -z9 --cpu_mode arm --endian       #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\List\ssl_work.lst                      #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\Obj\ssl_work.r79                       #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\ssl_work.c
      1          //******************************************************************************
      2          // Имеем: openssl-0.9.5a скомпилированный с дефайном NO_DH(Диффи и Хеллман отсутствуют)
      3          // Проблем: vk.com перестал поддерживать наши древние наборы шифров
      4          // Mission: добавить поддержку AES128-SHA из AES ciphersuites from RFC3268(extending TLS v1.0)
      5          
      6          /*
      7          Siemens S75 ciphersuites:
      8          1. DES-CBC-SHA  0x0A
      9          2. RC4-SHA 0x05
     10          3. RC4-MD5 0x04
     11          4. EXP1024-RC4-SHA 0x64
     12          5. EXP1024-DES-CBC-SHA 0x62
     13          6. EXP1024-RC4-MD5 0x60
     14          7. DES-CBS-SHA 0x09
     15          8. EXP-DES-CBC-SHA 0x08
     16          9. EXP-RC4-MD5 0x03
     17          */
     18          
     19          //для теста на компе
     20          //s_client -connect m.vk.com:443 -tls1 -cipher AES128-SHA
     21          
     22          //s75v52
     23          //int EVP_add_cipher(const EVP_CIPHER *c); 0xA0E8F2B9
     24          
     25          /* int SSL_library_init(void):
     26          #ifndef OPENSSL_NO_AES
     27          	EVP_add_cipher(EVP_aes_128_cbc());
     28          	EVP_add_cipher(EVP_aes_192_cbc());
     29          	EVP_add_cipher(EVP_aes_256_cbc());
     30          #endif
     31          
     32          
     33          */
     34          //******************************************************************************
     35          #include "ssl_work.h"
     36          #include "socket_work.h"
     37          #include "buffer.h"
     38          #include <siemens/swilib.h>
     39          #include <openssl/ssl.h>
     40          #include "ssl_ext.h"
     41          
     42          extern char logmsg[];
     43          extern void SMART_REDRAW();
     44          
     45          static SSL_CTX *ctx = NULL;

   \                                 In segment DATA_I, align 4, align-sorted
     46          int SSL_MAX_SESS_COUNT = 1;
   \                     SSL_MAX_SESS_COUNT:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for SSL_MAX_SESS_COUNT>`
     47          
     48          //******************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
     49          const char* tls1_alert_code_text(int code)
     50          {
     51            switch(code)
   \                     tls1_alert_code_text:
   \   00000000   C8109FE5           LDR      R1,??tls1_alert_code_text_0  ;; `?<Constant "close_notify">`
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   1600000A           BEQ      ??tls1_alert_code_text_1
   \   0000000C   0A0050E2           SUBS     R0,R0,#+10
   \   00000010   1600000A           BEQ      ??tls1_alert_code_text_2
   \   00000014   0A0050E2           SUBS     R0,R0,#+10
   \   00000018   1600000A           BEQ      ??tls1_alert_code_text_3
   \   0000001C   0A0050E2           SUBS     R0,R0,#+10
   \   00000020   1600000A           BEQ      ??tls1_alert_code_text_4
   \   00000024   0A0050E2           SUBS     R0,R0,#+10
   \   00000028   1600000A           BEQ      ??tls1_alert_code_text_5
   \   0000002C   010050E2           SUBS     R0,R0,#+1
   \   00000030   1600000A           BEQ      ??tls1_alert_code_text_6
   \   00000034   010050E2           SUBS     R0,R0,#+1
   \   00000038   1600000A           BEQ      ??tls1_alert_code_text_7
   \   0000003C   010050E2           SUBS     R0,R0,#+1
   \   00000040   1600000A           BEQ      ??tls1_alert_code_text_8
   \   00000044   010050E2           SUBS     R0,R0,#+1
   \   00000048   1600000A           BEQ      ??tls1_alert_code_text_9
   \   0000004C   010050E2           SUBS     R0,R0,#+1
   \   00000050   1600000A           BEQ      ??tls1_alert_code_text_10
   \   00000054   010050E2           SUBS     R0,R0,#+1
   \   00000058   1600000A           BEQ      ??tls1_alert_code_text_11
   \   0000005C   010050E2           SUBS     R0,R0,#+1
   \   00000060   1600000A           BEQ      ??tls1_alert_code_text_12
   \   00000064   170000EA           B        ??tls1_alert_code_text_13
     52            {
     53            case SSL3_AD_CLOSE_NOTIFY: return "close_notify";
   \                     ??tls1_alert_code_text_1:
   \   00000068   0100A0E1           MOV      R0,R1
   \   0000006C   1EFF2FE1           BX       LR
     54            case SSL3_AD_UNEXPECTED_MESSAGE: return "unexpected_message";
   \                     ??tls1_alert_code_text_2:
   \   00000070   100081E2           ADD      R0,R1,#+16
   \   00000074   1EFF2FE1           BX       LR
     55            case SSL3_AD_BAD_RECORD_MAC: return "bad_record_mac";
   \                     ??tls1_alert_code_text_3:
   \   00000078   240081E2           ADD      R0,R1,#+36
   \   0000007C   1EFF2FE1           BX       LR
     56            case SSL3_AD_DECOMPRESSION_FAILURE: return "decompression_failure";
   \                     ??tls1_alert_code_text_4:
   \   00000080   340081E2           ADD      R0,R1,#+52
   \   00000084   1EFF2FE1           BX       LR
     57            case SSL3_AD_HANDSHAKE_FAILURE: return  "handshake_failure";
   \                     ??tls1_alert_code_text_5:
   \   00000088   4C0081E2           ADD      R0,R1,#+76
   \   0000008C   1EFF2FE1           BX       LR
     58            case SSL3_AD_NO_CERTIFICATE: return "no_certificate";
   \                     ??tls1_alert_code_text_6:
   \   00000090   600081E2           ADD      R0,R1,#+96
   \   00000094   1EFF2FE1           BX       LR
     59            case SSL3_AD_BAD_CERTIFICATE: return "bad_certificate";
   \                     ??tls1_alert_code_text_7:
   \   00000098   700081E2           ADD      R0,R1,#+112
   \   0000009C   1EFF2FE1           BX       LR
     60            case SSL3_AD_UNSUPPORTED_CERTIFICATE: return "unsupported_certificate";
   \                     ??tls1_alert_code_text_8:
   \   000000A0   800081E2           ADD      R0,R1,#+128
   \   000000A4   1EFF2FE1           BX       LR
     61            case SSL3_AD_CERTIFICATE_REVOKED: return "certificate_revoked";
   \                     ??tls1_alert_code_text_9:
   \   000000A8   980081E2           ADD      R0,R1,#+152
   \   000000AC   1EFF2FE1           BX       LR
     62            case SSL3_AD_CERTIFICATE_EXPIRED: return "certificate_expired";
   \                     ??tls1_alert_code_text_10:
   \   000000B0   AC0081E2           ADD      R0,R1,#+172
   \   000000B4   1EFF2FE1           BX       LR
     63            case SSL3_AD_CERTIFICATE_UNKNOWN: return "certificate_unknown";
   \                     ??tls1_alert_code_text_11:
   \   000000B8   C00081E2           ADD      R0,R1,#+192
   \   000000BC   1EFF2FE1           BX       LR
     64            case SSL3_AD_ILLEGAL_PARAMETER: return "illegal_parameter";
   \                     ??tls1_alert_code_text_12:
   \   000000C0   D40081E2           ADD      R0,R1,#+212
   \   000000C4   1EFF2FE1           BX       LR
     65            default: return NULL;
   \                     ??tls1_alert_code_text_13:
   \   000000C8   0000A0E3           MOV      R0,#+0
   \   000000CC   1EFF2FE1           BX       LR               ;; return
   \                     ??tls1_alert_code_text_0:
   \   000000D0   ........           DC32     `?<Constant "close_notify">`
     66            }
     67          }
     68          

   \                                 In segment CODE, align 4, keep-with-next
     69          int SSL_session_reused(SSL *ssl)
     70          {
     71            return ssl->hit;
   \                     SSL_session_reused:
   \   00000000   5C0090E5           LDR      R0,[R0, #+92]
   \   00000004   1EFF2FE1           BX       LR               ;; return
     72          }
     73          
     74          //Чтобы SSL_connect() работал стабильно, методы BIO реализуем сами. Ибо прошивочные BIO функции связаны со стандартным браузером.

   \                                 In segment CODE, align 4, keep-with-next
     75          int bread(BIO *b, char *data, int len)
     76          {
   \                     bread:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
     77            CONNDATA *conn=CONNDATA_getTop();
   \   0000000C   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000010   0060A0E1           MOV      R6,R0
     78             
     79            *socklasterr() = 0;
   \   00000014   7C8100EF           SWI      +33148
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   001080E5           STR      R1,[R0, #+0]
     80            
     81            int recv_res = recv(/*b->num*/conn->sock, data, len, 0);
   \   00000020   4C0096E5           LDR      R0,[R6, #+76]
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   780100EF           SWI      +376
   \   00000034   0050A0E1           MOV      R5,R0
     82            
     83            if (recv_res == -1 && *socklasterr() == 0xC9)
   \   00000038   010075E3           CMN      R5,#+1
   \   0000003C   0E00001A           BNE      ??bread_0
   \   00000040   7C8100EF           SWI      +33148
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   C90050E3           CMP      R0,#+201
   \   0000004C   0A00001A           BNE      ??bread_0
     84              
     85            {
     86              if(data[0] == SSL3_RT_ALERT)
   \   00000050   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000054   150050E3           CMP      R0,#+21
   \   00000058   0500001A           BNE      ??bread_1
     87              {
     88                sprintf(logmsg, tls1_alert_code_text(data[6]));
   \   0000005C   0600D4E5           LDRB     R0,[R4, #+6]
   \   00000060   ........           BL       tls1_alert_code_text
   \   00000064   0010A0E1           MOV      R1,R0
   \   00000068   ........           LDR      R0,??DataTable13  ;; logmsg
   \   0000006C   160000EF           SWI      +22
     89                SMART_REDRAW();
   \   00000070   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
     90              }
     91              return 0;
   \                     ??bread_1:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   7080BDE8           POP      {R4-R6,PC}
     92            }
     93            
     94            return recv_res;  
   \                     ??bread_0:
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
     95          }
     96          

   \                                 In segment CODE, align 4, keep-with-next
     97          int bwrite(BIO *b, const char *data, int len)
     98          { 
   \                     bwrite:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0070A0E1           MOV      R7,R0
     99            CONNDATA *conn=CONNDATA_getTop();
   \   00000010   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000014   0060A0E1           MOV      R6,R0
    100            
    101            *socklasterr() = 0; 
   \   00000018   7C8100EF           SWI      +33148
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   001080E5           STR      R1,[R0, #+0]
    102            
    103            if (b->num == 0)
   \   00000024   1C0097E5           LDR      R0,[R7, #+28]
   \   00000028   000050E3           CMP      R0,#+0
    104              b->num = conn->sock;
   \   0000002C   4C009605           LDREQ    R0,[R6, #+76]
   \   00000030   1C008705           STREQ    R0,[R7, #+28]
    105            
    106            if (conn->ssl->bbio)
   \   00000034   900096E5           LDR      R0,[R6, #+144]
   \   00000038   141090E5           LDR      R1,[R0, #+20]
   \   0000003C   000051E3           CMP      R1,#+0
   \   00000040   0600000A           BEQ      ??bwrite_0
    107            {
    108              conn->ssl->bbio->method->bread = bread;
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   ........           LDR      R2,??DataTable10  ;; bread
   \   0000004C   0C2081E5           STR      R2,[R1, #+12]
    109              conn->ssl->bbio->method->bwrite = bwrite;
   \   00000050   140090E5           LDR      R0,[R0, #+20]
   \   00000054   ........           LDR      R1,??DataTable11  ;; bwrite
   \   00000058   000090E5           LDR      R0,[R0, #+0]
   \   0000005C   081080E5           STR      R1,[R0, #+8]
    110            }
    111            
    112            int send_res = send(/*b->num*/conn->sock, data, len, 0);//bio->num может быть пустым...
   \                     ??bwrite_0:
   \   00000060   4C0096E5           LDR      R0,[R6, #+76]
   \   00000064   0030A0E3           MOV      R3,#+0
   \   00000068   0520A0E1           MOV      R2,R5
   \   0000006C   0410A0E1           MOV      R1,R4
   \   00000070   790100EF           SWI      +377
   \   00000074   0040A0E1           MOV      R4,R0
    113            
    114            if (send_res == -1 && *socklasterr() == 0xC9)
   \   00000078   010074E3           CMN      R4,#+1
   \   0000007C   0400001A           BNE      ??bwrite_1
   \   00000080   7C8100EF           SWI      +33148
   \   00000084   000090E5           LDR      R0,[R0, #+0]
   \   00000088   C90050E3           CMP      R0,#+201
    115              return 0;
   \   0000008C   0000A003           MOVEQ    R0,#+0
   \   00000090   F080BD08           POPEQ    {R4-R7,PC}
    116            
    117            return send_res;
   \                     ??bwrite_1:
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   F080BDE8           POP      {R4-R7,PC}       ;; return
    118          }
    119          //******************************************************************************
    120          

   \                                 In segment CODE, align 4, keep-with-next
    121          void tmr_connect_timeout_handler()
    122          {
   \                     tmr_connect_timeout_handler:
   \   00000000   00402DE9           PUSH     {LR}
    123            end_ssl(CONNDATA_getTop());
   \   00000004   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000008   ........           BL       end_ssl
    124            if (sock_error_handler)
   \   0000000C   ........           LDR      R0,??DataTable15  ;; sock_error_handler
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    125              sock_error_handler(ERROR_SSL_CONNECT_TIMEOUT);
   \   0000001C   0A00A0E3           MOV      R0,#+10
   \   00000020   ........           B        ?Subroutine14
    126          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine14:
   \   00000000   31FF2FE1           BLX      R1
   \   00000004   0080BDE8           POP      {PC}             ;; return
    127          

   \                                 In segment CODE, align 4, keep-with-next
    128          void tmr_read_timeout_handler(/**/)
    129          {
   \                     tmr_read_timeout_handler:
   \   00000000   00402DE9           PUSH     {LR}
    130            end_ssl(CONNDATA_getTop());
   \   00000004   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000008   ........           BL       end_ssl
    131            if (sock_error_handler)
   \   0000000C   ........           LDR      R0,??DataTable15  ;; sock_error_handler
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    132              sock_error_handler(ERROR_READ_TIMEOUT);
   \   0000001C   0800A0E3           MOV      R0,#+8
   \   00000020                      REQUIRE ?Subroutine14
   \   00000020                      ;; // Fall through to label ?Subroutine14
    133          }
    134          
    135          //******************************************************************************
    136          

   \                                 In segment CODE, align 4, keep-with-next
    137          void end_ssl(CONNDATA *conn)
    138          {
   \                     end_ssl:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    139            if (conn == NULL)
   \   00000008   1080BD08           POPEQ    {R4,PC}
    140              return;
    141            
    142            GBS_DelTimer(&conn->tmr_read);
   \   0000000C   800084E2           ADD      R0,R4,#+128
   \   00000010   8C0100EF           SWI      +396
    143            
    144            SSL_shutdown(conn->ssl);//Отправим серверу "close notify".Ожидать подтверждения конечно же не будем   
   \   00000014   900094E5           LDR      R0,[R4, #+144]
   \   00000018   9C0300EF           SWI      +924
    145            SSL_free(conn->ssl);
   \   0000001C   900094E5           LDR      R0,[R4, #+144]
   \   00000020   A00300EF           SWI      +928
    146            closesocket(conn->sock);
   \   00000024   4C0094E5           LDR      R0,[R4, #+76]
   \   00000028   760100EF           SWI      +374
    147            CONNDATA_free(conn);  
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           _BLF     CONNDATA_free,??CONNDATA_free??rA
    148          }
   \   00000034   1080BDE8           POP      {R4,PC}          ;; return
    149          

   \                                 In segment CODE, align 4, keep-with-next
    150          void end_ssl_work()
    151          {
   \                     end_ssl_work:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   000000EA           B        ??end_ssl_work_0
    152            CONNDATA *conn;
    153              
    154            while (conn=CONNDATA_getTop())
    155              end_ssl(conn);
   \                     ??end_ssl_work_1:
   \   00000008   ........           BL       end_ssl
   \                     ??end_ssl_work_0:
   \   0000000C   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   FBFFFF1A           BNE      ??end_ssl_work_1
    156          }
   \   00000018   0080BDE8           POP      {PC}             ;; return
    157          
    158          //******************************************************************************
    159          

   \                                 In segment CODE, align 4, keep-with-next
    160          static int ssl_get_answer(CONNDATA *conn)
    161          {
   \                     ssl_get_answer:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    162            char tmp_dat[4096];
    163            static int recv_size;
    164            
    165            if (recv_buf == NULL)
   \   00000004   AC509FE5           LDR      R5,??ssl_get_answer_0  ;; ??recv_size
   \   00000008   AC709FE5           LDR      R7,??ssl_get_answer_0+0x4  ;; recv_buf
   \   0000000C   40DD4DE2           SUB      SP,SP,#+4096
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   000097E5           LDR      R0,[R7, #+0]
    166              recv_size = 0;
    167            
    168            int res = SSL_read(conn->ssl, tmp_dat, 4096);
   \   00000018   402DA0E3           MOV      R2,#+4096
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   00008505           STREQ    R0,[R5, #+0]
   \   00000024   900094E5           LDR      R0,[R4, #+144]
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   9D0300EF           SWI      +925
   \   00000030   0060A0E1           MOV      R6,R0
    169            
    170            if (res > 0)
   \   00000034   010056E3           CMP      R6,#+1
   \   00000038   150000BA           BLT      ??ssl_get_answer_1
    171            {
    172              recv_buf=realloc(recv_buf, recv_size+res);
   \   0000003C   000095E5           LDR      R0,[R5, #+0]
   \   00000040   001086E0           ADD      R1,R6,R0
   \   00000044   000097E5           LDR      R0,[R7, #+0]
   \   00000048   BA0000EF           SWI      +186
   \   0000004C   000087E5           STR      R0,[R7, #+0]
    173              memcpy(recv_buf+recv_size, tmp_dat, res);
   \   00000050   000095E5           LDR      R0,[R5, #+0]
   \   00000054   003097E5           LDR      R3,[R7, #+0]
   \   00000058   0620A0E1           MOV      R2,R6
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   030080E0           ADD      R0,R0,R3
   \   00000064   1E0100EF           SWI      +286
    174              recv_size+=res;
   \   00000068   000095E5           LDR      R0,[R5, #+0]
   \   0000006C   000086E0           ADD      R0,R6,R0
   \   00000070   000085E5           STR      R0,[R5, #+0]
    175              conn->TOTALRECEIVED+=res;
   \   00000074   6C0094E5           LDR      R0,[R4, #+108]
   \   00000078   000086E0           ADD      R0,R6,R0
   \   0000007C   6C0084E5           STR      R0,[R4, #+108]
    176              ALLTOTALRECEIVED+=res;
   \   00000080   38009FE5           LDR      R0,??ssl_get_answer_0+0x8  ;; ALLTOTALRECEIVED
   \   00000084   001090E5           LDR      R1,[R0, #+0]
   \   00000088   011086E0           ADD      R1,R6,R1
   \   0000008C   001080E5           STR      R1,[R0, #+0]
   \   00000090   050000EA           B        ??ssl_get_answer_2
    177            }
    178          
    179          #ifdef DEBUG  
    180            if (res == -1)
   \                     ??ssl_get_answer_1:
   \   00000094   010076E3           CMN      R6,#+1
   \   00000098   0300001A           BNE      ??ssl_get_answer_2
    181            {
    182              sprintf(logmsg,"SSL_read error!"); 
   \   0000009C   20109FE5           LDR      R1,??ssl_get_answer_0+0xC  ;; `?<Constant "SSL_read error!">`
   \   000000A0   ........           LDR      R0,??DataTable13  ;; logmsg
   \   000000A4   160000EF           SWI      +22
    183              SMART_REDRAW();
   \   000000A8   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    184            }
    185          #endif
    186            
    187            return res;
   \                     ??ssl_get_answer_2:
   \   000000AC   0600A0E1           MOV      R0,R6
   \   000000B0   40DD8DE2           ADD      SP,SP,#+4096
   \   000000B4   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??ssl_get_answer_0:
   \   000000B8   ........           DC32     ??recv_size
   \   000000BC   ........           DC32     recv_buf
   \   000000C0   ........           DC32     ALLTOTALRECEIVED
   \   000000C4   ........           DC32     `?<Constant "SSL_read error!">`
    188          }
    189          //******************************************************************************
    190          //

   \                                 In segment CODE, align 4, keep-with-next
    191          void ssl_send_answer(const char *url, char *buf, int len, int flag)
    192          {
   \                     ssl_send_answer:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    193            static CONNDATA *conn;
    194            static int send_q_size;
    195            
    196            if (url)//если первый вызов функции
   \   00000004   60419FE5           LDR      R4,??ssl_send_answer_0  ;; ??conn
   \   00000008   60519FE5           LDR      R5,??ssl_send_answer_0+0x4  ;; send_buf
   \   0000000C   60A19FE5           LDR      R10,??ssl_send_answer_0+0x8  ;; send_buf_len
   \   00000010   0060A0E1           MOV      R6,R0
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0280A0E1           MOV      R8,R2
   \   0000001C   0390A0E1           MOV      R9,R3
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   0B00000A           BEQ      ??ssl_send_answer_1
    197            {
    198              free_send_buf();
   \   00000028   ........           _BLF     free_send_buf,??free_send_buf??rA
    199              send_buf = buf;
   \   0000002C   007085E5           STR      R7,[R5, #+0]
    200              send_buf_len = len;
   \   00000030   00808AE5           STR      R8,[R10, #+0]
    201              send_q_size = len;
   \   00000034   048084E5           STR      R8,[R4, #+4]
    202                
    203              conn = CONNDATA_findByURL(url);
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           _BLF     CONNDATA_findByURL,??CONNDATA_findByURL??rA
   \   00000040   000084E5           STR      R0,[R4, #+0]
    204             
    205              if (conn && conn->ssl)//коннект активен(при keep-alive)
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   90109015           LDRNE    R1,[R0, #+144]
   \   0000004C   00005113           CMPNE    R1,#+0
   \   00000050   2C00000A           BEQ      ??ssl_send_answer_2
    206                CONNDATA_set2Top(conn);
   \   00000054   ........           _BLF     CONNDATA_set2Top,??CONNDATA_set2Top??rA
    207              else//если соединение не установлено
    208              {
    209                conn = CONNDATA_new(url, flag);
    210                connect_socket(conn);
    211                return;
    212              }
    213            }
    214            
    215           int res = SSL_write(conn->ssl, send_buf+(send_buf_len-send_q_size), send_buf_len);
   \                     ??ssl_send_answer_1:
   \   00000058   00009AE5           LDR      R0,[R10, #+0]
   \   0000005C   041094E5           LDR      R1,[R4, #+4]
   \   00000060   0020A0E1           MOV      R2,R0
   \   00000064   010040E0           SUB      R0,R0,R1
   \   00000068   001095E5           LDR      R1,[R5, #+0]
   \   0000006C   011080E0           ADD      R1,R0,R1
   \   00000070   000094E5           LDR      R0,[R4, #+0]
   \   00000074   900090E5           LDR      R0,[R0, #+144]
   \   00000078   9F0300EF           SWI      +927
    216           
    217           conn->recv_mode = 1;
   \   0000007C   001094E5           LDR      R1,[R4, #+0]
   \   00000080   0120A0E3           MOV      R2,#+1
   \   00000084   582081E5           STR      R2,[R1, #+88]
    218             
    219            if (res !=-1)
   \   00000088   002062E2           RSB      R2,R2,#+0
   \   0000008C   020050E1           CMP      R0,R2
   \   00000090   0900000A           BEQ      ??ssl_send_answer_3
    220            {
    221              send_q_size -= res;
   \   00000094   043094E5           LDR      R3,[R4, #+4]
   \   00000098   003043E0           SUB      R3,R3,R0
   \   0000009C   043084E5           STR      R3,[R4, #+4]
    222              conn->TOTALSENDED += res;
   \   000000A0   683091E5           LDR      R3,[R1, #+104]
   \   000000A4   033080E0           ADD      R3,R0,R3
   \   000000A8   683081E5           STR      R3,[R1, #+104]
    223              ALLTOTALSENDED += res;
   \   000000AC   C4309FE5           LDR      R3,??ssl_send_answer_0+0xC  ;; ALLTOTALSENDED
   \   000000B0   005093E5           LDR      R5,[R3, #+0]
   \   000000B4   055080E0           ADD      R5,R0,R5
   \   000000B8   005083E5           STR      R5,[R3, #+0]
    224            }
    225            
    226            if (res > 0)
   \                     ??ssl_send_answer_3:
   \   000000BC   ........           LDR      R5,??DataTable13  ;; logmsg
   \   000000C0   B4609FE5           LDR      R6,??ssl_send_answer_0+0x10  ;; `?<Constant "SSL_write Ok">`
   \   000000C4   010050E3           CMP      R0,#+1
   \   000000C8   130000BA           BLT      ??ssl_send_answer_4
    227            {
    228              if (send_q_size)//послали меньше чем заказывали
   \   000000CC   040094E5           LDR      R0,[R4, #+4]
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   F087BD18           POPNE    {R4-R10,PC}
    229              {
    230          #ifdef DEVELOP
    231              ShowMSG(1,(int)"send_q_size");
    232          #endif
    233                  return;//ожидаем сообщения ENIP_BUFFER_FREE???
    234              }
    235              
    236              free_recv_buf();
   \   000000D8   ........           _BLF     free_recv_buf,??free_recv_buf??rA
    237              GBS_DelTimer(&conn->tmr_read);
   \   000000DC   000094E5           LDR      R0,[R4, #+0]
   \   000000E0   800080E2           ADD      R0,R0,#+128
   \   000000E4   8C0100EF           SWI      +396
    238              GBS_StartTimerProc(&conn->tmr_read, 216* 30 , tmr_read_timeout_handler);
   \   000000E8   000094E5           LDR      R0,[R4, #+0]
   \   000000EC   ........           LDR      R2,??DataTable16  ;; tmr_read_timeout_handler
   \   000000F0   5010A0E3           MOV      R1,#+80
   \   000000F4   641D81E3           ORR      R1,R1,#0x1900
   \   000000F8   800080E2           ADD      R0,R0,#+128
   \   000000FC   4D0000EF           SWI      +77
    239              
    240          #ifdef DEBUG      
    241              sprintf(logmsg,"SSL_write Ok");
   \   00000100   0610A0E1           MOV      R1,R6
   \   00000104   0E0000EA           B        ??ssl_send_answer_5
    242              SMART_REDRAW();
    243          #endif
    244              
    245              return;
    246            }
   \                     ??ssl_send_answer_2:
   \   00000108   0910A0E1           MOV      R1,R9
   \   0000010C   0600A0E1           MOV      R0,R6
   \   00000110   ........           _BLF     CONNDATA_new,??CONNDATA_new??rA
   \   00000114   000084E5           STR      R0,[R4, #+0]
   \   00000118   ........           B        ?Subroutine16
    247            
    248            if (res ==0)//...? 
   \                     ??ssl_send_answer_4:
   \   0000011C   ........           LDR      R4,??DataTable15  ;; sock_error_handler
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   0800001A           BNE      ??ssl_send_answer_6
    249            {
    250              //end_ssl_last();
    251              sock_error_handler(ERROR_WRITE);
   \   00000128   001094E5           LDR      R1,[R4, #+0]
   \   0000012C   0600A0E3           MOV      R0,#+6
   \   00000130   31FF2FE1           BLX      R1
    252              
    253          #ifdef DEBUG
    254              ShowMSG(1,(int)"SSL write==0");
   \   00000134   101086E2           ADD      R1,R6,#+16
   \   00000138   0100A0E3           MOV      R0,#+1
   \   0000013C   480100EF           SWI      +328
    255              sprintf(logmsg,"ssl_write==0");
   \   00000140   201086E2           ADD      R1,R6,#+32
   \                     ??ssl_send_answer_5:
   \   00000144   0500A0E1           MOV      R0,R5
   \   00000148   ........           B        ?Subroutine15
    256              SMART_REDRAW();
    257          #endif
    258              
    259              return;
    260            } 
    261            
    262            if(res ==-1)
   \                     ??ssl_send_answer_6:
   \   0000014C   020050E1           CMP      R0,R2
   \   00000150   F087BD18           POPNE    {R4-R10,PC}
    263            {
    264              end_ssl(conn);
   \   00000154   0100A0E1           MOV      R0,R1
   \   00000158   ........           BL       end_ssl
    265              sock_error_handler(ERROR_WRITE);
   \   0000015C   001094E5           LDR      R1,[R4, #+0]
   \   00000160   0600A0E3           MOV      R0,#+6
   \   00000164   31FF2FE1           BLX      R1
    266              return;
   \   00000168   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_send_answer_0:
   \   0000016C   ........           DC32     ??conn
   \   00000170   ........           DC32     send_buf
   \   00000174   ........           DC32     send_buf_len
   \   00000178   ........           DC32     ALLTOTALSENDED
   \   0000017C   ........           DC32     `?<Constant "SSL_write Ok">`
    267            }
    268          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine16:
   \   00000000   ........           _BLF     connect_socket,??connect_socket??rA
   \   00000004   F087BDE8           POP      {R4-R10,PC}

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine15:
   \   00000000   160000EF           SWI      +22
   \   00000004   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
   \   00000008   F087BDE8           POP      {R4-R10,PC}
    269          
    270          //******************************************************************************
    271          /*
    272          static int verify_callback(int mode, X509_STORE_CTX *ctx)
    273          {
    274            return 0;
    275          }
    276          */
    277          //****************************************************************************
    278          
    279          //Вызывается после создания новой сессии

   \                                 In segment CODE, align 4, keep-with-next
    280          static int new_session(SSL *ssl, SSL_SESSION *new_session)
    281          {
   \                     new_session:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    282            CONNDATA *conn = CONNDATA_findBySSL(ssl);
   \   00000008   ........           _BLF     CONNDATA_findBySSL,??CONNDATA_findBySSL??rA
    283            
    284            if (conn)
   \   0000000C   000050E3           CMP      R0,#+0
    285              conn->ssl_sess = new_session;
   \   00000010   98408015           STRNE    R4,[R0, #+152]
    286            //else ERROR;
    287             
    288            //TOTALNEWSSLSESSIONS++;
    289          
    290            return(1);
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    291          }
    292          

   \                                 In segment CODE, align 4, keep-with-next
    293          static void remove_session(SSL_CTX *ctx, SSL_SESSION *sess)
    294          {//Сессия удалена из контекста по причине истечения тайм-аута, либо удаляется сам контекст
   \                     remove_session:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
    295            
    296            CONNDATA *conn;
    297            
    298            sess->references = 1;  //сессия больше не нужна
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   9C1080E5           STR      R1,[R0, #+156]
    299            
    300            if (conn = CONNDATA_findBySession(sess))//ищем соединение по сессии
   \   00000010   ........           _BLF     CONNDATA_findBySession,??CONNDATA_findBySession??rA
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    301            {
    302              conn->ssl_sess = NULL;    
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   981080E5           STR      R1,[R0, #+152]
    303          #ifdef DEBUG    
    304              ShowMSG(1,(int)"Session Remove");
   \   00000024   08109FE5           LDR      R1,??remove_session_0  ;; `?<Constant "Session Remove">`
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   480100EF           SWI      +328
    305          #endif    
    306            } 
    307          }
   \   00000030   0080BDE8           POP      {PC}             ;; return
   \                     ??remove_session_0:
   \   00000034   ........           DC32     `?<Constant "Session Remove">`
    308          
    309          //******************************************************************************
    310          /*
    311          //ищем в кэше нужную сессию(при работе с внутренним кэшем)
    312          static SSL_SESSION *get_session(SSL* ssl, unsigned char *data, int len, int *copy)
    313          {
    314          //Не разобрался еще..
    315            return 0;
    316          }
    317          */
    318          //******************************************************************************
    319           

   \                                 In segment CODE, align 4, keep-with-next
    320          static int ssl_connect(int sock)
    321          {
   \                     ssl_connect:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    322            static int __sock;
    323           
    324            if (sock)
   \   00000004   4C919FE5           LDR      R9,??ssl_connect_0  ;; ctx
    325              __sock = sock;
    326            
    327            CONNDATA *conn = CONNDATA_findBySock(__sock);
    328            
    329          #ifdef DEBUG
    330            sprintf(logmsg,"SSL connect...");
   \   00000008   ........           LDR      R6,??DataTable13  ;; logmsg
   \   0000000C   48719FE5           LDR      R7,??ssl_connect_0+0x4  ;; `?<Constant "SSL connect...">`
   \   00000010   0040B0E1           MOVS     R4,R0
   \   00000014   04408915           STRNE    R4,[R9, #+4]
   \   00000018   040099E5           LDR      R0,[R9, #+4]
    331            SMART_REDRAW();
    332          #endif
    333           
    334            if (sock)
   \   0000001C   0080E0E3           MVN      R8,#+0
   \   00000020   ........           _BLF     CONNDATA_findBySock,??CONNDATA_findBySock??rA
   \   00000024   0050A0E1           MOV      R5,R0
   \   00000028   0710A0E1           MOV      R1,R7
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   160000EF           SWI      +22
   \   00000034   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
   \   00000038   000054E3           CMP      R4,#+0
   \   0000003C   2E00000A           BEQ      ??ssl_connect_1
    335            {
    336              conn->ssl_state = -1;
   \   00000040   948085E5           STR      R8,[R5, #+148]
    337              
    338              if (!ctx)
   \   00000044   000099E5           LDR      R0,[R9, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0C00001A           BNE      ??ssl_connect_2
    339              {    
    340                ctx = SSL_CTX_new(TLSv1_client_method());
   \   00000050   950300EF           SWI      +917
   \   00000054   960300EF           SWI      +918
   \   00000058   000089E5           STR      R0,[R9, #+0]
    341                
    342                //Расширение: добавляем  шифры в cipher_list
    343                //sk_push((STACK*)ctx->cipher_list, (char*)&cipher_2F);
    344                //sk_push((STACK*)ctx->cipher_list_by_id, (char*)&cipher_2F);
    345                
    346                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL_LOOKUP, 0);//запрещаем внутренний кэш
   \   0000005C   0030A0E3           MOV      R3,#+0
   \   00000060   0120A0E3           MOV      R2,#+1
   \   00000064   402F82E3           ORR      R2,R2,#0x100
   \   00000068   2C10A0E3           MOV      R1,#+44
   \   0000006C   980300EF           SWI      +920
    347                //ssl_ctx_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, 5, 0);
    348                SSL_CTX_sess_set_new_cb(ctx, new_session);
   \   00000070   000099E5           LDR      R0,[R9, #+0]
   \   00000074   E4109FE5           LDR      R1,??ssl_connect_0+0x8  ;; new_session
   \   00000078   301080E5           STR      R1,[R0, #+48]
    349                SSL_CTX_sess_set_remove_cb(ctx, remove_session);
   \   0000007C   E0109FE5           LDR      R1,??ssl_connect_0+0xC  ;; remove_session
   \   00000080   341080E5           STR      R1,[R0, #+52]
    350                //SSL_CTX_sess_set_get_cb(ctx, get_session);
    351              }   
    352              
    353              SSL *ssl = SSL_new(ctx);  
   \                     ??ssl_connect_2:
   \   00000084   000099E5           LDR      R0,[R9, #+0]
   \   00000088   990300EF           SWI      +921
   \   0000008C   0090A0E1           MOV      R9,R0
    354              conn->ssl = ssl;
   \   00000090   909085E5           STR      R9,[R5, #+144]
    355              
    356              //Расширение: метод get_cipher_by_char меняем на свой/
    357              //get_cipher_by_char_old=ssl->method->get_cipher_by_char;
    358              //ssl->method->get_cipher_by_char = get_cipher_by_char_new;
    359                 
    360                if (conn->ssl_sess)
   \   00000094   981095E5           LDR      R1,[R5, #+152]
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0C00000A           BEQ      ??ssl_connect_3
    361                {
    362                  if (conn->ssl_sess->not_resumable)//на всякий случай
   \   000000A0   8C0091E5           LDR      R0,[R1, #+140]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0500000A           BEQ      ??ssl_connect_4
    363                  {
    364                    conn->ssl_sess->references = 0;
   \   000000AC   00A0A0E3           MOV      R10,#+0
   \   000000B0   9CA081E5           STR      R10,[R1, #+156]
    365                    SSL_SESSION_free(conn->ssl_sess);
   \   000000B4   0100A0E1           MOV      R0,R1
   \   000000B8   A20300EF           SWI      +930
    366                    conn->ssl_sess = NULL;
   \   000000BC   98A085E5           STR      R10,[R5, #+152]
   \   000000C0   030000EA           B        ??ssl_connect_3
    367                  }
    368                  else
    369                  {     
    370                    conn->ssl_sess->references = 2;//если 1я-сессия удаляется.Хз почему...
   \                     ??ssl_connect_4:
   \   000000C4   0200A0E3           MOV      R0,#+2
   \   000000C8   9C0081E5           STR      R0,[R1, #+156]
    371                    SSL_set_session(ssl, conn->ssl_sess);
   \   000000CC   0900A0E1           MOV      R0,R9
   \   000000D0   A10300EF           SWI      +929
    372                  }
    373                }
    374              
    375              SSL_set_fd(ssl, sock);
   \                     ??ssl_connect_3:
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0900A0E1           MOV      R0,R9
   \   000000DC   9A0300EF           SWI      +922
    376              
    377              ssl->rbio->method->bread = bread;
   \   000000E0   0C0099E5           LDR      R0,[R9, #+12]
   \   000000E4   ........           LDR      R2,??DataTable10  ;; bread
   \   000000E8   001090E5           LDR      R1,[R0, #+0]
   \   000000EC   0C2081E5           STR      R2,[R1, #+12]
    378              ssl->rbio->method->bwrite = bwrite;    
   \   000000F0   000090E5           LDR      R0,[R0, #+0]
   \   000000F4   ........           LDR      R1,??DataTable11  ;; bwrite
   \   000000F8   081080E5           STR      R1,[R0, #+8]
    379            }
    380            
    381            conn->ssl_state = SSL_connect(conn->ssl);
   \                     ??ssl_connect_1:
   \   000000FC   900095E5           LDR      R0,[R5, #+144]
   \   00000100   9B0300EF           SWI      +923
   \   00000104   940085E5           STR      R0,[R5, #+148]
    382            
    383            if (conn->ssl_state == -1)//error
   \   00000108   080050E1           CMP      R0,R8
   \   0000010C   0900001A           BNE      ??ssl_connect_5
    384            {
    385              end_ssl(conn);
   \   00000110   0500A0E1           MOV      R0,R5
   \   00000114   ........           BL       end_ssl
    386              
    387              sock_error_handler(ERROR_SSL_CONNECTION);
   \   00000118   ........           LDR      R1,??DataTable15  ;; sock_error_handler
   \   0000011C   0900A0E3           MOV      R0,#+9
   \   00000120   001091E5           LDR      R1,[R1, #+0]
   \   00000124   31FF2FE1           BLX      R1
    388          #ifdef DEBUG    
    389              sprintf(logmsg, "SSL_connect Error!");
   \   00000128   101087E2           ADD      R1,R7,#+16
   \   0000012C   0600A0E1           MOV      R0,R6
   \   00000130   160000EF           SWI      +22
    390              SMART_REDRAW();
   \   00000134   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    391          #endif
    392            }
    393            
    394          #ifdef DEBUG  
    395            if (conn->ssl_state == 1)//ok
   \                     ??ssl_connect_5:
   \   00000138   940095E5           LDR      R0,[R5, #+148]
   \   0000013C   010050E3           CMP      R0,#+1
   \   00000140   0200001A           BNE      ??ssl_connect_6
    396              sprintf(logmsg,"SSL_connect Ok!");
   \   00000144   241087E2           ADD      R1,R7,#+36
   \   00000148   0600A0E1           MOV      R0,R6
   \   0000014C   160000EF           SWI      +22
    397          #endif
    398            return conn->ssl_state;
   \                     ??ssl_connect_6:
   \   00000150   940095E5           LDR      R0,[R5, #+148]
   \   00000154   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_connect_0:
   \   00000158   ........           DC32     ctx
   \   0000015C   ........           DC32     `?<Constant "SSL connect...">`
   \   00000160   ........           DC32     new_session
   \   00000164   ........           DC32     remove_session
    399          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ctx:
   \   00000000                      DS8 4
   \   00000004                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??recv_size:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??conn:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    400          
    401          //******************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    402          void ssl_socket_msg_handler(GBS_MSG* msg)
    403          {
   \                     ssl_socket_msg_handler:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    404            CONNDATA *conn;
    405            
    406            switch((int)msg->data0)
   \   00000004   ........           LDR      R4,??DataTable13  ;; logmsg
   \   00000008   F4519FE5           LDR      R5,??ssl_socket_msg_handler_1  ;; `?<Constant "GPRS offline...">`
   \   0000000C   0070A0E1           MOV      R7,R0
   \   00000010   0C1097E5           LDR      R1,[R7, #+12]
   \   00000014   EC019FE5           LDR      R0,??ssl_socket_msg_handler_1+0x4  ;; is_gprs_online
   \   00000018   0180A0E3           MOV      R8,#+1
   \   0000001C   0060A0E3           MOV      R6,#+0
   \   00000020   801051E2           SUBS     R1,R1,#+128
   \   00000024   0B00000A           BEQ      ??ssl_socket_msg_handler_2
   \   00000028   021051E2           SUBS     R1,R1,#+2
   \   0000002C   0200000A           BEQ      ??ssl_socket_msg_handler_3
   \   00000030   121051E2           SUBS     R1,R1,#+18
   \   00000034   2B00000A           BEQ      ??ssl_socket_msg_handler_4
   \   00000038   140000EA           B        ??ssl_socket_msg_handler_5
    407            {
    408          //------------------------------------------------------------------------------    
    409            case LMAN_DISCONNECT_IND:
    410              is_gprs_online=0;
    411              sock_error_handler(GPRS_OFFLINE);
   \                     ??ssl_socket_msg_handler_3:
   \   0000003C   ........           LDR      R1,??DataTable15  ;; sock_error_handler
   \   00000040   006080E5           STR      R6,[R0, #+0]
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   0400A0E3           MOV      R0,#+4
   \   0000004C   31FF2FE1           BLX      R1
    412              
    413          #ifdef DEBUG      
    414              sprintf(logmsg,"GPRS offline...");
   \   00000050   0510A0E1           MOV      R1,R5
   \   00000054   4C0000EA           B        ??ssl_socket_msg_handler_6
    415              SMART_REDRAW();
    416          #endif    
    417              return;
    418          //------------------------------------------------------------------------------  
    419            case LMAN_CONNECT_CNF:
    420              //start_vibra(VIBR_ON_CONNECT);
    421              is_gprs_online=1;
    422              sock_error_handler(GPRS_ONLINE);
   \                     ??ssl_socket_msg_handler_2:
   \   00000058   ........           LDR      R1,??DataTable15  ;; sock_error_handler
   \   0000005C   008080E5           STR      R8,[R0, #+0]
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   0500A0E3           MOV      R0,#+5
   \   00000068   31FF2FE1           BLX      R1
    423                if (!disautorecconect)
   \   0000006C   98019FE5           LDR      R0,??ssl_socket_msg_handler_1+0x8  ;; disautorecconect
   \   00000070   000090E5           LDR      R0,[R0, #+0]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0400001A           BNE      ??ssl_socket_msg_handler_5
    424                {
    425          #ifdef DEBUG          
    426                  sprintf(logmsg,"GPRS online");
   \   0000007C   101085E2           ADD      R1,R5,#+16
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   160000EF           SWI      +22
    427                  SMART_REDRAW();
   \   00000088   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    428          #endif
    429                  reconnect();
   \   0000008C   ........           _BLF     reconnect,??reconnect??rA
    430                }
    431              break; 
    432          //------------------------------------------------------------------------------  
    433            case ENIP_DNR_HOST_BY_NAME:
    434              
    435              conn=CONNDATA_findByDNR((int)msg->data1);
    436              
    437              if (conn && conn->DNR_TRIES)
    438                connect_socket(NULL);
    439              
    440              return;
    441            }
    442          //------------------------------------------------------------------------------
    443          
    444            if (conn=CONNDATA_findBySock((int)msg->data1))//если наш сокет
   \                     ??ssl_socket_msg_handler_5:
   \   00000090   100097E5           LDR      R0,[R7, #+16]
   \   00000094   ........           _BLF     CONNDATA_findBySock,??CONNDATA_findBySock??rA
   \   00000098   00A0B0E1           MOVS     R10,R0
   \   0000009C   F087BD08           POPEQ    {R4-R10,PC}
    445            {
    446              switch((int)msg->data0)
   \   000000A0   0C0097E5           LDR      R0,[R7, #+12]
   \   000000A4   5090A0E3           MOV      R9,#+80
   \   000000A8   649D89E3           ORR      R9,R9,#0x1900
   \   000000AC   8A0040E2           SUB      R0,R0,#+138
   \   000000B0   050050E3           CMP      R0,#+5
   \   000000B4   F087BD88           POPHI    {R4-R10,PC}
   \   000000B8   011F8FE2           ADR      R1,??ssl_socket_msg_handler_0
   \   000000BC   0010D1E7           LDRB     R1,[R1, R0]
   \   000000C0   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??ssl_socket_msg_handler_0:
   \   000000C4   3A3A1001           DC8      +58,+58,+16,+1
   \   000000C8   4E3F0000           DC8      +78,+63,+0,+0
    447              {
    448              case ENIP_SOCK_CONNECTED:
    449                conn->sock_state=1;
   \                     ??ssl_socket_msg_handler_7:
   \   000000CC   54808AE5           STR      R8,[R10, #+84]
    450                ssl_connect(conn->sock);       
   \   000000D0   4C009AE5           LDR      R0,[R10, #+76]
   \   000000D4   ........           BL       ssl_connect
    451                GBS_StartTimerProc(&conn->tmr_connect, 216* 30 , tmr_connect_timeout_handler);
   \   000000D8   30219FE5           LDR      R2,??ssl_socket_msg_handler_1+0xC  ;; tmr_connect_timeout_handler
   \   000000DC   0910A0E1           MOV      R1,R9
   \   000000E0   70008AE2           ADD      R0,R10,#+112
   \   000000E4   2F0000EA           B        ??ssl_socket_msg_handler_8
   \                     ??ssl_socket_msg_handler_4:
   \   000000E8   100097E5           LDR      R0,[R7, #+16]
   \   000000EC   ........           _BLF     CONNDATA_findByDNR,??CONNDATA_findByDNR??rA
   \   000000F0   00A0B0E1           MOVS     R10,R0
   \   000000F4   60009015           LDRNE    R0,[R0, #+96]
   \   000000F8   00005013           CMPNE    R0,#+0
   \   000000FC   F087BD08           POPEQ    {R4-R10,PC}
   \   00000100   0000A0E3           MOV      R0,#+0
   \   00000104   ........           B        ?Subroutine16
    452                break;
    453          //------------------------------------------------------------------------------
    454              case ENIP_SOCK_DATA_READ:
    455                
    456                  if (conn->ssl_state == 0)//если в процессе хэндшейка
   \                     ??ssl_socket_msg_handler_9:
   \   00000108   94009AE5           LDR      R0,[R10, #+148]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0B00001A           BNE      ??ssl_socket_msg_handler_10
    457                  {
    458                    ssl_connect(0);//повторно вызываем 
   \   00000114   ........           BL       ssl_connect
    459                    
    460                    if (conn->ssl_state == 1)//SSL соединение установлено
   \   00000118   94009AE5           LDR      R0,[R10, #+148]
   \   0000011C   010050E3           CMP      R0,#+1
   \   00000120   F087BD18           POPNE    {R4-R10,PC}
    461                    {
    462                      GBS_DelTimer(&conn->tmr_connect);
   \   00000124   70008AE2           ADD      R0,R10,#+112
   \   00000128   8C0100EF           SWI      +396
    463                      ssl_send_answer(0, 0, 0, 0);//возобновляем передачу данных
   \   0000012C   0030A0E3           MOV      R3,#+0
   \   00000130   0320A0E1           MOV      R2,R3
   \   00000134   0210A0E1           MOV      R1,R2
   \   00000138   0100A0E1           MOV      R0,R1
   \   0000013C   ........           BL       ssl_send_answer
   \   00000140   F087BDE8           POP      {R4-R10,PC}
    464                    }
    465                    return;
    466                  }
    467                
    468                if (conn->ssl_state == 1 && conn->recv_mode == 1 )////если посылали send
   \                     ??ssl_socket_msg_handler_10:
   \   00000144   010050E3           CMP      R0,#+1
   \   00000148   58009A05           LDREQ    R0,[R10, #+88]
   \   0000014C   01005003           CMPEQ    R0,#+1
   \   00000150   F087BD18           POPNE    {R4-R10,PC}
    469                {
    470                  if (ssl_get_answer(conn) > 0)//если есть данные
   \   00000154   0A00A0E1           MOV      R0,R10
   \   00000158   ........           BL       ssl_get_answer
   \   0000015C   010050E3           CMP      R0,#+1
   \   00000160   F087BDB8           POPLT    {R4-R10,PC}
    471                    {
    472                      if (sock_data_read_handler(conn))//все данные получены
   \   00000164   A8109FE5           LDR      R1,??ssl_socket_msg_handler_1+0x10  ;; sock_data_read_handler
   \   00000168   0A00A0E1           MOV      R0,R10
   \   0000016C   001091E5           LDR      R1,[R1, #+0]
   \   00000170   31FF2FE1           BLX      R1
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   0500000A           BEQ      ??ssl_socket_msg_handler_11
    473                      {
    474                        conn->recv_mode = 0;
   \   0000017C   58608AE5           STR      R6,[R10, #+88]
    475                        GBS_DelTimer(&conn->tmr_read);
   \   00000180   80008AE2           ADD      R0,R10,#+128
   \   00000184   8C0100EF           SWI      +396
    476          #ifdef DEBUG
    477                        sprintf(logmsg,"SSL_Read OK");
   \   00000188   1C1085E2           ADD      R1,R5,#+28
   \                     ??ssl_socket_msg_handler_6:
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           B        ?Subroutine15
    478                        SMART_REDRAW();
    479          #endif
    480                      return;
    481                      }
    482                      GBS_DelTimer(&conn->tmr_read);
   \                     ??ssl_socket_msg_handler_11:
   \   00000194   80008AE2           ADD      R0,R10,#+128
   \   00000198   8C0100EF           SWI      +396
    483                      GBS_StartTimerProc(&conn->tmr_read, 216* 30 , tmr_read_timeout_handler);
   \   0000019C   ........           LDR      R2,??DataTable16  ;; tmr_read_timeout_handler
   \   000001A0   0910A0E1           MOV      R1,R9
   \   000001A4   80008AE2           ADD      R0,R10,#+128
   \                     ??ssl_socket_msg_handler_8:
   \   000001A8   4D0000EF           SWI      +77
   \   000001AC   F087BDE8           POP      {R4-R10,PC}
    484                    }
    485                }
    486                break;
    487          //------------------------------------------------------------------------------
    488              case ENIP_BUFFER_FREE://Досылаем очередь
    489              case ENIP_BUFFER_FREE1:     
    490                //ssl_send_answer(0, 0, 0); 
    491          #ifdef DEBUG
    492                ShowMSG(1, (int)"buffer free!!!");
   \                     ??ssl_socket_msg_handler_12:
   \   000001B0   281085E2           ADD      R1,R5,#+40
   \   000001B4   0100A0E3           MOV      R0,#+1
   \   000001B8   480100EF           SWI      +328
    493                sprintf(logmsg,"ENIP_BUFFER_FREE");
   \   000001BC   381085E2           ADD      R1,R5,#+56
   \   000001C0   F1FFFFEA           B        ??ssl_socket_msg_handler_6
    494                SMART_REDRAW();
    495          #endif
    496                break;
    497          //------------------------------------------------------------------------------
    498              case ENIP_SOCK_REMOTE_CLOSED://Закрыт со стороны сервера
    499          #ifdef DEBUG
    500                sprintf(logmsg,"Сервер %s закрыл соед.", conn->hostname);
   \                     ??ssl_socket_msg_handler_13:
   \   000001C4   0C208AE2           ADD      R2,R10,#+12
   \   000001C8   4C1085E2           ADD      R1,R5,#+76
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   160000EF           SWI      +22
    501                SMART_REDRAW();
   \   000001D4   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    502          #endif
    503                GBS_DelTimer(&conn->tmr_read); 
   \   000001D8   80008AE2           ADD      R0,R10,#+128
   \   000001DC   8C0100EF           SWI      +396
    504                sock_remote_closed_handler(conn->sock);
   \   000001E0   4C009AE5           LDR      R0,[R10, #+76]
   \   000001E4   2C109FE5           LDR      R1,??ssl_socket_msg_handler_1+0x14  ;; sock_remote_closed_handler
   \   000001E8   0008A0E1           MOV      R0,R0, LSL #+16
   \   000001EC   001091E5           LDR      R1,[R1, #+0]
   \   000001F0   4008A0E1           MOV      R0,R0, ASR #+16
   \   000001F4   31FF2FE1           BLX      R1
    505                end_ssl(conn);
   \   000001F8   0A00A0E1           MOV      R0,R10
   \   000001FC   ........           BL       end_ssl
   \                     ??ssl_socket_msg_handler_14:
   \   00000200   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_socket_msg_handler_1:
   \   00000204   ........           DC32     `?<Constant "GPRS offline...">`
   \   00000208   ........           DC32     is_gprs_online
   \   0000020C   ........           DC32     disautorecconect
   \   00000210   ........           DC32     tmr_connect_timeout_handler
   \   00000214   ........           DC32     sock_data_read_handler
   \   00000218   ........           DC32     sock_remote_closed_handler
    506                break;
    507          //------------------------------------------------------------------------------
    508              case ENIP_SOCK_CLOSED:
    509                //Закрыт вызовом closesocket
    510                //sprintf(logmsg,"Соединение закрыто вызовом closesocket");
    511                break;
    512              }
    513            }
    514          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     bread

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     bwrite

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     logmsg

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     sock_error_handler

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     tmr_read_timeout_handler

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for SSL_MAX_SESS_COUNT>`:
   \   00000000   01000000           DC32 1

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "close_notify">`:
   \   00000000   636C6F73655F       DC8 "close_notify"
   \              6E6F74696679
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   756E65787065       DC8 "unexpected_message"
   \              637465645F6D
   \              657373616765
   \              00          
   \   00000023   00                 DC8 0
   \   00000024   6261645F7265       DC8 "bad_record_mac"
   \              636F72645F6D
   \              616300      
   \   00000033   00                 DC8 0
   \   00000034   6465636F6D70       DC8 "decompression_failure"
   \              72657373696F
   \              6E5F6661696C
   \              75726500    
   \   0000004A   0000               DC8 0, 0
   \   0000004C   68616E647368       DC8 "handshake_failure"
   \              616B655F6661
   \              696C75726500
   \   0000005E   0000               DC8 0, 0
   \   00000060   6E6F5F636572       DC8 "no_certificate"
   \              746966696361
   \              746500      
   \   0000006F   00                 DC8 0
   \   00000070   6261645F6365       DC8 "bad_certificate"
   \              727469666963
   \              61746500    
   \   00000080   756E73757070       DC8 "unsupported_certificate"
   \              6F727465645F
   \              636572746966
   \              696361746500
   \   00000098   636572746966       DC8 "certificate_revoked"
   \              69636174655F
   \              7265766F6B65
   \              6400        
   \   000000AC   636572746966       DC8 "certificate_expired"
   \              69636174655F
   \              657870697265
   \              6400        
   \   000000C0   636572746966       DC8 "certificate_unknown"
   \              69636174655F
   \              756E6B6E6F77
   \              6E00        
   \   000000D4   696C6C656761       DC8 "illegal_parameter"
   \              6C5F70617261
   \              6D6574657200
   \   000000E6   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL_read error!">`:
   \   00000000   53534C5F7265       DC8 "SSL_read error!"
   \              616420657272
   \              6F722100    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL_write Ok">`:
   \   00000000   53534C5F7772       DC8 "SSL_write Ok"
   \              697465204F6B
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   53534C207772       DC8 "SSL write==0"
   \              6974653D3D30
   \              00          
   \   0000001D   000000             DC8 0, 0, 0
   \   00000020   73736C5F7772       DC8 "ssl_write==0"
   \              6974653D3D30
   \              00          
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Session Remove">`:
   \   00000000   53657373696F       DC8 "Session Remove"
   \              6E2052656D6F
   \              766500      
   \   0000000F   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL connect...">`:
   \   00000000   53534C20636F       DC8 "SSL connect..."
   \              6E6E6563742E
   \              2E2E00      
   \   0000000F   00                 DC8 0
   \   00000010   53534C5F636F       DC8 "SSL_connect Error!"
   \              6E6E65637420
   \              4572726F7221
   \              00          
   \   00000023   00                 DC8 0
   \   00000024   53534C5F636F       DC8 "SSL_connect Ok!"
   \              6E6E65637420
   \              4F6B2100    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "GPRS offline...">`:
   \   00000000   47505253206F       DC8 "GPRS offline..."
   \              66666C696E65
   \              2E2E2E00    
   \   00000010   47505253206F       DC8 "GPRS online"
   \              6E6C696E6500
   \   0000001C   53534C5F5265       DC8 "SSL_Read OK"
   \              6164204F4B00
   \   00000028   627566666572       DC8 "buffer free!!!"
   \              206672656521
   \              212100      
   \   00000037   00                 DC8 0
   \   00000038   454E49505F42       DC8 "ENIP_BUFFER_FREE"
   \              55464645525F
   \              4652454500  
   \   00000049   000000             DC8 0, 0, 0
   \   0000004C   D1E5F0E2E5F0       DC8 "\321\345\360\342\345\360 %s \347\340\352\360\373\353 \361\356\345\344."
   \              20257320E7E0
   \              EAF0FBEB20F1
   \              EEE5E42E00  
   \   00000063   00                 DC8 0
    515          

   Maximum stack usage in bytes:

     Function                    CSTACK
     --------                    ------
     SSL_session_reused              0
     bread                          16
     bwrite                         20
     end_ssl                         8
     end_ssl_work                    4
     new_session                     8
     remove_session                  4
     ssl_connect                    32
     ssl_get_answer               4116
     ssl_send_answer                32
     ssl_socket_msg_handler         32
     tls1_alert_code_text            0
     tmr_connect_timeout_handler     4
     tmr_read_timeout_handler        4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SSL_MAX_SESS_COUNT                4
     tls1_alert_code_text            212
     SSL_session_reused                8
     bread                           132
     bwrite                          156
     tmr_connect_timeout_handler      36
     ?Subroutine14                     8
     tmr_read_timeout_handler         32
     end_ssl                          56
     end_ssl_work                     28
     ssl_get_answer                  200
     ssl_send_answer                 384
     ?Subroutine16                     8
     ?Subroutine15                    12
     new_session                      28
     remove_session                   56
     ssl_connect                     360
     ctx                               8
     recv_size                         4
     conn                              8
     ssl_socket_msg_handler          540
     ??DataTable10                     4
     ??DataTable11                     4
     ??DataTable13                     4
     ??DataTable15                     4
     ??DataTable16                     4
     ?<Initializer for SSL_MAX_SESS_COUNT>
                                       4
     ?<Constant "close_notify">      232
     ?<Constant "SSL_read error!">    16
     ?<Constant "SSL_write Ok">       48
     ?<Constant "Session Remove">     16
     ?<Constant "SSL connect...">     52
     ?<Constant "GPRS offline...">   100
      Others                         248

 
 2 500 bytes in segment CODE
   464 bytes in segment DATA_C
     4 bytes in segment DATA_I
     4 bytes in segment DATA_ID
    20 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 2 276 bytes of CODE  memory (+ 248 bytes shared)
   468 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
