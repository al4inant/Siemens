##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    16/Feb/2023  22:41:16 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON_Utils.c                                  #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON_Utils.c -D NEWSGOLD -D ELKA -D DEBUG     #
#                       -lCN D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK. #
#                       ELF_C\Release_ELKA\List\ -la                         #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\List\ -o D:\Users\alfinant\Documents\S #
#                       iemens\Dev\IAR\VK.ELF_C\Release_ELKA\Obj\ -z9        #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork --diag_suppress Pe301    #
#                       -e --fpu None --dlib_config                          #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\List\cJSON_Utils.lst                   #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Release_ELKA\Obj\cJSON_Utils.r79                    #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\json\cJSON_Utils.c
      1          /*
      2            Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
      3          
      4            Permission is hereby granted, free of charge, to any person obtaining a copy
      5            of this software and associated documentation files (the "Software"), to deal
      6            in the Software without restriction, including without limitation the rights
      7            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8            copies of the Software, and to permit persons to whom the Software is
      9            furnished to do so, subject to the following conditions:
     10          
     11            The above copyright notice and this permission notice shall be included in
     12            all copies or substantial portions of the Software.
     13          
     14            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     20            THE SOFTWARE.
     21          */
     22          
     23          /* disable warnings about old C89 functions in MSVC */
     24          #if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
     25          #define _CRT_SECURE_NO_DEPRECATE
     26          #endif
     27          
     28          #ifdef __GNUCC__
     29          #pragma GCC visibility push(default)
     30          #endif
     31          #if defined(_MSC_VER)
     32          #pragma warning (push)
     33          /* disable warning about single line comments in system headers */
     34          #pragma warning (disable : 4001)
     35          #endif
     36          
     37          #include <siemens\swilib.h>
     38          
     39          #include <ctype.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __intrinsic __code __interwork __atpcs int tolower(int)
   \                     tolower:
   \   00000000   410050E3           CMP      R0,#+65
   \   00000004   1EFF2FB1           BXLT     LR
   \   00000008   5B0050E3           CMP      R0,#+91
   \   0000000C   200080B2           ADDLT    R0,R0,#+32
   \   00000010   1EFF2FE1           BX       LR               ;; return
     40          //#include <string.h>
     41          //#include <stdlib.h>
     42          //#include <stdio.h>
     43          #include <limits.h>
     44          
     45          #if defined(_MSC_VER)
     46          #pragma warning (pop)
     47          #endif
     48          #ifdef __GNUCC__
     49          #pragma GCC visibility pop
     50          #endif
     51          
     52          #include "cJSON_Utils.h"
     53          
     54          /* define our own boolean type */
     55          #define true ((cJSON_bool)1)
     56          #define false ((cJSON_bool)0)
     57          

   \                                 In segment CODE, align 4, keep-with-next
     58          static unsigned char* cJSONUtils_strdup(const unsigned char* const string)
     59          {
   \                     cJSONUtils_strdup:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     60              size_t length = 0;
     61              unsigned char *copy = NULL;
     62          
     63              length = strlen((const char*)string) + sizeof("");
   \   00000008   1B0000EF           SWI      +27
   \   0000000C   015080E2           ADD      R5,R0,#+1
     64              copy = (unsigned char*) cJSON_malloc(length);
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000018   0060B0E1           MOVS     R6,R0
     65              if (copy == NULL)
     66              {
     67                  return NULL;
   \   0000001C   0000A003           MOVEQ    R0,#+0
   \   00000020   7080BD08           POPEQ    {R4-R6,PC}
     68              }
     69              memcpy(copy, string, length);
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   1E0100EF           SWI      +286
     70          
     71              return copy;
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   7080BDE8           POP      {R4-R6,PC}       ;; return
     72          }
     73          
     74          /* string comparison which doesn't consider NULL pointers equal */

   \                                 In segment CODE, align 4, keep-with-next
     75          static int compare_strings(const unsigned char *string1, const unsigned char *string2, const cJSON_bool case_sensitive)
     76          {
   \                     compare_strings:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     77              if ((string1 == NULL) || (string2 == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
     78              {
     79                  return 1;
   \   00000014   0100A003           MOVEQ    R0,#+1
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
     80              }
     81          
     82              if (string1 == string2)
   \   0000001C   050054E1           CMP      R4,R5
     83              {
     84                  return 0;
   \   00000020   0000A003           MOVEQ    R0,#+0
   \   00000024   7080BD08           POPEQ    {R4-R6,PC}
     85              }
     86          
     87              if (case_sensitive)
   \   00000028   000052E3           CMP      R2,#+0
   \   0000002C   0500000A           BEQ      ??compare_strings_0
     88              {
     89                  return strcmp((const char*)string1, (const char*)string2);
   \   00000030   190000EF           SWI      +25
   \   00000034   7080BDE8           POP      {R4-R6,PC}
     90              }
     91          
     92              for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
     93              {
     94                  if (*string1 == '\0')
   \                     ??compare_strings_1:
   \   00000038   ........           LDRB     R0,[R4], #+1
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   7080BD08           POPEQ    {R4-R6,PC}
     95                  {
     96                      return 0;
     97                  }
     98              }
   \   00000044   015085E2           ADD      R5,R5,#+1
   \                     ??compare_strings_0:
   \   00000048   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000004C   ........           _BLF     tolower,??tolower??rA
   \   00000050   0060A0E1           MOV      R6,R0
   \   00000054   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000058   ........           _BLF     tolower,??tolower??rA
   \   0000005C   000056E1           CMP      R6,R0
   \   00000060   F4FFFF0A           BEQ      ??compare_strings_1
     99          
    100              return tolower(*string1) - tolower(*string2);
   \   00000064   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000068   ........           _BLF     tolower,??tolower??rA
   \   0000006C   0040A0E1           MOV      R4,R0
   \   00000070   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000074   ........           _BLF     tolower,??tolower??rA
   \   00000078   000044E0           SUB      R0,R4,R0
   \   0000007C   7080BDE8           POP      {R4-R6,PC}       ;; return
    101          }
    102          
    103          /* Compare the next path element of two JSON pointers, two NULL pointers are considered unequal: */

   \                                 In segment CODE, align 4, keep-with-next
    104          static cJSON_bool compare_pointers(const unsigned char *name, const unsigned char *pointer, const cJSON_bool case_sensitive)
    105          {
   \                     compare_pointers:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   0250A0E1           MOV      R5,R2
    106              if ((name == NULL) || (pointer == NULL))
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0900000A           BEQ      ??compare_pointers_0
   \   00000018   000056E3           CMP      R6,#+0
   \   0000001C   0B00001A           BNE      ??compare_pointers_1
    107              {
    108                  return false;
   \   00000020   060000EA           B        ??compare_pointers_0
    109              }
    110          
    111              for (; (*name != '\0') && (*pointer != '\0') && (*pointer != '/'); (void)name++, pointer++) /* compare until next '/' */
    112              {
    113                  if (*pointer == '~')
    114                  {
    115                      /* check for escaped '~' (~0) and '/' (~1) */
    116                      if (((pointer[1] != '0') || (*name != '~')) && ((pointer[1] != '1') || (*name != '/')))
   \                     ??compare_pointers_2:
   \   00000024   0110D6E5           LDRB     R1,[R6, #+1]
   \   00000028   300051E3           CMP      R1,#+48
   \   0000002C   7E005003           CMPEQ    R0,#+126
   \   00000030   0300000A           BEQ      ??compare_pointers_3
   \   00000034   310051E3           CMP      R1,#+49
   \   00000038   2F005003           CMPEQ    R0,#+47
   \   0000003C   0000000A           BEQ      ??compare_pointers_3
    117                      {
    118                          /* invalid escape sequence or wrong character in *name */
    119                          return false;
   \                     ??compare_pointers_0:
   \   00000040   ........           B        ?Subroutine34
    120                      }
    121                      else
    122                      {
    123                          pointer++;
   \                     ??compare_pointers_3:
   \   00000044   016086E2           ADD      R6,R6,#+1
    124                      }
    125                  }
   \                     ??compare_pointers_4:
   \   00000048   014084E2           ADD      R4,R4,#+1
   \   0000004C   016086E2           ADD      R6,R6,#+1
   \                     ??compare_pointers_1:
   \   00000050   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0010D615           LDRBNE   R1,[R6, #+0]
   \   0000005C   00005113           CMPNE    R1,#+0
   \   00000060   2F005113           CMPNE    R1,#+47
   \   00000064   0D00000A           BEQ      ??compare_pointers_5
   \   00000068   7E0051E3           CMP      R1,#+126
   \   0000006C   ECFFFF0A           BEQ      ??compare_pointers_2
    126                  else if ((!case_sensitive && (tolower(*name) != tolower(*pointer))) || (case_sensitive && (*name != *pointer)))
   \   00000070   000055E3           CMP      R5,#+0
   \   00000074   0600001A           BNE      ??compare_pointers_6
   \   00000078   ........           _BLF     tolower,??tolower??rA
   \   0000007C   0070A0E1           MOV      R7,R0
   \   00000080   0000D6E5           LDRB     R0,[R6, #+0]
   \   00000084   ........           _BLF     tolower,??tolower??rA
   \   00000088   000057E1           CMP      R7,R0
   \   0000008C   EBFFFF1A           BNE      ??compare_pointers_0
   \   00000090   ECFFFFEA           B        ??compare_pointers_4
   \                     ??compare_pointers_6:
   \   00000094   010050E1           CMP      R0,R1
   \   00000098   EAFFFF0A           BEQ      ??compare_pointers_4
    127                  {
    128                      return false;
   \   0000009C   E7FFFFEA           B        ??compare_pointers_0
    129                  }
    130              }
    131              if (((*pointer != 0) && (*pointer != '/')) != (*name != 0))
   \                     ??compare_pointers_5:
   \   000000A0   0000D6E5           LDRB     R0,[R6, #+0]
   \   000000A4   0030D4E5           LDRB     R3,[R4, #+0]
   \   000000A8   0110A0E3           MOV      R1,#+1
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   2F005013           CMPNE    R0,#+47
   \   000000B4   0100A013           MOVNE    R0,#+1
   \   000000B8   0000A003           MOVEQ    R0,#+0
   \   000000BC   000053E3           CMP      R3,#+0
   \   000000C0   0010A003           MOVEQ    R1,#+0
   \   000000C4   010050E1           CMP      R0,R1
   \   000000C8   DCFFFF1A           BNE      ??compare_pointers_0
    132              {
    133                  /* one string has ended, the other not */
    134                  return false;;
    135              }
    136          
    137              return true;
   \   000000CC   0100A0E3           MOV      R0,#+1
   \   000000D0   F080BDE8           POP      {R4-R7,PC}       ;; return
    138          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine34:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   F080BDE8           POP      {R4-R7,PC}
    139          
    140          /* calculate the length of a string if encoded as JSON pointer with ~0 and ~1 escape sequences */

   \                                 In segment CODE, align 4, keep-with-next
    141          static size_t pointer_encoded_length(const unsigned char *string)
    142          {
    143              size_t length;
    144              for (length = 0; *string != '\0'; (void)string++, length++)
   \                     pointer_encoded_length:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   040000EA           B        ??pointer_encoded_length_0
    145              {
    146                  /* character needs to be escaped? */
    147                  if ((*string == '~') || (*string == '/'))
   \                     ??pointer_encoded_length_1:
   \   00000008   7E0052E3           CMP      R2,#+126
   \   0000000C   2F005213           CMPNE    R2,#+47
    148                  {
    149                      length++;
   \   00000010   01108102           ADDEQ    R1,R1,#+1
    150                  }
    151              }
   \   00000014   010080E2           ADD      R0,R0,#+1
   \   00000018   011081E2           ADD      R1,R1,#+1
   \                     ??pointer_encoded_length_0:
   \   0000001C   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000020   000052E3           CMP      R2,#+0
   \   00000024   F7FFFF1A           BNE      ??pointer_encoded_length_1
    152          
    153              return length;
   \   00000028   0100A0E1           MOV      R0,R1
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    154          }
    155          
    156          /* copy a string while escaping '~' and '/' with ~0 and ~1 JSON pointer escape codes */

   \                                 In segment CODE, align 4, keep-with-next
    157          static void encode_string_as_pointer(unsigned char *destination, const unsigned char *source)
    158          {
   \                     encode_string_as_pointer:
   \   00000000   010000EA           B        ??encode_string_as_pointer_0
    159              for (; source[0] != '\0'; (void)source++, destination++)
    160              {
    161                  if (source[0] == '/')
    162                  {
    163                      destination[1] = '1';
    164                      destination++;
    165                  }
    166                  else if (source[0] == '~')
    167                  {
    168                      destination[0] = '~';
    169                      destination[1] = '1';
    170                      destination++;
    171                  }
    172                  else
    173                  {
    174                      destination[0] = source[0];
   \                     ??encode_string_as_pointer_1:
   \   00000004   011081E2           ADD      R1,R1,#+1
   \   00000008   010080E2           ADD      R0,R0,#+1
   \                     ??encode_string_as_pointer_0:
   \   0000000C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000010   000052E3           CMP      R2,#+0
   \   00000014   0900000A           BEQ      ??encode_string_as_pointer_2
   \   00000018   2F0052E3           CMP      R2,#+47
   \   0000001C   0300001A           BNE      ??encode_string_as_pointer_3
   \                     ??encode_string_as_pointer_4:
   \   00000020   3120A0E3           MOV      R2,#+49
   \   00000024   0120C0E5           STRB     R2,[R0, #+1]
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   F4FFFFEA           B        ??encode_string_as_pointer_1
   \                     ??encode_string_as_pointer_3:
   \   00000030   7E0052E3           CMP      R2,#+126
   \   00000034   0020C0E5           STRB     R2,[R0, #+0]
   \   00000038   F1FFFF1A           BNE      ??encode_string_as_pointer_1
   \   0000003C   F7FFFFEA           B        ??encode_string_as_pointer_4
    175                  }
    176              }
    177          
    178              destination[0] = '\0';
   \                     ??encode_string_as_pointer_2:
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   0010C0E5           STRB     R1,[R0, #+0]
    179          }
   \   00000048   1EFF2FE1           BX       LR               ;; return
    180          

   \                                 In segment CODE, align 4, keep-with-next
    181          CJSON_PUBLIC(char *) cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target)
    182          {
   \                     cJSONUtils_FindPointerFromObjectTo:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0170A0E1           MOV      R7,R1
    183              size_t child_index = 0;
   \   0000000C   0080A0E3           MOV      R8,#+0
    184              cJSON *current_child = 0;
    185          
    186              if ((object == NULL) || (target == NULL))
   \   00000010   000056E3           CMP      R6,#+0
   \   00000014   00005713           CMPNE    R7,#+0
    187              {
    188                  return NULL;
   \   00000018   0000A003           MOVEQ    R0,#+0
   \   0000001C   F081BD08           POPEQ    {R4-R8,PC}
    189              }
    190          
    191              if (object == target)
   \   00000020   070056E1           CMP      R6,R7
   \   00000024   0200001A           BNE      ??cJSONUtils_FindPointerFromObjectTo_0
    192              {
    193                  /* found */
    194                  return (char*)cJSONUtils_strdup((const unsigned char*)"");
   \   00000028   ........           ADR      R0,??DataTable0  ;; ""
   \   0000002C   ........           BL       cJSONUtils_strdup
   \   00000030   F081BDE8           POP      {R4-R8,PC}
    195              }
    196          
    197              /* recursively search all children of the object or array */
    198              for (current_child = object->child; current_child != NULL; (void)(current_child = current_child->next), child_index++)
   \                     ??cJSONUtils_FindPointerFromObjectTo_0:
   \   00000034   085096E5           LDR      R5,[R6, #+8]
   \   00000038   010000EA           B        ??cJSONUtils_FindPointerFromObjectTo_1
   \                     ??cJSONUtils_FindPointerFromObjectTo_2:
   \   0000003C   005095E5           LDR      R5,[R5, #+0]
   \   00000040   018088E2           ADD      R8,R8,#+1
   \                     ??cJSONUtils_FindPointerFromObjectTo_1:
   \   00000044   000055E3           CMP      R5,#+0
   \   00000048   2F00000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_3
    199              {
    200                  unsigned char *target_pointer = (unsigned char*)cJSONUtils_FindPointerFromObjectTo(current_child, target);
   \   0000004C   0710A0E1           MOV      R1,R7
   \   00000050   0500A0E1           MOV      R0,R5
   \   00000054   E9FFFFEB           BL       cJSONUtils_FindPointerFromObjectTo
   \   00000058   0040B0E1           MOVS     R4,R0
    201                  /* found the target? */
    202                  if (target_pointer != NULL)
   \   0000005C   F6FFFF0A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_2
    203                  {
    204                      if (cJSON_IsArray(object))
   \   00000060   0600A0E1           MOV      R0,R6
   \   00000064   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0C00000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_4
    205                      {
    206                          /* reserve enough memory for a 64 bit integer + '/' and '\0' */
    207                          unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + 20 + sizeof("/"));
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   1B0000EF           SWI      +27
   \   00000078   160080E2           ADD      R0,R0,#+22
   \   0000007C   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
    208                          /* check if conversion to unsigned long is valid
    209                           * This should be eliminated at compile time by dead code elimination
    210                           * if size_t is an alias of unsigned long, or if it is bigger */
    211                          if (child_index > ULONG_MAX)
    212                          {
    213                              cJSON_free(target_pointer);
    214                              return NULL;
    215                          }
    216                          sprintf((char*)full_pointer, "/%lu%s", (unsigned long)child_index, target_pointer); /* /<array_index><path> */
   \   00000080   8C109FE5           LDR      R1,??cJSONUtils_FindPointerFromObjectTo_5  ;; `?<Constant "/%lu%s">`
   \   00000084   0050A0E1           MOV      R5,R0
   \   00000088   0430A0E1           MOV      R3,R4
   \   0000008C   0820A0E1           MOV      R2,R8
   \   00000090   160000EF           SWI      +22
    217                          cJSON_free(target_pointer);
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           _BLF     cJSON_free,??cJSON_free??rA
    218          
    219                          return (char*)full_pointer;
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   F081BDE8           POP      {R4-R8,PC}
    220                      }
    221          
    222                      if (cJSON_IsObject(object))
   \                     ??cJSONUtils_FindPointerFromObjectTo_4:
   \   000000A4   0600A0E1           MOV      R0,R6
   \   000000A8   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   1300000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_6
    223                      {
    224                          unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + pointer_encoded_length((unsigned char*)current_child->string) + 2);
   \   000000B8   1B0000EF           SWI      +27
   \   000000BC   0060A0E1           MOV      R6,R0
   \   000000C0   200095E5           LDR      R0,[R5, #+32]
   \   000000C4   ........           BL       pointer_encoded_length
   \   000000C8   060080E0           ADD      R0,R0,R6
   \   000000CC   020080E2           ADD      R0,R0,#+2
   \   000000D0   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   000000D4   0060A0E1           MOV      R6,R0
    225                          full_pointer[0] = '/';
   \   000000D8   2F00A0E3           MOV      R0,#+47
   \   000000DC   0000C6E5           STRB     R0,[R6, #+0]
    226                          encode_string_as_pointer(full_pointer + 1, (unsigned char*)current_child->string);
   \   000000E0   201095E5           LDR      R1,[R5, #+32]
   \   000000E4   010086E2           ADD      R0,R6,#+1
   \   000000E8   ........           BL       encode_string_as_pointer
    227                          strcat((char*)full_pointer, (char*)target_pointer);
   \   000000EC   0410A0E1           MOV      R1,R4
   \   000000F0   0600A0E1           MOV      R0,R6
   \   000000F4   170000EF           SWI      +23
    228                          cJSON_free(target_pointer);
   \   000000F8   0400A0E1           MOV      R0,R4
   \   000000FC   ........           _BLF     cJSON_free,??cJSON_free??rA
    229          
    230                          return (char*)full_pointer;
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   F081BDE8           POP      {R4-R8,PC}
    231                      }
    232          
    233                      /* reached leaf of the tree, found nothing */
    234                      cJSON_free(target_pointer);
   \                     ??cJSONUtils_FindPointerFromObjectTo_6:
   \   00000108   ........           _BLF     cJSON_free,??cJSON_free??rA
    235                      return NULL;
    236                  }
    237              }
    238          
    239              /* not found */
    240              return NULL;
   \                     ??cJSONUtils_FindPointerFromObjectTo_3:
   \   0000010C   0000A0E3           MOV      R0,#+0
   \   00000110   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??cJSONUtils_FindPointerFromObjectTo_5:
   \   00000114   ........           DC32     `?<Constant "/%lu%s">`
    241          }
    242          
    243          /* non broken version of cJSON_GetArrayItem */
    244          static cJSON *get_array_item(const cJSON *array, size_t item)
    245          {
    246              cJSON *child = array ? array->child : NULL;
    247              while ((child != NULL) && (item > 0))
    248              {
    249                  item--;
    250                  child = child->next;
    251              }
    252          
    253              return child;
    254          }
    255          

   \                                 In segment CODE, align 4, keep-with-next
    256          static cJSON_bool decode_array_index_from_pointer(const unsigned char * const pointer, size_t * const index)
    257          {
   \                     decode_array_index_from_pointer:
   \   00000000   10002DE9           PUSH     {R4}
    258              size_t parsed_index = 0;
    259              size_t position = 0;
    260          
    261              if ((pointer[0] == '0') && ((pointer[1] != '\0') && (pointer[1] != '/')))
   \   00000004   00C0D0E5           LDRB     R12,[R0, #+0]
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   30005CE3           CMP      R12,#+48
   \   00000014   0A00001A           BNE      ??decode_array_index_from_pointer_0
   \   00000018   01C0D0E5           LDRB     R12,[R0, #+1]
   \   0000001C   00005CE3           CMP      R12,#+0
   \   00000020   2F005C13           CMPNE    R12,#+47
   \   00000024   0600000A           BEQ      ??decode_array_index_from_pointer_0
    262              {
    263                  /* leading zeroes are not permitted */
    264                  return 0;
   \                     ??decode_array_index_from_pointer_1:
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   110000EA           B        ??decode_array_index_from_pointer_2
    265              }
    266          
    267              for (position = 0; (pointer[position] >= '0') && (pointer[0] <= '9'); position++)
    268              {
    269                  parsed_index = (10 * parsed_index) + (size_t)(pointer[position] - '0');
   \                     ??decode_array_index_from_pointer_3:
   \   00000030   00C0DCE5           LDRB     R12,[R12, #+0]
   \   00000034   0A40A0E3           MOV      R4,#+10
    270          
    271              }
   \   00000038   013083E2           ADD      R3,R3,#+1
   \   0000003C   30C04CE2           SUB      R12,R12,#+48
   \   00000040   94C222E0           MLA      R2,R4,R2,R12
   \                     ??decode_array_index_from_pointer_0:
   \   00000044   00C083E0           ADD      R12,R3,R0
   \   00000048   0040DCE5           LDRB     R4,[R12, #+0]
   \   0000004C   300054E3           CMP      R4,#+48
   \   00000050   0200003A           BCC      ??decode_array_index_from_pointer_4
   \   00000054   0040D0E5           LDRB     R4,[R0, #+0]
   \   00000058   3A0054E3           CMP      R4,#+58
   \   0000005C   F3FFFF3A           BCC      ??decode_array_index_from_pointer_3
    272          
    273              if ((pointer[position] != '\0') && (pointer[position] != '/'))
   \                     ??decode_array_index_from_pointer_4:
   \   00000060   0000DCE5           LDRB     R0,[R12, #+0]
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   2F005013           CMPNE    R0,#+47
   \   0000006C   EDFFFF1A           BNE      ??decode_array_index_from_pointer_1
    274              {
    275                  return 0;
    276              }
    277          
    278              *index = parsed_index;
   \   00000070   002081E5           STR      R2,[R1, #+0]
    279          
    280              return 1;
   \   00000074   0100A0E3           MOV      R0,#+1
   \                     ??decode_array_index_from_pointer_2:
   \   00000078   1000BDE8           POP      {R4}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    281          }
    282          

   \                                 In segment CODE, align 4, keep-with-next
    283          static cJSON *get_item_from_pointer(cJSON * const object, const char * pointer, const cJSON_bool case_sensitive)
    284          {
   \                     get_item_from_pointer:
   \   00000000   F1402DE9           PUSH     {R0,R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0060A0E1           MOV      R6,R0
   \   0000000C   0250A0E1           MOV      R5,R2
    285              cJSON *current_element = object;
    286          
    287              if (pointer == NULL)
   \   00000010   000054E3           CMP      R4,#+0
   \   00000014   0070A0E3           MOV      R7,#+0
    288              {
    289                  return NULL;
   \   00000018   0000A003           MOVEQ    R0,#+0
   \   0000001C   F280BD08           POPEQ    {R1,R4-R7,PC}
    290              }
    291          
    292              /* follow path of the pointer */
    293              while ((pointer[0] == '/') && (current_element != NULL))
   \                     ??get_item_from_pointer_0:
   \   00000020   ........           LDRB     R0,[R4], #+1
   \   00000024   2F0050E3           CMP      R0,#+47
   \   00000028   2C00001A           BNE      ??get_item_from_pointer_1
   \   0000002C   000056E3           CMP      R6,#+0
   \   00000030   2A00000A           BEQ      ??get_item_from_pointer_1
    294              {
    295                  pointer++;
    296                  if (cJSON_IsArray(current_element))
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   1100000A           BEQ      ??get_item_from_pointer_2
    297                  {
    298                      size_t index = 0;
   \   00000044   00708DE5           STR      R7,[SP, #+0]
    299                      if (!decode_array_index_from_pointer((const unsigned char*)pointer, &index))
   \   00000048   0D10A0E1           MOV      R1,SP
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           BL       decode_array_index_from_pointer
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   F280BD08           POPEQ    {R1,R4-R7,PC}
    300                      {
    301                          return NULL;
    302                      }
    303          
    304                      current_element = get_array_item(current_element, index);
   \   0000005C   00009DE5           LDR      R0,[SP, #+0]
   \   00000060   000056E3           CMP      R6,#+0
   \   00000064   1700000A           BEQ      ??get_item_from_pointer_3
   \   00000068   086096E5           LDR      R6,[R6, #+8]
   \   0000006C   010000EA           B        ??get_item_from_pointer_4
   \                     ??get_item_from_pointer_5:
   \   00000070   006096E5           LDR      R6,[R6, #+0]
   \   00000074   010040E2           SUB      R0,R0,#+1
   \                     ??get_item_from_pointer_4:
   \   00000078   000056E3           CMP      R6,#+0
   \   0000007C   1100000A           BEQ      ??get_item_from_pointer_3
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   F9FFFF1A           BNE      ??get_item_from_pointer_5
   \   00000088   0E0000EA           B        ??get_item_from_pointer_3
    305                  }
    306                  else if (cJSON_IsObject(current_element))
   \                     ??get_item_from_pointer_2:
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   F280BD08           POPEQ    {R1,R4-R7,PC}
    307                  {
    308                      current_element = current_element->child;
   \   0000009C   086096E5           LDR      R6,[R6, #+8]
   \   000000A0   000000EA           B        ??get_item_from_pointer_6
    309                      /* GetObjectItem. */
    310                      while ((current_element != NULL) && !compare_pointers((unsigned char*)current_element->string, (const unsigned char*)pointer, case_sensitive))
    311                      {
    312                          current_element = current_element->next;
   \                     ??get_item_from_pointer_7:
   \   000000A4   006096E5           LDR      R6,[R6, #+0]
    313                      }
   \                     ??get_item_from_pointer_6:
   \   000000A8   000056E3           CMP      R6,#+0
   \   000000AC   0500000A           BEQ      ??get_item_from_pointer_3
   \   000000B0   200096E5           LDR      R0,[R6, #+32]
   \   000000B4   0520A0E1           MOV      R2,R5
   \   000000B8   0410A0E1           MOV      R1,R4
   \   000000BC   ........           BL       compare_pointers
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   F6FFFF0A           BEQ      ??get_item_from_pointer_7
    314                  }
    315                  else
    316                  {
    317                      return NULL;
    318                  }
    319          
    320                  /* skip to the next path token or end of string */
    321                  while ((pointer[0] != '\0') && (pointer[0] != '/'))
   \                     ??get_item_from_pointer_3:
   \   000000C8   0000D4E5           LDRB     R0,[R4, #+0]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   2F005013           CMPNE    R0,#+47
   \   000000D4   D1FFFF0A           BEQ      ??get_item_from_pointer_0
    322                  {
    323                      pointer++;
   \   000000D8   014084E2           ADD      R4,R4,#+1
   \   000000DC   F9FFFFEA           B        ??get_item_from_pointer_3
    324                  }
    325              }
    326          
    327              return current_element;
   \                     ??get_item_from_pointer_1:
   \   000000E0   0600A0E1           MOV      R0,R6
   \   000000E4   F280BDE8           POP      {R1,R4-R7,PC}    ;; return
    328          }
    329          

   \                                 In segment CODE, align 4, keep-with-next
    330          CJSON_PUBLIC(cJSON *) cJSONUtils_GetPointer(cJSON * const object, const char *pointer)
    331          {
    332              return get_item_from_pointer(object, pointer, false);
   \                     cJSONUtils_GetPointer:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        get_item_from_pointer  ;; tailcall
    333          }
    334          

   \                                 In segment CODE, align 4, keep-with-next
    335          CJSON_PUBLIC(cJSON *) cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer)
    336          {
    337              return get_item_from_pointer(object, pointer, true);
   \                     cJSONUtils_GetPointerCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        get_item_from_pointer  ;; tailcall
    338          }
    339          
    340          /* JSON Patch implementation. */

   \                                 In segment CODE, align 4, keep-with-next
    341          static void decode_pointer_inplace(unsigned char *string)
    342          {
    343              unsigned char *decoded_string = string;
   \                     decode_pointer_inplace:
   \   00000000   0010B0E1           MOVS     R1,R0
    344          
    345              if (string == NULL) {
   \   00000004   0700001A           BNE      ??decode_pointer_inplace_0
   \   00000008   1EFF2FE1           BX       LR
    346                  return;
    347              }
    348          
    349              for (; *string; (void)decoded_string++, string++)
    350              {
    351                  if (string[0] == '~')
    352                  {
    353                      if (string[1] == '0')
    354                      {
    355                          decoded_string[0] = '~';
    356                      }
    357                      else if (string[1] == '1')
   \                     ??decode_pointer_inplace_1:
   \   0000000C   310052E3           CMP      R2,#+49
   \   00000010   1EFF2F11           BXNE     LR
    358                      {
    359                          decoded_string[1] = '/';
   \   00000014   2F20A0E3           MOV      R2,#+47
   \   00000018   0120C1E5           STRB     R2,[R1, #+1]
    360                      }
    361                      else
    362                      {
    363                          /* invalid escape sequence */
    364                          return;
    365                      }
    366          
    367                      string++;
   \                     ??decode_pointer_inplace_2:
   \   0000001C   010080E2           ADD      R0,R0,#+1
   \                     ??decode_pointer_inplace_3:
   \   00000020   011081E2           ADD      R1,R1,#+1
   \   00000024   010080E2           ADD      R0,R0,#+1
   \                     ??decode_pointer_inplace_0:
   \   00000028   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   0700000A           BEQ      ??decode_pointer_inplace_4
   \   00000034   7E0052E3           CMP      R2,#+126
   \   00000038   F8FFFF1A           BNE      ??decode_pointer_inplace_3
   \   0000003C   0120D0E5           LDRB     R2,[R0, #+1]
   \   00000040   300052E3           CMP      R2,#+48
   \   00000044   F0FFFF1A           BNE      ??decode_pointer_inplace_1
   \   00000048   7E20A0E3           MOV      R2,#+126
   \   0000004C   0020C1E5           STRB     R2,[R1, #+0]
   \   00000050   F1FFFFEA           B        ??decode_pointer_inplace_2
    368                  }
    369              }
    370          
    371              decoded_string[0] = '\0';
   \                     ??decode_pointer_inplace_4:
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   0000C1E5           STRB     R0,[R1, #+0]
    372          }
   \   0000005C   1EFF2FE1           BX       LR               ;; return
    373          
    374          /* non-broken cJSON_DetachItemFromArray */
    375          static cJSON *detach_item_from_array(cJSON *array, size_t which)
    376          {
    377              cJSON *c = array->child;
    378              while (c && (which > 0))
    379              {
    380                  c = c->next;
    381                  which--;
    382              }
    383              if (!c)
    384              {
    385                  /* item doesn't exist */
    386                  return NULL;
    387              }
    388              if (c->prev)
    389              {
    390                  /* not the first element */
    391                  c->prev->next = c->next;
    392              }
    393              if (c->next)
    394              {
    395                  c->next->prev = c->prev;
    396              }
    397              if (c==array->child)
    398              {
    399                  array->child = c->next;
    400              }
    401              /* make sure the detached item doesn't point anywhere anymore */
    402              c->prev = c->next = NULL;
    403          
    404              return c;
    405          }
    406          
    407          /* detach an item at the given path */

   \                                 In segment CODE, align 4, keep-with-next
    408          static cJSON *detach_path(cJSON *object, const unsigned char *path, const cJSON_bool case_sensitive)
    409          {
   \                     detach_path:
   \   00000000   F1432DE9           PUSH     {R0,R4-R9,LR}
   \   00000004   0070A0E1           MOV      R7,R0
   \   00000008   0100A0E1           MOV      R0,R1
   \   0000000C   0280A0E1           MOV      R8,R2
    410              unsigned char *parent_pointer = NULL;
    411              unsigned char *child_pointer = NULL;
    412              cJSON *parent = NULL;
    413              cJSON *detached_item = NULL;
   \   00000010   0040A0E3           MOV      R4,#+0
   \   00000014   0050A0E3           MOV      R5,#+0
    414          
    415              /* copy path and split it in parent and child */
    416              parent_pointer = cJSONUtils_strdup(path);
   \   00000018   ........           BL       cJSONUtils_strdup
   \   0000001C   0060B0E1           MOVS     R6,R0
    417              if (parent_pointer == NULL) {
   \   00000020   3800000A           BEQ      ??detach_path_0
    418                  goto cleanup;
    419              }
    420          
    421              child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/'); /* last '/' */
   \   00000024   2F10A0E3           MOV      R1,#+47
   \   00000028   170100EF           SWI      +279
   \   0000002C   0090B0E1           MOVS     R9,R0
    422              if (child_pointer == NULL)
   \   00000030   3200000A           BEQ      ??detach_path_1
    423              {
    424                  goto cleanup;
    425              }
    426              /* split strings */
    427              child_pointer[0] = '\0';
   \   00000034   ........           STRB     R4,[R9], #+1
    428              child_pointer++;
    429          
    430              parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);
   \   00000038   0820A0E1           MOV      R2,R8
   \   0000003C   0610A0E1           MOV      R1,R6
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   ........           BL       get_item_from_pointer
   \   00000048   0070A0E1           MOV      R7,R0
    431              decode_pointer_inplace(child_pointer);
   \   0000004C   0900A0E1           MOV      R0,R9
   \   00000050   ........           BL       decode_pointer_inplace
    432          
    433              if (cJSON_IsArray(parent))
   \   00000054   0700A0E1           MOV      R0,R7
   \   00000058   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   1E00000A           BEQ      ??detach_path_2
    434              {
    435                  size_t index = 0;
   \   00000064   00408DE5           STR      R4,[SP, #+0]
    436                  if (!decode_array_index_from_pointer(child_pointer, &index))
   \   00000068   0D10A0E1           MOV      R1,SP
   \   0000006C   0900A0E1           MOV      R0,R9
   \   00000070   ........           BL       decode_array_index_from_pointer
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   2000000A           BEQ      ??detach_path_1
    437                  {
    438                      goto cleanup;
    439                  }
    440                  detached_item = detach_item_from_array(parent, index);
   \   0000007C   00009DE5           LDR      R0,[SP, #+0]
   \   00000080   081097E5           LDR      R1,[R7, #+8]
   \   00000084   010000EA           B        ??detach_path_3
   \                     ??detach_path_4:
   \   00000088   001091E5           LDR      R1,[R1, #+0]
   \   0000008C   010040E2           SUB      R0,R0,#+1
   \                     ??detach_path_3:
   \   00000090   000051E3           CMP      R1,#+0
   \   00000094   1900000A           BEQ      ??detach_path_1
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   F9FFFF1A           BNE      ??detach_path_4
   \   000000A0   040091E5           LDR      R0,[R1, #+4]
   \   000000A4   0150A0E1           MOV      R5,R1
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   00209115           LDRNE    R2,[R1, #+0]
   \   000000B0   00208015           STRNE    R2,[R0, #+0]
   \   000000B4   000091E5           LDR      R0,[R1, #+0]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   04209115           LDRNE    R2,[R1, #+4]
   \   000000C0   04208015           STRNE    R2,[R0, #+4]
   \   000000C4   080097E5           LDR      R0,[R7, #+8]
   \   000000C8   000051E1           CMP      R1,R0
   \   000000CC   00009105           LDREQ    R0,[R1, #+0]
   \   000000D0   08008705           STREQ    R0,[R7, #+8]
   \   000000D4   004081E5           STR      R4,[R1, #+0]
   \   000000D8   044081E5           STR      R4,[R1, #+4]
   \   000000DC   070000EA           B        ??detach_path_1
    441              }
    442              else if (cJSON_IsObject(parent))
   \                     ??detach_path_2:
   \   000000E0   0700A0E1           MOV      R0,R7
   \   000000E4   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   0300000A           BEQ      ??detach_path_1
    443              {
    444                  detached_item = cJSON_DetachItemFromObject(parent, (char*)child_pointer);
   \   000000F0   0910A0E1           MOV      R1,R9
   \   000000F4   0700A0E1           MOV      R0,R7
   \   000000F8   ........           _BLF     cJSON_DetachItemFromObject,??cJSON_DetachItemFromObject??rA
   \   000000FC   0050A0E1           MOV      R5,R0
    445              }
    446              else
    447              {
    448                  /* Couldn't find object to remove child from. */
    449                  goto cleanup;
    450              }
    451          
    452          cleanup:
    453              if (parent_pointer != NULL)
    454              {
    455                  cJSON_free(parent_pointer);
   \                     ??detach_path_1:
   \   00000100   0600A0E1           MOV      R0,R6
   \   00000104   ........           _BLF     cJSON_free,??cJSON_free??rA
    456              }
    457          
    458              return detached_item;
   \                     ??detach_path_0:
   \   00000108   0500A0E1           MOV      R0,R5
   \   0000010C   F283BDE8           POP      {R1,R4-R9,PC}    ;; return
    459          }
    460          
    461          /* sort lists using mergesort */

   \                                 In segment CODE, align 4, keep-with-next
    462          static cJSON *sort_list(cJSON *list, const cJSON_bool case_sensitive)
    463          {
   \                     sort_list:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0080A0E1           MOV      R8,R0
    464              cJSON *first = list;
    465              cJSON *second = list;
   \   0000000C   0870A0E1           MOV      R7,R8
    466              cJSON *current_item = list;
   \   00000010   0890A0E1           MOV      R9,R8
    467              cJSON *result = list;
    468              cJSON *result_tail = NULL;
   \   00000014   0050A0E3           MOV      R5,#+0
   \   00000018   0060A0E3           MOV      R6,#+0
    469          
    470              if ((list == NULL) || (list->next == NULL))
   \   0000001C   000058E3           CMP      R8,#+0
   \   00000020   4400000A           BEQ      ??sort_list_0
   \   00000024   000098E5           LDR      R0,[R8, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0300001A           BNE      ??sort_list_1
    471              {
    472                  /* One entry is sorted already. */
    473                  return result;
   \   00000030   400000EA           B        ??sort_list_0
    474              }
    475          
    476              while ((current_item != NULL) && (current_item->next != NULL) && (compare_strings((unsigned char*)current_item->string, (unsigned char*)current_item->next->string, case_sensitive) < 0))
    477              {
    478                  /* Test for list sorted. */
    479                  current_item = current_item->next;
   \                     ??sort_list_2:
   \   00000034   009099E5           LDR      R9,[R9, #+0]
    480              }
   \   00000038   000059E3           CMP      R9,#+0
   \   0000003C   3D00000A           BEQ      ??sort_list_0
   \                     ??sort_list_1:
   \   00000040   000099E5           LDR      R0,[R9, #+0]
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??sort_list_3
   \   0000004C   201090E5           LDR      R1,[R0, #+32]
   \   00000050   200099E5           LDR      R0,[R9, #+32]
   \   00000054   0420A0E1           MOV      R2,R4
   \   00000058   ........           BL       compare_strings
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   F3FFFF4A           BMI      ??sort_list_2
   \                     ??sort_list_3:
   \   00000064   000099E5           LDR      R0,[R9, #+0]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   3100000A           BEQ      ??sort_list_0
    481              if ((current_item == NULL) || (current_item->next == NULL))
    482              {
    483                  /* Leave sorted lists unmodified. */
    484                  return result;
    485              }
    486          
    487              /* reset pointer to the beginning */
    488              current_item = list;
   \   00000070   0890A0E1           MOV      R9,R8
    489              while (current_item != NULL)
    490              {
    491                  /* Walk two pointers to find the middle. */
    492                  second = second->next;
    493                  current_item = current_item->next;
   \                     ??sort_list_4:
   \   00000074   009099E5           LDR      R9,[R9, #+0]
   \   00000078   007097E5           LDR      R7,[R7, #+0]
    494                  /* advances current_item two steps at a time */
    495                  if (current_item != NULL)
   \   0000007C   000059E3           CMP      R9,#+0
    496                  {
    497                      current_item = current_item->next;
   \   00000080   00909915           LDRNE    R9,[R9, #+0]
    498                  }
    499              }
   \   00000084   000059E3           CMP      R9,#+0
   \   00000088   F9FFFF1A           BNE      ??sort_list_4
    500              if ((second != NULL) && (second->prev != NULL))
   \   0000008C   000057E3           CMP      R7,#+0
   \   00000090   04009715           LDRNE    R0,[R7, #+4]
    501              {
    502                  /* Split the lists */
    503                  second->prev->next = NULL;
    504              }
    505          
    506              /* Recursively sort the sub-lists. */
    507              first = sort_list(first, case_sensitive);
   \   00000094   0410A0E1           MOV      R1,R4
   \   00000098   00005013           CMPNE    R0,#+0
   \   0000009C   00508015           STRNE    R5,[R0, #+0]
   \   000000A0   0800A0E1           MOV      R0,R8
   \   000000A4   D5FFFFEB           BL       sort_list
   \   000000A8   0080A0E1           MOV      R8,R0
    508              second = sort_list(second, case_sensitive);
   \   000000AC   0410A0E1           MOV      R1,R4
   \   000000B0   0700A0E1           MOV      R0,R7
   \   000000B4   D1FFFFEB           BL       sort_list
   \   000000B8   0070A0E1           MOV      R7,R0
    509              result = NULL;
   \   000000BC   020000EA           B        ??sort_list_5
    510          
    511              /* Merge the sub-lists */
    512              while ((first != NULL) && (second != NULL))
    513              {
    514                  cJSON *smaller = NULL;
    515                  if (compare_strings((unsigned char*)first->string, (unsigned char*)second->string, false) < 0)
    516                  {
    517                      smaller = first;
    518                  }
    519                  else
    520                  {
    521                      smaller = second;
    522                  }
    523          
    524                  if (result == NULL)
    525                  {
    526                      /* start merged list with the smaller element */
    527                      result_tail = smaller;
    528                      result = smaller;
    529                  }
    530                  else
    531                  {
    532                      /* add smaller element to the list */
    533                      result_tail->next = smaller;
    534                      smaller->prev = result_tail;
    535                      result_tail = smaller;
    536                  }
    537          
    538                  if (first == smaller)
   \                     ??sort_list_6:
   \   000000C0   000058E1           CMP      R8,R0
   \   000000C4   0800001A           BNE      ??sort_list_7
    539                  {
    540                      first = first->next;
   \   000000C8   008098E5           LDR      R8,[R8, #+0]
    541                  }
   \                     ??sort_list_5:
   \   000000CC   000058E3           CMP      R8,#+0
   \   000000D0   0600001A           BNE      ??sort_list_8
    542                  else
    543                  {
    544                      second = second->next;
    545                  }
    546              }
    547          
    548              if (first != NULL)
    549              {
    550                  /* Append rest of first list. */
    551                  if (result == NULL)
    552                  {
    553                      return first;
    554                  }
    555                  result_tail->next = first;
    556                  first->prev = result_tail;
    557              }
    558              if (second != NULL)
   \   000000D4   000057E3           CMP      R7,#+0
   \   000000D8   1D00000A           BEQ      ??sort_list_9
    559              {
    560                  /* Append rest of second list */
    561                  if (result == NULL)
   \   000000DC   000055E3           CMP      R5,#+0
   \   000000E0   1900001A           BNE      ??sort_list_10
    562                  {
    563                      return second;
   \   000000E4   0700A0E1           MOV      R0,R7
   \   000000E8   F083BDE8           POP      {R4-R9,PC}
    564                  }
   \                     ??sort_list_7:
   \   000000EC   007097E5           LDR      R7,[R7, #+0]
   \                     ??sort_list_8:
   \   000000F0   000057E3           CMP      R7,#+0
   \   000000F4   0D00000A           BEQ      ??sort_list_11
   \   000000F8   200098E5           LDR      R0,[R8, #+32]
   \   000000FC   201097E5           LDR      R1,[R7, #+32]
   \   00000100   0020A0E3           MOV      R2,#+0
   \   00000104   ........           BL       compare_strings
   \   00000108   000050E3           CMP      R0,#+0
   \   0000010C   0800A041           MOVMI    R0,R8
   \   00000110   0700A051           MOVPL    R0,R7
   \   00000114   000055E3           CMP      R5,#+0
   \   00000118   00008615           STRNE    R0,[R6, #+0]
   \   0000011C   04608015           STRNE    R6,[R0, #+4]
   \   00000120   0060A011           MOVNE    R6,R0
   \   00000124   0060A001           MOVEQ    R6,R0
   \   00000128   0050A001           MOVEQ    R5,R0
   \   0000012C   E3FFFFEA           B        ??sort_list_6
   \                     ??sort_list_11:
   \   00000130   000055E3           CMP      R5,#+0
   \   00000134   0100001A           BNE      ??sort_list_12
   \                     ??sort_list_0:
   \   00000138   0800A0E1           MOV      R0,R8
   \   0000013C   F083BDE8           POP      {R4-R9,PC}
   \                     ??sort_list_12:
   \   00000140   008086E5           STR      R8,[R6, #+0]
   \   00000144   046088E5           STR      R6,[R8, #+4]
   \   00000148   010000EA           B        ??sort_list_9
    565                  result_tail->next = second;
   \                     ??sort_list_10:
   \   0000014C   007086E5           STR      R7,[R6, #+0]
    566                  second->prev = result_tail;
   \   00000150   046087E5           STR      R6,[R7, #+4]
    567              }
    568          
    569              return result;
   \                     ??sort_list_9:
   \   00000154   0500A0E1           MOV      R0,R5
   \   00000158   F083BDE8           POP      {R4-R9,PC}       ;; return
    570          }
    571          

   \                                 In segment CODE, align 4, keep-with-next
    572          static void sort_object(cJSON * const object, const cJSON_bool case_sensitive)
    573          {
   \                     sort_object:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    574              if (object == NULL)
   \   00000008   1080BD08           POPEQ    {R4,PC}
    575              {
    576                  return;
    577              }
    578              object->child = sort_list(object->child, case_sensitive);
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   ........           BL       sort_list
   \   00000014   080084E5           STR      R0,[R4, #+8]
    579          }
   \   00000018   1080BDE8           POP      {R4,PC}          ;; return
    580          

   \                                 In segment CODE, align 4, keep-with-next
    581          static cJSON_bool compare_json(cJSON *a, cJSON *b, const cJSON_bool case_sensitive)
    582          {
   \                     compare_json:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0260A0E1           MOV      R6,R2
    583              if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   1A00000A           BEQ      ??compare_json_0
   \   0000001C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000020   0C2094E5           LDR      R2,[R4, #+12]
   \   00000024   FF1000E2           AND      R1,R0,#0xFF
   \   00000028   FF2002E2           AND      R2,R2,#0xFF
   \   0000002C   020051E1           CMP      R1,R2
   \   00000030   1400001A           BNE      ??compare_json_0
    584              {
    585                  /* mismatched type. */
    586                  return false;
    587              }
    588              switch (a->type & 0xFF)
   \   00000034   FF0000E2           AND      R0,R0,#0xFF
   \   00000038   080050E2           SUBS     R0,R0,#+8
   \   0000003C   0600000A           BEQ      ??compare_json_1
   \   00000040   080050E2           SUBS     R0,R0,#+8
   \   00000044   1100000A           BEQ      ??compare_json_2
   \   00000048   100050E2           SUBS     R0,R0,#+16
   \   0000004C   1600000A           BEQ      ??compare_json_3
   \   00000050   200050E2           SUBS     R0,R0,#+32
   \   00000054   2700000A           BEQ      ??compare_json_4
   \   00000058   110000EA           B        ??compare_json_5
    589              {
    590                  case cJSON_Number:
    591                      /* numeric mismatch. */
    592                      if ((a->valueint != b->valueint) || (a->valuedouble != b->valuedouble))
   \                     ??compare_json_1:
   \   0000005C   140095E5           LDR      R0,[R5, #+20]
   \   00000060   141094E5           LDR      R1,[R4, #+20]
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   0600001A           BNE      ??compare_json_0
   \   0000006C   180095E5           LDR      R0,[R5, #+24]
   \   00000070   1C1095E5           LDR      R1,[R5, #+28]
   \   00000074   182094E5           LDR      R2,[R4, #+24]
   \   00000078   1C3094E5           LDR      R3,[R4, #+28]
   \   0000007C   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   0600000A           BEQ      ??compare_json_5
    593                      {
    594                          return false;
   \                     ??compare_json_0:
   \   00000088   0000A0E3           MOV      R0,#+0
   \   0000008C   7080BDE8           POP      {R4-R6,PC}
    595                      }
    596                      else
    597                      {
    598                          return true;
    599                      }
    600          
    601                  case cJSON_String:
    602                      /* string mismatch. */
    603                      if (strcmp(a->valuestring, b->valuestring) != 0)
   \                     ??compare_json_2:
   \   00000090   100095E5           LDR      R0,[R5, #+16]
   \   00000094   101094E5           LDR      R1,[R4, #+16]
   \   00000098   190000EF           SWI      +25
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   F8FFFF1A           BNE      ??compare_json_0
    604                      {
    605                          return false;
    606                      }
    607                      else
    608                      {
    609                          return true;
   \                     ??compare_json_5:
   \   000000A4   0100A0E3           MOV      R0,#+1
   \   000000A8   7080BDE8           POP      {R4-R6,PC}
    610                      }
    611          
    612                  case cJSON_Array:
    613                      for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)
   \                     ??compare_json_3:
   \   000000AC   085095E5           LDR      R5,[R5, #+8]
   \   000000B0   084094E5           LDR      R4,[R4, #+8]
   \   000000B4   010000EA           B        ??compare_json_6
   \                     ??compare_json_7:
   \   000000B8   005095E5           LDR      R5,[R5, #+0]
   \   000000BC   004094E5           LDR      R4,[R4, #+0]
   \                     ??compare_json_6:
   \   000000C0   000055E3           CMP      R5,#+0
   \   000000C4   0800000A           BEQ      ??compare_json_8
   \   000000C8   000054E3           CMP      R4,#+0
   \   000000CC   EDFFFF0A           BEQ      ??compare_json_0
    614                      {
    615                          cJSON_bool identical = compare_json(a, b, case_sensitive);
    616                          if (!identical)
   \   000000D0   0620A0E1           MOV      R2,R6
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0500A0E1           MOV      R0,R5
   \   000000DC   C7FFFFEB           BL       compare_json
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   F3FFFF1A           BNE      ??compare_json_7
    617                          {
    618                              return false;
   \   000000E8   7080BDE8           POP      {R4-R6,PC}
    619                          }
    620                      }
    621          
    622                      /* array size mismatch? (one of both children is not NULL) */
    623                      if ((a != NULL) || (b != NULL))
   \                     ??compare_json_8:
   \   000000EC   000054E3           CMP      R4,#+0
   \   000000F0   EBFFFF0A           BEQ      ??compare_json_5
    624                      {
    625                          return false;
   \   000000F4   E3FFFFEA           B        ??compare_json_0
    626                      }
    627                      else
    628                      {
    629                          return true;
    630                      }
    631          
    632                  case cJSON_Object:
    633                      sort_object(a, case_sensitive);
   \                     ??compare_json_4:
   \   000000F8   0610A0E1           MOV      R1,R6
   \   000000FC   0500A0E1           MOV      R0,R5
   \   00000100   ........           BL       sort_object
    634                      sort_object(b, case_sensitive);
   \   00000104   0610A0E1           MOV      R1,R6
   \   00000108   0400A0E1           MOV      R0,R4
   \   0000010C   ........           BL       sort_object
    635                      for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)
   \   00000110   085095E5           LDR      R5,[R5, #+8]
   \   00000114   084094E5           LDR      R4,[R4, #+8]
   \   00000118   010000EA           B        ??compare_json_9
   \                     ??compare_json_10:
   \   0000011C   005095E5           LDR      R5,[R5, #+0]
   \   00000120   004094E5           LDR      R4,[R4, #+0]
   \                     ??compare_json_9:
   \   00000124   000055E3           CMP      R5,#+0
   \   00000128   EFFFFF0A           BEQ      ??compare_json_8
   \   0000012C   000054E3           CMP      R4,#+0
   \   00000130   D4FFFF0A           BEQ      ??compare_json_0
    636                      {
    637                          cJSON_bool identical = false;
    638                          /* compare object keys */
    639                          if (compare_strings((unsigned char*)a->string, (unsigned char*)b->string, case_sensitive))
   \   00000134   200095E5           LDR      R0,[R5, #+32]
   \   00000138   201094E5           LDR      R1,[R4, #+32]
   \   0000013C   0620A0E1           MOV      R2,R6
   \   00000140   ........           BL       compare_strings
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   CEFFFF1A           BNE      ??compare_json_0
    640                          {
    641                              /* missing member */
    642                              return false;
    643                          }
    644                          identical = compare_json(a, b, case_sensitive);
    645                          if (!identical)
   \   0000014C   0620A0E1           MOV      R2,R6
   \   00000150   0410A0E1           MOV      R1,R4
   \   00000154   0500A0E1           MOV      R0,R5
   \   00000158   A8FFFFEB           BL       compare_json
   \   0000015C   000050E3           CMP      R0,#+0
   \   00000160   EDFFFF1A           BNE      ??compare_json_10
    646                          {
    647                              return false;
   \   00000164   7080BDE8           POP      {R4-R6,PC}
    648                          }
    649                      }
    650          
    651                      /* object length mismatch (one of both children is not null) */
    652                      if ((a != NULL) || (b != NULL))
    653                      {
    654                          return false;
    655                      }
    656                      else
    657                      {
    658                          return true;
    659                      }
    660          
    661                  default:
    662                      break;
    663              }
    664          
    665              /* null, true or false */
    666              return true;
    667          }
    668          
    669          /* non broken version of cJSON_InsertItemInArray */
    670          static cJSON_bool insert_item_in_array(cJSON *array, size_t which, cJSON *newitem)
    671          {
    672              cJSON *child = array->child;
    673              while (child && (which > 0))
    674              {
    675                  child = child->next;
    676                  which--;
    677              }
    678              if (which > 0)
    679              {
    680                  /* item is after the end of the array */
    681                  return 0;
    682              }
    683              if (child == NULL)
    684              {
    685                  cJSON_AddItemToArray(array, newitem);
    686                  return 1;
    687              }
    688          
    689              /* insert into the linked list */
    690              newitem->next = child;
    691              newitem->prev = child->prev;
    692              child->prev = newitem;
    693          
    694              /* was it at the beginning */
    695              if (child == array->child)
    696              {
    697                  array->child = newitem;
    698              }
    699              else
    700              {
    701                  newitem->prev->next = newitem;
    702              }
    703          
    704              return 1;
    705          }
    706          

   \                                 In segment CODE, align 4, keep-with-next
    707          static cJSON *get_object_item(const cJSON * const object, const char* name, const cJSON_bool case_sensitive)
    708          {
    709              if (case_sensitive)
   \                     get_object_item:
   \   00000000   000052E3           CMP      R2,#+0
   \   00000004   0000000A           BEQ      ??get_object_item_0
    710              {
    711                  return cJSON_GetObjectItemCaseSensitive(object, name);
   \   00000008   ........           _BF      cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA  ;; tailcall
    712              }
    713          
    714              return cJSON_GetObjectItem(object, name);
   \                     ??get_object_item_0:
   \   0000000C   ........           _BF      cJSON_GetObjectItem,??cJSON_GetObjectItem??rA  ;; tailcall
    715          }
    716          
    717          enum patch_operation { INVALID, ADD, REMOVE, REPLACE, MOVE, COPY, TEST };
    718          
    719          static enum patch_operation decode_patch_operation(const cJSON * const patch, const cJSON_bool case_sensitive)
    720          {
    721              cJSON *operation = get_object_item(patch, "op", case_sensitive);
    722              if (!cJSON_IsString(operation))
    723              {
    724                  return INVALID;
    725              }
    726          
    727              if (strcmp(operation->valuestring, "add") == 0)
    728              {
    729                  return ADD;
    730              }
    731          
    732              if (strcmp(operation->valuestring, "remove") == 0)
    733              {
    734                  return REMOVE;
    735              }
    736          
    737              if (strcmp(operation->valuestring, "replace") == 0)
    738              {
    739                  return REPLACE;
    740              }
    741          
    742              if (strcmp(operation->valuestring, "move") == 0)
    743              {
    744                  return MOVE;
    745              }
    746          
    747              if (strcmp(operation->valuestring, "copy") == 0)
    748              {
    749                  return COPY;
    750              }
    751          
    752              if (strcmp(operation->valuestring, "test") == 0)
    753              {
    754                  return TEST;
    755              }
    756          
    757              return INVALID;
    758          }
    759          
    760          /* overwrite and existing item with another one and free resources on the way */

   \                                 In segment CODE, align 4, keep-with-next
    761          static void overwrite_item(cJSON * const root, const cJSON replacement)
    762          {
   \                     overwrite_item:
   \   00000000   0E002DE9           PUSH     {R1-R3}
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   0040B0E1           MOVS     R4,R0
    763              if (root == NULL)
   \   0000000C   0F00000A           BEQ      ??overwrite_item_0
    764              {
    765                  return;
    766              }
    767          
    768              if (root->string != NULL)
   \   00000010   200094E5           LDR      R0,[R4, #+32]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0000000A           BEQ      ??overwrite_item_1
    769              {
    770                  cJSON_free(root->string);
   \   0000001C   ........           _BLF     cJSON_free,??cJSON_free??rA
    771              }
    772              if (root->valuestring != NULL)
   \                     ??overwrite_item_1:
   \   00000020   100094E5           LDR      R0,[R4, #+16]
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   0000000A           BEQ      ??overwrite_item_2
    773              {
    774                  cJSON_free(root->valuestring);
   \   0000002C   ........           _BLF     cJSON_free,??cJSON_free??rA
    775              }
    776              if (root->child != NULL)
   \                     ??overwrite_item_2:
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0000000A           BEQ      ??overwrite_item_3
    777              {
    778                  cJSON_Delete(root->child);
   \   0000003C   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
    779              }
    780          
    781              memcpy(root, &replacement, sizeof(cJSON));
   \                     ??overwrite_item_3:
   \   00000040   2420A0E3           MOV      R2,#+36
   \   00000044   08108DE2           ADD      R1,SP,#+8
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   1E0100EF           SWI      +286
    782          }
   \                     ??overwrite_item_0:
   \   00000050   1040BDE8           POP      {R4,LR}
   \   00000054   0CD08DE2           ADD      SP,SP,#+12
   \   00000058   1EFF2FE1           BX       LR               ;; return
    783          

   \                                 In segment CODE, align 4, keep-with-next
    784          static int apply_patch(cJSON *object, const cJSON *patch, const cJSON_bool case_sensitive)
    785          {
   \                     apply_patch:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
    786              cJSON *path = NULL;
    787              cJSON *value = NULL;
    788              cJSON *parent = NULL;
    789              enum patch_operation opcode = INVALID;
    790              unsigned char *parent_pointer = NULL;
    791              unsigned char *child_pointer = NULL;
    792              int status = 0;
    793          
    794              path = get_object_item(patch, "path", case_sensitive);
   \   00000004   ........           LDR      R10,??DataTable10  ;; ??invalid
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0080A0E3           MOV      R8,#+0
   \   00000018   0090A0E3           MOV      R9,#+0
   \   0000001C   0840A0E1           MOV      R4,R8
   \   00000020   4C108AE2           ADD      R1,R10,#+76
   \   00000024   0600A0E1           MOV      R0,R6
   \   00000028   ........           BL       get_object_item
   \   0000002C   00008DE5           STR      R0,[SP, #+0]
    795              if (!cJSON_IsString(path))
   \   00000030   ........           _BLF     cJSON_IsString,??cJSON_IsString??rA
   \   00000034   000050E3           CMP      R0,#+0
    796              {
    797                  /* malformed patch. */
    798                  status = 2;
   \   00000038   0240A003           MOVEQ    R4,#+2
    799                  goto cleanup;
   \   0000003C   6200000A           BEQ      ??apply_patch_0
    800              }
    801          
    802              opcode = decode_patch_operation(patch, case_sensitive);
   \   00000040   0720A0E1           MOV      R2,R7
   \   00000044   E51F8FE2           ADR      R1,??apply_patch_1  ;; "op"
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   ........           BL       get_object_item
   \   00000050   00B0A0E1           MOV      R11,R0
   \   00000054   ........           _BLF     cJSON_IsString,??cJSON_IsString??rA
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   4600000A           BEQ      ??apply_patch_2
   \   00000060   10009BE5           LDR      R0,[R11, #+16]
   \   00000064   DE1F8FE2           ADR      R1,??apply_patch_1+0x4  ;; "add"
   \   00000068   190000EF           SWI      +25
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   1300001A           BNE      ??apply_patch_3
   \   00000074   01B0A0E3           MOV      R11,#+1
    803              if (opcode == INVALID)
    804              {
    805                  status = 3;
    806                  goto cleanup;
    807              }
    808              else if (opcode == TEST)
    809              {
    810                  /* compare value: {...} with the given path */
    811                  status = !compare_json(get_item_from_pointer(object, path->valuestring, case_sensitive), get_object_item(patch, "value", case_sensitive), case_sensitive);
    812                  goto cleanup;
    813              }
    814          
    815              /* special case for replacing the root */
    816              if (path->valuestring[0] == '\0')
   \                     ??apply_patch_4:
   \   00000078   00009DE5           LDR      R0,[SP, #+0]
   \   0000007C   101090E5           LDR      R1,[R0, #+16]
   \   00000080   0000D1E5           LDRB     R0,[R1, #+0]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   6B00001A           BNE      ??apply_patch_5
    817              {
    818                  if (opcode == REMOVE)
   \   0000008C   02005BE3           CMP      R11,#+2
   \   00000090   3B00001A           BNE      ??apply_patch_6
    819                  {
    820                      static const cJSON invalid = { NULL, NULL, NULL, cJSON_Invalid, NULL, 0, 0, NULL};
    821          
    822                      overwrite_item(object, invalid);
   \   00000094   24D04DE2           SUB      SP,SP,#+36
   \   00000098   0D10A0E1           MOV      R1,SP
   \   0000009C   2420A0E3           MOV      R2,#+36
   \                     ??apply_patch_7:
   \   000000A0   042052E2           SUBS     R2,R2,#+4
   \   000000A4   02009AE7           LDR      R0,[R10, R2]
   \   000000A8   020081E7           STR      R0,[R1, R2]
   \   000000AC   FBFFFF1A           BNE      ??apply_patch_7
   \   000000B0   0E00BDE8           POP      {R1-R3}
   \   000000B4   0500A0E1           MOV      R0,R5
   \   000000B8   ........           BL       overwrite_item
    823          
    824                      status = 0;
    825                      goto cleanup;
   \   000000BC   18D08DE2           ADD      SP,SP,#+24
   \   000000C0   410000EA           B        ??apply_patch_0
    826                  }
   \                     ??apply_patch_3:
   \   000000C4   10009BE5           LDR      R0,[R11, #+16]
   \   000000C8   24108AE2           ADD      R1,R10,#+36
   \   000000CC   190000EF           SWI      +25
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   02B0A003           MOVEQ    R11,#+2
   \   000000D8   E6FFFF0A           BEQ      ??apply_patch_4
   \   000000DC   10009BE5           LDR      R0,[R11, #+16]
   \   000000E0   2C108AE2           ADD      R1,R10,#+44
   \   000000E4   190000EF           SWI      +25
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   03B0A003           MOVEQ    R11,#+3
   \   000000F0   E0FFFF0A           BEQ      ??apply_patch_4
   \   000000F4   10009BE5           LDR      R0,[R11, #+16]
   \   000000F8   34108AE2           ADD      R1,R10,#+52
   \   000000FC   190000EF           SWI      +25
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   04B0A003           MOVEQ    R11,#+4
   \   00000108   DAFFFF0A           BEQ      ??apply_patch_4
   \   0000010C   10009BE5           LDR      R0,[R11, #+16]
   \   00000110   3C108AE2           ADD      R1,R10,#+60
   \   00000114   190000EF           SWI      +25
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   05B0A003           MOVEQ    R11,#+5
   \   00000120   D4FFFF0A           BEQ      ??apply_patch_4
   \   00000124   10009BE5           LDR      R0,[R11, #+16]
   \   00000128   44108AE2           ADD      R1,R10,#+68
   \   0000012C   190000EF           SWI      +25
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   1000001A           BNE      ??apply_patch_2
   \   00000138   0720A0E1           MOV      R2,R7
   \   0000013C   54108AE2           ADD      R1,R10,#+84
   \   00000140   0600A0E1           MOV      R0,R6
   \   00000144   ........           BL       get_object_item
   \   00000148   0060A0E1           MOV      R6,R0
   \   0000014C   00009DE5           LDR      R0,[SP, #+0]
   \   00000150   0720A0E1           MOV      R2,R7
   \   00000154   101090E5           LDR      R1,[R0, #+16]
   \   00000158   0500A0E1           MOV      R0,R5
   \   0000015C   ........           BL       get_item_from_pointer
   \   00000160   0720A0E1           MOV      R2,R7
   \   00000164   0610A0E1           MOV      R1,R6
   \   00000168   ........           BL       compare_json
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   1500001A           BNE      ??apply_patch_0
   \   00000174   0140A0E3           MOV      R4,#+1
   \   00000178   130000EA           B        ??apply_patch_0
   \                     ??apply_patch_2:
   \   0000017C   0340A0E3           MOV      R4,#+3
   \   00000180   110000EA           B        ??apply_patch_0
    827          
    828                  if ((opcode == REPLACE) || (opcode == ADD))
   \                     ??apply_patch_6:
   \   00000184   03005BE3           CMP      R11,#+3
   \   00000188   01005B13           CMPNE    R11,#+1
   \   0000018C   2A00001A           BNE      ??apply_patch_5
    829                  {
    830                      value = get_object_item(patch, "value", case_sensitive);
   \   00000190   0720A0E1           MOV      R2,R7
   \   00000194   54108AE2           ADD      R1,R10,#+84
   \   00000198   0600A0E1           MOV      R0,R6
   \   0000019C   ........           BL       get_object_item
   \   000001A0   0080B0E1           MOVS     R8,R0
    831                      if (value == NULL)
   \   000001A4   0A00001A           BNE      ??apply_patch_8
    832                      {
    833                          /* missing "value" for add/replace. */
    834                          status = 7;
   \                     ??apply_patch_9:
   \   000001A8   0740A0E3           MOV      R4,#+7
    835                          goto cleanup;
    836                      }
    837          
    838                      value = cJSON_Duplicate(value, 1);
    839                      if (value == NULL)
    840                      {
    841                          /* out of memory for add/replace. */
    842                          status = 8;
    843                          goto cleanup;
    844                      }
    845          
    846                      overwrite_item(object, *value);
    847          
    848                      /* delete the duplicated value */
    849                      cJSON_free(value);
    850                      value = NULL;
    851          
    852                      /* the string "value" isn't needed */
    853                      if (object->string != NULL)
    854                      {
    855                          cJSON_free(object->string);
    856                          object->string = NULL;
    857                      }
    858          
    859                      status = 0;
    860                      goto cleanup;
    861                  }
    862              }
    863          
    864              if ((opcode == REMOVE) || (opcode == REPLACE))
    865              {
    866                  /* Get rid of old. */
    867                  cJSON *old_item = detach_path(object, (unsigned char*)path->valuestring, case_sensitive);
    868                  if (old_item == NULL)
    869                  {
    870                      status = 13;
    871                      goto cleanup;
    872                  }
    873                  cJSON_Delete(old_item);
    874                  if (opcode == REMOVE)
    875                  {
    876                      /* For Remove, this job is done. */
    877                      status = 0;
    878                      goto cleanup;
    879                  }
    880              }
    881          
    882              /* Copy/Move uses "from". */
    883              if ((opcode == MOVE) || (opcode == COPY))
    884              {
    885                  cJSON *from = get_object_item(patch, "from", case_sensitive);
    886                  if (from == NULL)
    887                  {
    888                      /* missing "from" for copy/move. */
    889                      status = 4;
    890                      goto cleanup;
    891                  }
    892          
    893                  if (opcode == MOVE)
    894                  {
    895                      value = detach_path(object, (unsigned char*)from->valuestring, case_sensitive);
    896                  }
    897                  if (opcode == COPY)
    898                  {
    899                      value = get_item_from_pointer(object, from->valuestring, case_sensitive);
    900                  }
    901                  if (value == NULL)
    902                  {
    903                      /* missing "from" for copy/move. */
    904                      status = 5;
    905                      goto cleanup;
    906                  }
    907                  if (opcode == COPY)
    908                  {
    909                      value = cJSON_Duplicate(value, 1);
    910                  }
    911                  if (value == NULL)
    912                  {
    913                      /* out of memory for copy/move. */
    914                      status = 6;
    915                      goto cleanup;
    916                  }
    917              }
    918              else /* Add/Replace uses "value". */
    919              {
    920                  value = get_object_item(patch, "value", case_sensitive);
    921                  if (value == NULL)
    922                  {
    923                      /* missing "value" for add/replace. */
    924                      status = 7;
    925                      goto cleanup;
    926                  }
    927                  value = cJSON_Duplicate(value, 1);
    928                  if (value == NULL)
    929                  {
    930                      /* out of memory for add/replace. */
    931                      status = 8;
    932                      goto cleanup;
    933                  }
    934              }
    935          
    936              /* Now, just add "value" to "path". */
    937          
    938              /* split pointer in parent and child */
    939              parent_pointer = cJSONUtils_strdup((unsigned char*)path->valuestring);
    940              child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/');
    941              if (child_pointer != NULL)
    942              {
    943                  child_pointer[0] = '\0';
    944                  child_pointer++;
    945              }
    946              parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);
    947              decode_pointer_inplace(child_pointer);
    948          
    949              /* add, remove, replace, move, copy, test. */
    950              if ((parent == NULL) || (child_pointer == NULL))
    951              {
    952                  /* Couldn't find object to add to. */
    953                  status = 9;
    954                  goto cleanup;
    955              }
    956              else if (cJSON_IsArray(parent))
    957              {
    958                  if (strcmp((char*)child_pointer, "-") == 0)
    959                  {
    960                      cJSON_AddItemToArray(parent, value);
    961                      value = NULL;
    962                  }
    963                  else
    964                  {
    965                      size_t index = 0;
    966                      if (!decode_array_index_from_pointer(child_pointer, &index))
    967                      {
    968                          status = 11;
    969                          goto cleanup;
    970                      }
    971          
    972                      if (!insert_item_in_array(parent, index, value))
    973                      {
    974                          status = 10;
    975                          goto cleanup;
    976                      }
    977                      value = NULL;
    978                  }
    979              }
    980              else if (cJSON_IsObject(parent))
    981              {
    982                  if (case_sensitive)
    983                  {
    984                      cJSON_DeleteItemFromObjectCaseSensitive(parent, (char*)child_pointer);
    985                  }
    986                  else
    987                  {
    988                      cJSON_DeleteItemFromObject(parent, (char*)child_pointer);
    989                  }
    990                  cJSON_AddItemToObject(parent, (char*)child_pointer, value);
    991                  value = NULL;
    992              }
    993              else /* parent is not an object */
    994              {
    995                  /* Couldn't find object to add to. */
    996                  status = 9;
    997                  goto cleanup;
    998              }
    999          
   1000          cleanup:
   1001              if (value != NULL)
   \                     ??apply_patch_10:
   \   000001AC   000058E3           CMP      R8,#+0
   \   000001B0   0100000A           BEQ      ??apply_patch_11
   1002              {
   1003                  cJSON_Delete(value);
   \   000001B4   0800A0E1           MOV      R0,R8
   \   000001B8   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1004              }
   1005              if (parent_pointer != NULL)
   \                     ??apply_patch_11:
   \   000001BC   000059E3           CMP      R9,#+0
   \   000001C0   0100000A           BEQ      ??apply_patch_0
   1006              {
   1007                  cJSON_free(parent_pointer);
   \   000001C4   0900A0E1           MOV      R0,R9
   \   000001C8   ........           _BLF     cJSON_free,??cJSON_free??rA
   1008              }
   1009          
   1010              return status;
   \                     ??apply_patch_0:
   \   000001CC   0400A0E1           MOV      R0,R4
   \   000001D0   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??apply_patch_8:
   \   000001D4   0110A0E3           MOV      R1,#+1
   \   000001D8   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000001DC   0080B0E1           MOVS     R8,R0
   \   000001E0   0100001A           BNE      ??apply_patch_12
   \                     ??apply_patch_13:
   \   000001E4   0840A0E3           MOV      R4,#+8
   \   000001E8   EFFFFFEA           B        ??apply_patch_10
   \                     ??apply_patch_12:
   \   000001EC   24D04DE2           SUB      SP,SP,#+36
   \   000001F0   0D10A0E1           MOV      R1,SP
   \   000001F4   2420A0E3           MOV      R2,#+36
   \                     ??apply_patch_14:
   \   000001F8   042052E2           SUBS     R2,R2,#+4
   \   000001FC   020098E7           LDR      R0,[R8, R2]
   \   00000200   020081E7           STR      R0,[R1, R2]
   \   00000204   FBFFFF1A           BNE      ??apply_patch_14
   \   00000208   0E00BDE8           POP      {R1-R3}
   \   0000020C   0500A0E1           MOV      R0,R5
   \   00000210   ........           BL       overwrite_item
   \   00000214   0800A0E1           MOV      R0,R8
   \   00000218   ........           _BLF     cJSON_free,??cJSON_free??rA
   \   0000021C   200095E5           LDR      R0,[R5, #+32]
   \   00000220   18D08DE2           ADD      SP,SP,#+24
   \   00000224   000050E3           CMP      R0,#+0
   \   00000228   E7FFFF0A           BEQ      ??apply_patch_0
   \   0000022C   ........           _BLF     cJSON_free,??cJSON_free??rA
   \   00000230   0000A0E3           MOV      R0,#+0
   \   00000234   200085E5           STR      R0,[R5, #+32]
   \   00000238   E3FFFFEA           B        ??apply_patch_0
   \                     ??apply_patch_5:
   \   0000023C   0B00A0E1           MOV      R0,R11
   \   00000240   020050E3           CMP      R0,#+2
   \   00000244   03005013           CMPNE    R0,#+3
   \   00000248   0900001A           BNE      ??apply_patch_15
   \   0000024C   0720A0E1           MOV      R2,R7
   \   00000250   0500A0E1           MOV      R0,R5
   \   00000254   ........           BL       detach_path
   \   00000258   000050E3           CMP      R0,#+0
   \   0000025C   0D40A003           MOVEQ    R4,#+13
   \   00000260   D9FFFF0A           BEQ      ??apply_patch_0
   \   00000264   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   \   00000268   0B00A0E1           MOV      R0,R11
   \   0000026C   020050E3           CMP      R0,#+2
   \   00000270   D5FFFF0A           BEQ      ??apply_patch_0
   \                     ??apply_patch_15:
   \   00000274   040050E3           CMP      R0,#+4
   \   00000278   05005013           CMPNE    R0,#+5
   \   0000027C   2000001A           BNE      ??apply_patch_16
   \   00000280   0720A0E1           MOV      R2,R7
   \   00000284   5C108AE2           ADD      R1,R10,#+92
   \   00000288   0600A0E1           MOV      R0,R6
   \   0000028C   ........           BL       get_object_item
   \   00000290   0060B0E1           MOVS     R6,R0
   \   00000294   0440A003           MOVEQ    R4,#+4
   \   00000298   CBFFFF0A           BEQ      ??apply_patch_0
   \   0000029C   04005BE3           CMP      R11,#+4
   \   000002A0   0400001A           BNE      ??apply_patch_17
   \   000002A4   101096E5           LDR      R1,[R6, #+16]
   \   000002A8   0720A0E1           MOV      R2,R7
   \   000002AC   0500A0E1           MOV      R0,R5
   \   000002B0   ........           BL       detach_path
   \   000002B4   0080A0E1           MOV      R8,R0
   \                     ??apply_patch_17:
   \   000002B8   05005BE3           CMP      R11,#+5
   \   000002BC   0400001A           BNE      ??apply_patch_18
   \   000002C0   101096E5           LDR      R1,[R6, #+16]
   \   000002C4   0720A0E1           MOV      R2,R7
   \   000002C8   0500A0E1           MOV      R0,R5
   \   000002CC   ........           BL       get_item_from_pointer
   \   000002D0   0080A0E1           MOV      R8,R0
   \                     ??apply_patch_18:
   \   000002D4   000058E3           CMP      R8,#+0
   \   000002D8   0540A003           MOVEQ    R4,#+5
   \   000002DC   BAFFFF0A           BEQ      ??apply_patch_0
   \   000002E0   05005BE3           CMP      R11,#+5
   \   000002E4   1000001A           BNE      ??apply_patch_19
   \   000002E8   0110A0E3           MOV      R1,#+1
   \   000002EC   0800A0E1           MOV      R0,R8
   \   000002F0   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000002F4   0080B0E1           MOVS     R8,R0
   \   000002F8   0B00001A           BNE      ??apply_patch_19
   \   000002FC   0640A0E3           MOV      R4,#+6
   \   00000300   B1FFFFEA           B        ??apply_patch_0
   \                     ??apply_patch_16:
   \   00000304   0720A0E1           MOV      R2,R7
   \   00000308   54108AE2           ADD      R1,R10,#+84
   \   0000030C   0600A0E1           MOV      R0,R6
   \   00000310   ........           BL       get_object_item
   \   00000314   0080B0E1           MOVS     R8,R0
   \   00000318   A2FFFF0A           BEQ      ??apply_patch_9
   \   0000031C   0110A0E3           MOV      R1,#+1
   \   00000320   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000324   0080B0E1           MOVS     R8,R0
   \   00000328   ADFFFF0A           BEQ      ??apply_patch_13
   \                     ??apply_patch_19:
   \   0000032C   00009DE5           LDR      R0,[SP, #+0]
   \   00000330   100090E5           LDR      R0,[R0, #+16]
   \   00000334   ........           BL       cJSONUtils_strdup
   \   00000338   0090A0E1           MOV      R9,R0
   \   0000033C   2F10A0E3           MOV      R1,#+47
   \   00000340   170100EF           SWI      +279
   \   00000344   0060B0E1           MOVS     R6,R0
   \   00000348   0000A013           MOVNE    R0,#+0
   \   0000034C   ........           STRBNE   R0,[R6], #+1
   \   00000350   0720A0E1           MOV      R2,R7
   \   00000354   0910A0E1           MOV      R1,R9
   \   00000358   0500A0E1           MOV      R0,R5
   \   0000035C   ........           BL       get_item_from_pointer
   \   00000360   0050A0E1           MOV      R5,R0
   \   00000364   0600A0E1           MOV      R0,R6
   \   00000368   ........           BL       decode_pointer_inplace
   \   0000036C   000055E3           CMP      R5,#+0
   \   00000370   00005613           CMPNE    R6,#+0
   \   00000374   0100001A           BNE      ??apply_patch_20
   \                     ??apply_patch_21:
   \   00000378   0940A0E3           MOV      R4,#+9
   \   0000037C   8AFFFFEA           B        ??apply_patch_10
   \                     ??apply_patch_20:
   \   00000380   0500A0E1           MOV      R0,R5
   \   00000384   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000388   000050E3           CMP      R0,#+0
   \   0000038C   2900000A           BEQ      ??apply_patch_22
   \   00000390   ........           ADR      R1,??DataTable1  ;; "-"
   \   00000394   0600A0E1           MOV      R0,R6
   \   00000398   190000EF           SWI      +25
   \   0000039C   000050E3           CMP      R0,#+0
   \   000003A0   0300001A           BNE      ??apply_patch_23
   \                     ??apply_patch_24:
   \   000003A4   0810A0E1           MOV      R1,R8
   \   000003A8   0500A0E1           MOV      R0,R5
   \   000003AC   ........           _BLF     cJSON_AddItemToArray,??cJSON_AddItemToArray??rA
   \   000003B0   81FFFFEA           B        ??apply_patch_11
   \                     ??apply_patch_23:
   \   000003B4   0010A0E3           MOV      R1,#+0
   \   000003B8   00108DE5           STR      R1,[SP, #+0]
   \   000003BC   0D10A0E1           MOV      R1,SP
   \   000003C0   0600A0E1           MOV      R0,R6
   \   000003C4   ........           BL       decode_array_index_from_pointer
   \   000003C8   000050E3           CMP      R0,#+0
   \   000003CC   0B40A003           MOVEQ    R4,#+11
   \   000003D0   75FFFF0A           BEQ      ??apply_patch_10
   \   000003D4   00009DE5           LDR      R0,[SP, #+0]
   \   000003D8   081095E5           LDR      R1,[R5, #+8]
   \   000003DC   030000EA           B        ??apply_patch_25
   \                     ??apply_patch_1:
   \   000003E0   6F700000           DC8      "op",+0
   \   000003E4   61646400           DC8      "add"
   \                     ??apply_patch_26:
   \   000003E8   001091E5           LDR      R1,[R1, #+0]
   \   000003EC   010040E2           SUB      R0,R0,#+1
   \                     ??apply_patch_25:
   \   000003F0   000051E3           CMP      R1,#+0
   \   000003F4   00005013           CMPNE    R0,#+0
   \   000003F8   FAFFFF1A           BNE      ??apply_patch_26
   \   000003FC   000050E3           CMP      R0,#+0
   \   00000400   0A40A013           MOVNE    R4,#+10
   \   00000404   68FFFF1A           BNE      ??apply_patch_10
   \   00000408   000051E3           CMP      R1,#+0
   \   0000040C   E4FFFF0A           BEQ      ??apply_patch_24
   \   00000410   001088E5           STR      R1,[R8, #+0]
   \   00000414   040091E5           LDR      R0,[R1, #+4]
   \   00000418   040088E5           STR      R0,[R8, #+4]
   \   0000041C   048081E5           STR      R8,[R1, #+4]
   \   00000420   080095E5           LDR      R0,[R5, #+8]
   \   00000424   000051E1           CMP      R1,R0
   \   00000428   04009815           LDRNE    R0,[R8, #+4]
   \   0000042C   08808505           STREQ    R8,[R5, #+8]
   \   00000430   00808015           STRNE    R8,[R0, #+0]
   \   00000434   60FFFFEA           B        ??apply_patch_11
   \                     ??apply_patch_22:
   \   00000438   0500A0E1           MOV      R0,R5
   \   0000043C   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000440   000050E3           CMP      R0,#+0
   \   00000444   CBFFFF0A           BEQ      ??apply_patch_21
   \   00000448   000057E3           CMP      R7,#+0
   \   0000044C   0610A0E1           MOV      R1,R6
   \   00000450   0500A0E1           MOV      R0,R5
   \   00000454   0100000A           BEQ      ??apply_patch_27
   \   00000458   ........           _BLF     cJSON_DeleteItemFromObjectCaseSensitive,??cJSON_DeleteItemFromObjectCaseSensitive??rA
   \   0000045C   000000EA           B        ??apply_patch_28
   \                     ??apply_patch_27:
   \   00000460   ........           _BLF     cJSON_DeleteItemFromObject,??cJSON_DeleteItemFromObject??rA
   \                     ??apply_patch_28:
   \   00000464   0820A0E1           MOV      R2,R8
   \   00000468   0610A0E1           MOV      R1,R6
   \   0000046C   0500A0E1           MOV      R0,R5
   \   00000470   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   00000474   50FFFFEA           B        ??apply_patch_11
   1011          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??invalid:
   \   00000000   000000000000       DC32 0H, 0H, 0H, 0, 0H, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \   00000024   72656D6F7665       DC8 "remove"
   \              00          
   \   0000002B   00                 DC8 0
   \   0000002C   7265706C6163       DC8 "replace"
   \              6500        
   \   00000034   6D6F766500         DC8 "move"
   \   00000039   000000             DC8 0, 0, 0
   \   0000003C   636F707900         DC8 "copy"
   \   00000041   000000             DC8 0, 0, 0
   \   00000044   7465737400         DC8 "test"
   \   00000049   000000             DC8 0, 0, 0
   \   0000004C   7061746800         DC8 "path"
   \   00000051   000000             DC8 0, 0, 0
   \   00000054   76616C756500       DC8 "value"
   \   0000005A   0000               DC8 0, 0
   \   0000005C   66726F6D00         DC8 "from"
   \   00000061   000000             DC8 0, 0, 0
   \   00000064   25732F256C75       DC8 "%s/%lu"
   \              00          
   \   0000006B   00                 DC8 0
   1012          

   \                                 In segment CODE, align 4, keep-with-next
   1013          CJSON_PUBLIC(int) cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches)
   1014          {
   \                     cJSONUtils_ApplyPatches:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1015              const cJSON *current_patch = NULL;
   1016              int status = 0;
   1017          
   1018              if (!cJSON_IsArray(patches))
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000014   000050E3           CMP      R0,#+0
   1019              {
   1020                  /* malformed patches. */
   1021                  return 1;
   \   00000018   0100A003           MOVEQ    R0,#+1
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
   1022              }
   1023          
   1024              if (patches != NULL)
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0B00000A           BEQ      ??cJSONUtils_ApplyPatches_0
   1025              {
   1026                  current_patch = patches->child;
   \   00000028   085095E5           LDR      R5,[R5, #+8]
   \   0000002C   000000EA           B        ??cJSONUtils_ApplyPatches_1
   1027              }
   1028          
   1029              while (current_patch != NULL)
   1030              {
   1031                  status = apply_patch(object, current_patch, false);
   1032                  if (status != 0)
   1033                  {
   1034                      return status;
   1035                  }
   1036                  current_patch = current_patch->next;
   \                     ??cJSONUtils_ApplyPatches_2:
   \   00000030   005095E5           LDR      R5,[R5, #+0]
   \                     ??cJSONUtils_ApplyPatches_1:
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0600000A           BEQ      ??cJSONUtils_ApplyPatches_0
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       apply_patch
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F6FFFF0A           BEQ      ??cJSONUtils_ApplyPatches_2
   \   00000054   3080BDE8           POP      {R4,R5,PC}
   1037              }
   1038          
   1039              return 0;
   \                     ??cJSONUtils_ApplyPatches_0:
   \   00000058   ........           B        ?Subroutine35
   1040          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine35:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   3080BDE8           POP      {R4,R5,PC}       ;; return
   1041          

   \                                 In segment CODE, align 4, keep-with-next
   1042          CJSON_PUBLIC(int) cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches)
   1043          {
   \                     cJSONUtils_ApplyPatchesCaseSensitive:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1044              const cJSON *current_patch = NULL;
   1045              int status = 0;
   1046          
   1047              if (!cJSON_IsArray(patches))
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000014   000050E3           CMP      R0,#+0
   1048              {
   1049                  /* malformed patches. */
   1050                  return 1;
   \   00000018   0100A003           MOVEQ    R0,#+1
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
   1051              }
   1052          
   1053              if (patches != NULL)
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0B00000A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_0
   1054              {
   1055                  current_patch = patches->child;
   \   00000028   085095E5           LDR      R5,[R5, #+8]
   \   0000002C   000000EA           B        ??cJSONUtils_ApplyPatchesCaseSensitive_1
   1056              }
   1057          
   1058              while (current_patch != NULL)
   1059              {
   1060                  status = apply_patch(object, current_patch, true);
   1061                  if (status != 0)
   1062                  {
   1063                      return status;
   1064                  }
   1065                  current_patch = current_patch->next;
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_2:
   \   00000030   005095E5           LDR      R5,[R5, #+0]
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_1:
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0600000A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_0
   \   0000003C   0120A0E3           MOV      R2,#+1
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       apply_patch
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F6FFFF0A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_2
   \   00000054   3080BDE8           POP      {R4,R5,PC}
   1066              }
   1067          
   1068              return 0;
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_0:
   \   00000058                      REQUIRE ?Subroutine35
   \   00000058                      ;; // Fall through to label ?Subroutine35
   1069          }
   1070          

   \                                 In segment CODE, align 4, keep-with-next
   1071          static void compose_patch(cJSON * const patches, const unsigned char * const operation, const unsigned char * const path, const unsigned char *suffix, const cJSON * const value)
   1072          {
   \                     compose_patch:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24709DE5           LDR      R7,[SP, #+36]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0290A0E1           MOV      R9,R2
   \   00000014   03A0A0E1           MOV      R10,R3
   1073              cJSON *patch = NULL;
   1074          
   1075              if ((patches == NULL) || (operation == NULL) || (path == NULL))
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   00005613           CMPNE    R6,#+0
   \   00000020   00005913           CMPNE    R9,#+0
   \   00000024   F08FBD08           POPEQ    {R4-R11,PC}
   1076              {
   1077                  return;
   1078              }
   1079          
   1080              patch = cJSON_CreateObject();
   \   00000028   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   0000002C   0050B0E1           MOVS     R5,R0
   1081              if (patch == NULL)
   \   00000030   F08FBD08           POPEQ    {R4-R11,PC}
   1082              {
   1083                  return;
   1084              }
   1085              cJSON_AddItemToObject(patch, "op", cJSON_CreateString((const char*)operation));
   \   00000034   0600A0E1           MOV      R0,R6
   1086          
   1087              if (suffix == NULL)
   \   00000038   ........           LDR      R6,??DataTable10  ;; ??invalid
   \   0000003C   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   00000040   0020A0E1           MOV      R2,R0
   \   00000044   ........           ADR      R1,??DataTable3  ;; "op"
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   00000050   00005AE3           CMP      R10,#+0
   \   00000054   0600001A           BNE      ??compose_patch_0
   1088              {
   1089                  cJSON_AddItemToObject(patch, "path", cJSON_CreateString((const char*)path));
   \   00000058   0900A0E1           MOV      R0,R9
   \   0000005C   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   00000060   0020A0E1           MOV      R2,R0
   \   00000064   4C1086E2           ADD      R1,R6,#+76
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   00000070   180000EA           B        ??compose_patch_1
   1090              }
   1091              else
   1092              {
   1093                  size_t suffix_length = pointer_encoded_length(suffix);
   \                     ??compose_patch_0:
   \   00000074   0A00A0E1           MOV      R0,R10
   \   00000078   ........           BL       pointer_encoded_length
   \   0000007C   0080A0E1           MOV      R8,R0
   1094                  size_t path_length = strlen((const char*)path);
   \   00000080   0900A0E1           MOV      R0,R9
   \   00000084   1B0000EF           SWI      +27
   \   00000088   00B0A0E1           MOV      R11,R0
   1095                  unsigned char *full_path = (unsigned char*)cJSON_malloc(path_length + suffix_length + sizeof("/"));
   \   0000008C   0B0088E0           ADD      R0,R8,R11
   \   00000090   020080E2           ADD      R0,R0,#+2
   \   00000094   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000098   0080A0E1           MOV      R8,R0
   1096          
   1097                  sprintf((char*)full_path, "%s/", (const char*)path);
   \   0000009C   0920A0E1           MOV      R2,R9
   \   000000A0   ........           ADR      R1,??DataTable8  ;; "%s/"
   \   000000A4   160000EF           SWI      +22
   1098                  encode_string_as_pointer(full_path + path_length + 1, suffix);
   \   000000A8   0A10A0E1           MOV      R1,R10
   \   000000AC   08008BE0           ADD      R0,R11,R8
   \   000000B0   010080E2           ADD      R0,R0,#+1
   \   000000B4   ........           BL       encode_string_as_pointer
   1099          
   1100                  cJSON_AddItemToObject(patch, "path", cJSON_CreateString((const char*)full_path));
   \   000000B8   0800A0E1           MOV      R0,R8
   \   000000BC   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   000000C0   0020A0E1           MOV      R2,R0
   \   000000C4   4C1086E2           ADD      R1,R6,#+76
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1101                  cJSON_free(full_path);
   \   000000D0   0800A0E1           MOV      R0,R8
   \   000000D4   ........           _BLF     cJSON_free,??cJSON_free??rA
   1102              }
   1103          
   1104              if (value != NULL)
   \                     ??compose_patch_1:
   \   000000D8   000057E3           CMP      R7,#+0
   \   000000DC   0600000A           BEQ      ??compose_patch_2
   1105              {
   1106                  cJSON_AddItemToObject(patch, "value", cJSON_Duplicate(value, 1));
   \   000000E0   0110A0E3           MOV      R1,#+1
   \   000000E4   0700A0E1           MOV      R0,R7
   \   000000E8   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000000EC   0020A0E1           MOV      R2,R0
   \   000000F0   541086E2           ADD      R1,R6,#+84
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1107              }
   1108              cJSON_AddItemToArray(patches, patch);
   \                     ??compose_patch_2:
   \   000000FC   0510A0E1           MOV      R1,R5
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   ........           _BLF     cJSON_AddItemToArray,??cJSON_AddItemToArray??rA
   1109          }
   \   00000108   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1110          

   \                                 In segment CODE, align 4, keep-with-next
   1111          CJSON_PUBLIC(void) cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value)
   1112          {
   \                     cJSONUtils_AddPatchToArray:
   \   00000000   00402DE9           PUSH     {LR}
   1113              compose_patch(array, (const unsigned char*)operation, (const unsigned char*)path, NULL, value);
   \   00000004   08002DE9           PUSH     {R3}
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   ........           BL       compose_patch
   1114          }
   \   00000010   0180BDE8           POP      {R0,PC}          ;; return
   1115          

   \                                 In segment CODE, align 4, keep-with-next
   1116          static void create_patches(cJSON * const patches, const unsigned char * const path, cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)
   1117          {
   \                     create_patches:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24809DE5           LDR      R8,[SP, #+36]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0290A0E1           MOV      R9,R2
   \   00000014   0360A0E1           MOV      R6,R3
   1118              if ((from == NULL) || (to == NULL))
   \   00000018   000059E3           CMP      R9,#+0
   \   0000001C   00005613           CMPNE    R6,#+0
   \   00000020   F08FBD08           POPEQ    {R4-R11,PC}
   1119              {
   1120                  return;
   1121              }
   1122          
   1123              if ((from->type & 0xFF) != (to->type & 0xFF))
   \   00000024   0C0099E5           LDR      R0,[R9, #+12]
   \   00000028   0C2096E5           LDR      R2,[R6, #+12]
   \   0000002C   ........           LDR      R7,??DataTable10  ;; ??invalid
   \   00000030   FF1000E2           AND      R1,R0,#0xFF
   \   00000034   FF2002E2           AND      R2,R2,#0xFF
   \   00000038   020051E1           CMP      R1,R2
   \   0000003C   1800001A           BNE      ??create_patches_0
   1124              {
   1125                  compose_patch(patches, (const unsigned char*)"replace", path, 0, to);
   \                     ??create_patches_1:
   \   00000040   FF0000E2           AND      R0,R0,#0xFF
   \   00000044   080050E2           SUBS     R0,R0,#+8
   \   00000048   0600000A           BEQ      ??create_patches_2
   \   0000004C   080050E2           SUBS     R0,R0,#+8
   \   00000050   0E00000A           BEQ      ??create_patches_3
   \   00000054   100050E2           SUBS     R0,R0,#+16
   \   00000058   1900000A           BEQ      ??create_patches_4
   \   0000005C   200050E2           SUBS     R0,R0,#+32
   \   00000060   5200000A           BEQ      ??create_patches_5
   \   00000064   F08FBDE8           POP      {R4-R11,PC}
   1126                  return;
   1127              }
   1128          
   1129              switch (from->type & 0xFF)
   1130              {
   1131                  case cJSON_Number:
   1132                      if ((from->valueint != to->valueint) || (from->valuedouble != to->valuedouble))
   \                     ??create_patches_2:
   \   00000068   140099E5           LDR      R0,[R9, #+20]
   \   0000006C   141096E5           LDR      R1,[R6, #+20]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   0A00001A           BNE      ??create_patches_0
   \   00000078   180099E5           LDR      R0,[R9, #+24]
   \   0000007C   1C1099E5           LDR      R1,[R9, #+28]
   \   00000080   182096E5           LDR      R2,[R6, #+24]
   \   00000084   1C3096E5           LDR      R3,[R6, #+28]
   \   00000088   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   0000008C   020000EA           B        ??create_patches_6
   1133                      {
   1134                          compose_patch(patches, (const unsigned char*)"replace", path, NULL, to);
   1135                      }
   1136                      return;
   1137          
   1138                  case cJSON_String:
   1139                      if (strcmp(from->valuestring, to->valuestring) != 0)
   \                     ??create_patches_3:
   \   00000090   100099E5           LDR      R0,[R9, #+16]
   \   00000094   101096E5           LDR      R1,[R6, #+16]
   \   00000098   190000EF           SWI      +25
   \                     ??create_patches_6:
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   F08FBD08           POPEQ    {R4-R11,PC}
   1140                      {
   1141                          compose_patch(patches, (const unsigned char*)"replace", path, NULL, to);
   \                     ??create_patches_0:
   \   000000A4   40002DE9           PUSH     {R6}
   \   000000A8   0030A0E3           MOV      R3,#+0
   \   000000AC   0520A0E1           MOV      R2,R5
   \   000000B0   2C1087E2           ADD      R1,R7,#+44
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   ........           BL       compose_patch
   \   000000BC   04D08DE2           ADD      SP,SP,#+4
   \   000000C0   F08FBDE8           POP      {R4-R11,PC}
   1142                      }
   1143                      return;
   1144          
   1145                  case cJSON_Array:
   1146                  {
   1147                      size_t index = 0;
   1148                      cJSON *from_child = from->child;
   \                     ??create_patches_4:
   \   000000C4   089099E5           LDR      R9,[R9, #+8]
   1149                      cJSON *to_child = to->child;
   \   000000C8   086096E5           LDR      R6,[R6, #+8]
   1150                      unsigned char *new_path = (unsigned char*)cJSON_malloc(strlen((const char*)path) + 20 + sizeof("/")); /* Allow space for 64bit int. log10(2^64) = 20 */
   \   000000CC   0500A0E1           MOV      R0,R5
   \   000000D0   1B0000EF           SWI      +27
   \   000000D4   160080E2           ADD      R0,R0,#+22
   \   000000D8   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   000000DC   00A0A0E1           MOV      R10,R0
   1151          
   1152                      /* generate patches for all array elements that exist in both "from" and "to" */
   1153                      for (index = 0; (from_child != NULL) && (to_child != NULL); (void)(from_child = from_child->next), (void)(to_child = to_child->next), index++)
   \   000000E0   00B0A0E3           MOV      R11,#+0
   \   000000E4   110000EA           B        ??create_patches_7
   \                     ??create_patches_8:
   \   000000E8   000056E3           CMP      R6,#+0
   \   000000EC   1300000A           BEQ      ??create_patches_9
   1154                      {
   1155                          /* check if conversion to unsigned long is valid
   1156                           * This should be eliminated at compile time by dead code elimination
   1157                           * if size_t is an alias of unsigned long, or if it is bigger */
   1158                          if (index > ULONG_MAX)
   1159                          {
   1160                              cJSON_free(new_path);
   1161                              return;
   1162                          }
   1163                          sprintf((char*)new_path, "%s/%lu", path, (unsigned long)index); /* path of the current array element */
   \   000000F0   0B30A0E1           MOV      R3,R11
   \   000000F4   0520A0E1           MOV      R2,R5
   \   000000F8   641087E2           ADD      R1,R7,#+100
   \   000000FC   0A00A0E1           MOV      R0,R10
   \   00000100   160000EF           SWI      +22
   1164                          create_patches(patches, new_path, from_child, to_child, case_sensitive);
   \   00000104   0800A0E1           MOV      R0,R8
   \   00000108   01002DE9           PUSH     {R0}
   \   0000010C   0630A0E1           MOV      R3,R6
   \   00000110   0920A0E1           MOV      R2,R9
   \   00000114   0A10A0E1           MOV      R1,R10
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   B7FFFFEB           BL       create_patches
   1165                      }
   \   00000120   009099E5           LDR      R9,[R9, #+0]
   \   00000124   006096E5           LDR      R6,[R6, #+0]
   \   00000128   01B08BE2           ADD      R11,R11,#+1
   \   0000012C   04D08DE2           ADD      SP,SP,#+4
   \                     ??create_patches_7:
   \   00000130   000059E3           CMP      R9,#+0
   \   00000134   EBFFFF1A           BNE      ??create_patches_8
   1166          
   1167                      /* remove leftover elements from 'from' that are not in 'to' */
   1168                      for (; (from_child != NULL); (void)(from_child = from_child->next))
   \                     ??create_patches_10:
   \   00000138   000059E3           CMP      R9,#+0
   \   0000013C   1600000A           BEQ      ??create_patches_11
   1169                      {
   1170                          /* check if conversion to unsigned long is valid
   1171                           * This should be eliminated at compile time by dead code elimination
   1172                           * if size_t is an alias of unsigned long, or if it is bigger */
   1173                          if (index > ULONG_MAX)
   1174                          {
   1175                              cJSON_free(new_path);
   1176                              return;
   1177                          }
   1178                          sprintf((char*)new_path, "%lu", (unsigned long)index);
   \                     ??create_patches_9:
   \   00000140   0B20A0E1           MOV      R2,R11
   \   00000144   5C1F8FE2           ADR      R1,??create_patches_12  ;; "%lu"
   \   00000148   0A00A0E1           MOV      R0,R10
   \   0000014C   160000EF           SWI      +22
   1179                          compose_patch(patches, (const unsigned char*)"remove", path, new_path, NULL);
   \   00000150   0000A0E3           MOV      R0,#+0
   \   00000154   01002DE9           PUSH     {R0}
   \   00000158   0A30A0E1           MOV      R3,R10
   \   0000015C   0520A0E1           MOV      R2,R5
   \   00000160   241087E2           ADD      R1,R7,#+36
   \   00000164   0400A0E1           MOV      R0,R4
   \   00000168   ........           BL       compose_patch
   1180                      }
   \   0000016C   009099E5           LDR      R9,[R9, #+0]
   \   00000170   04D08DE2           ADD      SP,SP,#+4
   \   00000174   EFFFFFEA           B        ??create_patches_10
   1181                      /* add new elements in 'to' that were not in 'from' */
   1182                      for (; (to_child != NULL); (void)(to_child = to_child->next), index++)
   1183                      {
   1184                          compose_patch(patches, (const unsigned char*)"add", path, (const unsigned char*)"-", to_child);
   \                     ??create_patches_13:
   \   00000178   0600A0E1           MOV      R0,R6
   \   0000017C   01002DE9           PUSH     {R0}
   \   00000180   ........           ADR      R3,??DataTable6  ;; "-"
   \   00000184   0520A0E1           MOV      R2,R5
   \   00000188   ........           ADR      R1,??DataTable9  ;; "add"
   \   0000018C   0400A0E1           MOV      R0,R4
   \   00000190   ........           BL       compose_patch
   1185                      }
   \   00000194   006096E5           LDR      R6,[R6, #+0]
   \   00000198   04D08DE2           ADD      SP,SP,#+4
   \                     ??create_patches_11:
   \   0000019C   000056E3           CMP      R6,#+0
   \   000001A0   F4FFFF1A           BNE      ??create_patches_13
   1186                      cJSON_free(new_path);
   \   000001A4   0A00A0E1           MOV      R0,R10
   \   000001A8   ........           _BLF     cJSON_free,??cJSON_free??rA
   1187                      return;
   \   000001AC   F08FBDE8           POP      {R4-R11,PC}
   1188                  }
   1189          
   1190                  case cJSON_Object:
   1191                  {
   1192                      cJSON *from_child = NULL;
   1193                      cJSON *to_child = NULL;
   1194                      sort_object(from, case_sensitive);
   \                     ??create_patches_5:
   \   000001B0   0810A0E1           MOV      R1,R8
   \   000001B4   0900A0E1           MOV      R0,R9
   \   000001B8   ........           BL       sort_object
   1195                      sort_object(to, case_sensitive);
   \   000001BC   0810A0E1           MOV      R1,R8
   \   000001C0   0600A0E1           MOV      R0,R6
   \   000001C4   ........           BL       sort_object
   1196          
   1197                      from_child = from->child;
   \   000001C8   089099E5           LDR      R9,[R9, #+8]
   1198                      to_child = to->child;
   \   000001CC   086096E5           LDR      R6,[R6, #+8]
   \   000001D0   1B0000EA           B        ??create_patches_14
   1199                      /* for all object values in the object with more of them */
   1200                      while ((from_child != NULL) || (to_child != NULL))
   1201                      {
   1202                          int diff;
   1203                          if (from_child == NULL)
   1204                          {
   1205                              diff = 1;
   1206                          }
   1207                          else if (to_child == NULL)
   1208                          {
   1209                              diff = -1;
   1210                          }
   1211                          else
   1212                          {
   1213                              diff = compare_strings((unsigned char*)from_child->string, (unsigned char*)to_child->string, case_sensitive);
   1214                          }
   1215          
   1216                          if (diff == 0)
   1217                          {
   1218                              /* both object keys are the same */
   1219                              size_t path_length = strlen((const char*)path);
   \                     ??create_patches_15:
   \   000001D4   0500A0E1           MOV      R0,R5
   \   000001D8   1B0000EF           SWI      +27
   \   000001DC   00A0A0E1           MOV      R10,R0
   1220                              size_t from_child_name_length = pointer_encoded_length((unsigned char*)from_child->string);
   \   000001E0   200099E5           LDR      R0,[R9, #+32]
   \   000001E4   ........           BL       pointer_encoded_length
   1221                              unsigned char *new_path = (unsigned char*)cJSON_malloc(path_length + from_child_name_length + sizeof("/"));
   \   000001E8   00008AE0           ADD      R0,R10,R0
   \   000001EC   020080E2           ADD      R0,R0,#+2
   \   000001F0   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   000001F4   00B0A0E1           MOV      R11,R0
   1222          
   1223                              sprintf((char*)new_path, "%s/", path);
   \   000001F8   0520A0E1           MOV      R2,R5
   \   000001FC   ........           ADR      R1,??DataTable8  ;; "%s/"
   \   00000200   160000EF           SWI      +22
   1224                              encode_string_as_pointer(new_path + path_length + 1, (unsigned char*)from_child->string);
   \   00000204   201099E5           LDR      R1,[R9, #+32]
   \   00000208   0B008AE0           ADD      R0,R10,R11
   \   0000020C   010080E2           ADD      R0,R0,#+1
   \   00000210   ........           BL       encode_string_as_pointer
   1225          
   1226                              /* create a patch for the element */
   1227                              create_patches(patches, new_path, from_child, to_child, case_sensitive);
   \   00000214   0800A0E1           MOV      R0,R8
   \   00000218   01002DE9           PUSH     {R0}
   \   0000021C   0630A0E1           MOV      R3,R6
   \   00000220   0920A0E1           MOV      R2,R9
   \   00000224   0B10A0E1           MOV      R1,R11
   \   00000228   0400A0E1           MOV      R0,R4
   \   0000022C   73FFFFEB           BL       create_patches
   1228                              cJSON_free(new_path);
   \   00000230   0B00A0E1           MOV      R0,R11
   \   00000234   ........           _BLF     cJSON_free,??cJSON_free??rA
   1229          
   1230                              from_child = from_child->next;
   \   00000238   009099E5           LDR      R9,[R9, #+0]
   1231                              to_child = to_child->next;
   \                     ??create_patches_16:
   \   0000023C   006096E5           LDR      R6,[R6, #+0]
   \                     ??create_patches_17:
   \   00000240   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   1232                          }
   \                     ??create_patches_14:
   \   00000244   000059E3           CMP      R9,#+0
   \   00000248   0900001A           BNE      ??create_patches_18
   \   0000024C   000056E3           CMP      R6,#+0
   \   00000250   F08FBD08           POPEQ    {R4-R11,PC}
   1233                          else if (diff < 0)
   1234                          {
   1235                              /* object element doesn't exist in 'to' --> remove it */
   1236                              compose_patch(patches, (const unsigned char*)"remove", path, (unsigned char*)from_child->string, NULL);
   1237          
   1238                              from_child = from_child->next;
   1239                          }
   1240                          else
   1241                          {
   1242                              /* object element doesn't exist in 'from' --> add it */
   1243                              compose_patch(patches, (const unsigned char*)"add", path, (unsigned char*)to_child->string, to_child);
   \                     ??create_patches_19:
   \   00000254   0600A0E1           MOV      R0,R6
   \   00000258   01002DE9           PUSH     {R0}
   \   0000025C   203096E5           LDR      R3,[R6, #+32]
   \   00000260   0520A0E1           MOV      R2,R5
   \   00000264   ........           ADR      R1,??DataTable9  ;; "add"
   \   00000268   0400A0E1           MOV      R0,R4
   \   0000026C   ........           BL       compose_patch
   1244          
   1245                              to_child = to_child->next;
   \   00000270   F1FFFFEA           B        ??create_patches_16
   1246                          }
   \                     ??create_patches_18:
   \   00000274   000056E3           CMP      R6,#+0
   \   00000278   0600000A           BEQ      ??create_patches_20
   \   0000027C   200099E5           LDR      R0,[R9, #+32]
   \   00000280   201096E5           LDR      R1,[R6, #+32]
   \   00000284   0820A0E1           MOV      R2,R8
   \   00000288   ........           BL       compare_strings
   \   0000028C   000050E3           CMP      R0,#+0
   \   00000290   CFFFFF0A           BEQ      ??create_patches_15
   \   00000294   EEFFFF5A           BPL      ??create_patches_19
   \                     ??create_patches_20:
   \   00000298   0000A0E3           MOV      R0,#+0
   \   0000029C   01002DE9           PUSH     {R0}
   \   000002A0   203099E5           LDR      R3,[R9, #+32]
   \   000002A4   0520A0E1           MOV      R2,R5
   \   000002A8   241087E2           ADD      R1,R7,#+36
   \   000002AC   0400A0E1           MOV      R0,R4
   \   000002B0   ........           BL       compose_patch
   \   000002B4   009099E5           LDR      R9,[R9, #+0]
   \   000002B8   E0FFFFEA           B        ??create_patches_17
   \                     ??create_patches_12:
   \   000002BC   256C7500           DC8      "%lu"
   1247                      }
   1248                      return;
   1249                  }
   1250          
   1251                  default:
   1252                      break;
   1253              }
   1254          }
   1255          

   \                                 In segment CODE, align 4, keep-with-next
   1256          CJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to)
   1257          {
   \                     cJSONUtils_GeneratePatches:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1258              cJSON *patches = NULL;
   1259          
   1260              if ((from == NULL) || (to == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   1261              {
   1262                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
   1263              }
   1264          
   1265              patches = cJSON_CreateArray();
   \   0000001C   ........           _BLF     cJSON_CreateArray,??cJSON_CreateArray??rA
   \   00000020   0060A0E1           MOV      R6,R0
   1266              create_patches(patches, (const unsigned char*)"", from, to, false);
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   ........           B        ?Subroutine33
   1267          
   1268              return patches;
   1269          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine33:
   \   00000000   01002DE9           PUSH     {R0}
   \   00000004   0530A0E1           MOV      R3,R5
   \   00000008   0420A0E1           MOV      R2,R4
   \   0000000C   ........           ADR      R1,??DataTable11  ;; ""
   \   00000010   0600A0E1           MOV      R0,R6
   \   00000014   ........           BL       create_patches
   \   00000018   0600A0E1           MOV      R0,R6
   \   0000001C   04D08DE2           ADD      SP,SP,#+4
   \   00000020   7080BDE8           POP      {R4-R6,PC}       ;; return
   1270          

   \                                 In segment CODE, align 4, keep-with-next
   1271          CJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to)
   1272          {
   \                     cJSONUtils_GeneratePatchesCaseSensitive:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1273              cJSON *patches = NULL;
   1274          
   1275              if ((from == NULL) || (to == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   1276              {
   1277                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
   1278              }
   1279          
   1280              patches = cJSON_CreateArray();
   \   0000001C   ........           _BLF     cJSON_CreateArray,??cJSON_CreateArray??rA
   \   00000020   0060A0E1           MOV      R6,R0
   1281              create_patches(patches, (const unsigned char*)"", from, to, true);
   \   00000024   0100A0E3           MOV      R0,#+1
   \   00000028                      REQUIRE ?Subroutine33
   \   00000028                      ;; // Fall through to label ?Subroutine33
   1282          
   1283              return patches;
   1284          }
   1285          

   \                                 In segment CODE, align 4, keep-with-next
   1286          CJSON_PUBLIC(void) cJSONUtils_SortObject(cJSON * const object)
   1287          {
   1288              sort_object(object, false);
   \                     cJSONUtils_SortObject:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   ........           B        sort_object      ;; tailcall
   1289          }
   1290          

   \                                 In segment CODE, align 4, keep-with-next
   1291          CJSON_PUBLIC(void) cJSONUtils_SortObjectCaseSensitive(cJSON * const object)
   1292          {
   1293              sort_object(object, true);
   \                     cJSONUtils_SortObjectCaseSensitive:
   \   00000000   0110A0E3           MOV      R1,#+1
   \   00000004   ........           B        sort_object      ;; tailcall
   1294          }
   1295          

   \                                 In segment CODE, align 4, keep-with-next
   1296          static cJSON *merge_patch(cJSON *target, const cJSON * const patch, const cJSON_bool case_sensitive)
   1297          {
   \                     merge_patch:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1298              cJSON *patch_child = NULL;
   1299          
   1300              if (!cJSON_IsObject(patch))
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   0400001A           BNE      ??merge_patch_0
   1301              {
   1302                  /* scalar value, array or NULL, just duplicate */
   1303                  cJSON_Delete(target);
   \   00000024   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1304                  return cJSON_Duplicate(patch, 1);
   \   00000028   0110A0E3           MOV      R1,#+1
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000034   7080BDE8           POP      {R4-R6,PC}
   1305              }
   1306          
   1307              if (!cJSON_IsObject(target))
   \                     ??merge_patch_0:
   \   00000038   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0300001A           BNE      ??merge_patch_1
   1308              {
   1309                  cJSON_Delete(target);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1310                  target = cJSON_CreateObject();
   \   0000004C   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   00000050   0040A0E1           MOV      R4,R0
   1311              }
   1312          
   1313              patch_child = patch->child;
   \                     ??merge_patch_1:
   \   00000054   085095E5           LDR      R5,[R5, #+8]
   \   00000058   040000EA           B        ??merge_patch_2
   1314              while (patch_child != NULL)
   1315              {
   1316                  if (cJSON_IsNull(patch_child))
   1317                  {
   1318                      /* NULL is the indicator to remove a value, see RFC7396 */
   1319                      if (case_sensitive)
   1320                      {
   1321                          cJSON_DeleteItemFromObjectCaseSensitive(target, patch_child->string);
   1322                      }
   1323                      else
   1324                      {
   1325                          cJSON_DeleteItemFromObject(target, patch_child->string);
   1326                      }
   1327                  }
   1328                  else
   1329                  {
   1330                      cJSON *replace_me = NULL;
   1331                      cJSON *replacement = NULL;
   1332          
   1333                      if (case_sensitive)
   1334                      {
   1335                          replace_me = cJSON_DetachItemFromObjectCaseSensitive(target, patch_child->string);
   1336                      }
   1337                      else
   1338                      {
   1339                          replace_me = cJSON_DetachItemFromObject(target, patch_child->string);
   1340                      }
   1341          
   1342                      replacement = merge_patch(replace_me, patch_child, case_sensitive);
   1343                      if (replacement == NULL)
   1344                      {
   1345                          return NULL;
   1346                      }
   1347          
   1348                      cJSON_AddItemToObject(target, patch_child->string, replacement);
   \                     ??merge_patch_3:
   \   0000005C   201095E5           LDR      R1,[R5, #+32]
   \   00000060   0020A0E1           MOV      R2,R0
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1349                  }
   1350                  patch_child = patch_child->next;
   \                     ??merge_patch_4:
   \   0000006C   005095E5           LDR      R5,[R5, #+0]
   \                     ??merge_patch_2:
   \   00000070   000055E3           CMP      R5,#+0
   \   00000074   1700000A           BEQ      ??merge_patch_5
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           _BLF     cJSON_IsNull,??cJSON_IsNull??rA
   \   00000080   201095E5           LDR      R1,[R5, #+32]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0600000A           BEQ      ??merge_patch_6
   \   0000008C   000056E3           CMP      R6,#+0
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   0100000A           BEQ      ??merge_patch_7
   \   00000098   ........           _BLF     cJSON_DeleteItemFromObjectCaseSensitive,??cJSON_DeleteItemFromObjectCaseSensitive??rA
   \   0000009C   F2FFFFEA           B        ??merge_patch_4
   \                     ??merge_patch_7:
   \   000000A0   ........           _BLF     cJSON_DeleteItemFromObject,??cJSON_DeleteItemFromObject??rA
   \   000000A4   F0FFFFEA           B        ??merge_patch_4
   \                     ??merge_patch_6:
   \   000000A8   000056E3           CMP      R6,#+0
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   0100000A           BEQ      ??merge_patch_8
   \   000000B4   ........           _BLF     cJSON_DetachItemFromObjectCaseSensitive,??cJSON_DetachItemFromObjectCaseSensitive??rA
   \   000000B8   000000EA           B        ??merge_patch_9
   \                     ??merge_patch_8:
   \   000000BC   ........           _BLF     cJSON_DetachItemFromObject,??cJSON_DetachItemFromObject??rA
   \                     ??merge_patch_9:
   \   000000C0   0620A0E1           MOV      R2,R6
   \   000000C4   0510A0E1           MOV      R1,R5
   \   000000C8   CCFFFFEB           BL       merge_patch
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   E1FFFF1A           BNE      ??merge_patch_3
   \   000000D4   7080BDE8           POP      {R4-R6,PC}
   1351              }
   1352              return target;
   \                     ??merge_patch_5:
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   7080BDE8           POP      {R4-R6,PC}       ;; return
   1353          }
   1354          

   \                                 In segment CODE, align 4, keep-with-next
   1355          CJSON_PUBLIC(cJSON *) cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch)
   1356          {
   1357              return merge_patch(target, patch, false);
   \                     cJSONUtils_MergePatch:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        merge_patch      ;; tailcall
   1358          }
   1359          

   \                                 In segment CODE, align 4, keep-with-next
   1360          CJSON_PUBLIC(cJSON *) cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch)
   1361          {
   1362              return merge_patch(target, patch, true);
   \                     cJSONUtils_MergePatchCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        merge_patch      ;; tailcall
   1363          }
   1364          

   \                                 In segment CODE, align 4, keep-with-next
   1365          static cJSON *generate_merge_patch(cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)
   1366          {
   \                     generate_merge_patch:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1367              cJSON *from_child = NULL;
   1368              cJSON *to_child = NULL;
   1369              cJSON *patch = NULL;
   1370              if (to == NULL)
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   0100001A           BNE      ??generate_merge_patch_0
   1371              {
   1372                  /* patch to delete everything */
   1373                  return cJSON_CreateNull();
   \   00000018   ........           _BLF     cJSON_CreateNull,??cJSON_CreateNull??rA
   \   0000001C   F080BDE8           POP      {R4-R7,PC}
   1374              }
   1375              if (!cJSON_IsObject(to) || !cJSON_IsObject(from))
   \                     ??generate_merge_patch_0:
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0300000A           BEQ      ??generate_merge_patch_1
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300001A           BNE      ??generate_merge_patch_2
   1376              {
   1377                  return cJSON_Duplicate(to, 1);
   \                     ??generate_merge_patch_1:
   \   00000040   0110A0E3           MOV      R1,#+1
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   0000004C   F080BDE8           POP      {R4-R7,PC}
   1378              }
   1379          
   1380              sort_object(from, case_sensitive);
   \                     ??generate_merge_patch_2:
   \   00000050   0610A0E1           MOV      R1,R6
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       sort_object
   1381              sort_object(to, case_sensitive);
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   ........           BL       sort_object
   1382          
   1383              from_child = from->child;
   \   00000068   084094E5           LDR      R4,[R4, #+8]
   1384              to_child = to->child;
   \   0000006C   085095E5           LDR      R5,[R5, #+8]
   1385              patch = cJSON_CreateObject();
   \   00000070   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   00000074   0070A0E1           MOV      R7,R0
   \   00000078   050000EA           B        ??generate_merge_patch_3
   1386              while (from_child || to_child)
   1387              {
   1388                  int diff;
   1389                  if (from_child != NULL)
   1390                  {
   1391                      if (to_child != NULL)
   1392                      {
   1393                          diff = strcmp(from_child->string, to_child->string);
   1394                      }
   1395                      else
   1396                      {
   1397                          diff = -1;
   1398                      }
   1399                  }
   1400                  else
   1401                  {
   1402                      diff = 1;
   1403                  }
   1404          
   1405                  if (diff < 0)
   1406                  {
   1407                      /* from has a value that to doesn't have -> remove */
   1408                      cJSON_AddItemToObject(patch, from_child->string, cJSON_CreateNull());
   \                     ??generate_merge_patch_4:
   \   0000007C   ........           _BLF     cJSON_CreateNull,??cJSON_CreateNull??rA
   \   00000080   201094E5           LDR      R1,[R4, #+32]
   \   00000084   0020A0E1           MOV      R2,R0
   \   00000088   0700A0E1           MOV      R0,R7
   \   0000008C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1409          
   1410                      from_child = from_child->next;
   \   00000090   004094E5           LDR      R4,[R4, #+0]
   1411                  }
   \                     ??generate_merge_patch_3:
   \   00000094   000054E3           CMP      R4,#+0
   \   00000098   0700001A           BNE      ??generate_merge_patch_5
   \   0000009C   000055E3           CMP      R5,#+0
   \   000000A0   0E00001A           BNE      ??generate_merge_patch_6
   1412                  else if (diff > 0)
   1413                  {
   1414                      /* to has a value that from doesn't have -> add to patch */
   1415                      cJSON_AddItemToObject(patch, to_child->string, cJSON_Duplicate(to_child, 1));
   1416          
   1417                      to_child = to_child->next;
   1418                  }
   1419                  else
   1420                  {
   1421                      /* object key exists in both objects */
   1422                      if (!compare_json(from_child, to_child, case_sensitive))
   1423                      {
   1424                          /* not identical --> generate a patch */
   1425                          cJSON_AddItemToObject(patch, to_child->string, cJSONUtils_GenerateMergePatch(from_child, to_child));
   1426                      }
   1427          
   1428                      /* next key in the object */
   1429                      from_child = from_child->next;
   1430                      to_child = to_child->next;
   1431                  }
   1432              }
   1433              if (patch->child == NULL)
   \   000000A4   080097E5           LDR      R0,[R7, #+8]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   0700A0E1           MOV      R0,R7
   \   000000B0   F080BD18           POPNE    {R4-R7,PC}
   1434              {
   1435                  /* no patch generated */
   1436                  cJSON_Delete(patch);
   \   000000B4   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1437                  return NULL;
   \   000000B8   ........           B        ?Subroutine34
   1438              }
   \                     ??generate_merge_patch_5:
   \   000000BC   000055E3           CMP      R5,#+0
   \   000000C0   EDFFFF0A           BEQ      ??generate_merge_patch_4
   \   000000C4   200094E5           LDR      R0,[R4, #+32]
   \   000000C8   201095E5           LDR      R1,[R5, #+32]
   \   000000CC   190000EF           SWI      +25
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   E8FFFF4A           BMI      ??generate_merge_patch_4
   \   000000D8   010050E3           CMP      R0,#+1
   \   000000DC   080000BA           BLT      ??generate_merge_patch_7
   \                     ??generate_merge_patch_6:
   \   000000E0   0110A0E3           MOV      R1,#+1
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000000EC   201095E5           LDR      R1,[R5, #+32]
   \   000000F0   0020A0E1           MOV      R2,R0
   \   000000F4   0700A0E1           MOV      R0,R7
   \   000000F8   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \                     ??generate_merge_patch_8:
   \   000000FC   005095E5           LDR      R5,[R5, #+0]
   \   00000100   E3FFFFEA           B        ??generate_merge_patch_3
   \                     ??generate_merge_patch_7:
   \   00000104   0620A0E1           MOV      R2,R6
   \   00000108   0510A0E1           MOV      R1,R5
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   ........           BL       compare_json
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   0600001A           BNE      ??generate_merge_patch_9
   \   0000011C   0510A0E1           MOV      R1,R5
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       cJSONUtils_GenerateMergePatch
   \   00000128   201095E5           LDR      R1,[R5, #+32]
   \   0000012C   0020A0E1           MOV      R2,R0
   \   00000130   0700A0E1           MOV      R0,R7
   \   00000134   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \                     ??generate_merge_patch_9:
   \   00000138   004094E5           LDR      R4,[R4, #+0]
   \   0000013C   EEFFFFEA           B        ??generate_merge_patch_8
   1439          
   1440              return patch;
   1441          }
   1442          

   \                                 In segment CODE, align 4, keep-with-next
   1443          CJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to)
   1444          {
   1445              return generate_merge_patch(from, to, false);
   \                     cJSONUtils_GenerateMergePatch:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        generate_merge_patch  ;; tailcall
   1446          }
   1447          

   \                                 In segment CODE, align 4, keep-with-next
   1448          CJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to)
   1449          {
   1450              return generate_merge_patch(from, to, true);
   \                     cJSONUtils_GenerateMergePatchCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        generate_merge_patch  ;; tailcall
   1451          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   2D000000           DC8      "-",+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   6F700000           DC8      "op",+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   2D000000           DC8      "-",+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   25732F00           DC8      "%s/"

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   61646400           DC8      "add"

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     ??invalid

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "/%lu%s">`:
   \   00000000   2F256C752573       DC8 "/%lu%s"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   6F7000             DC8 "op"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   61646400           DC8 "add"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   2D00               DC8 "-"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   25732F00           DC8 "%s/"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   256C7500           DC8 "%lu"

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     apply_patch                       76
     cJSONUtils_AddPatchToArray         8
     cJSONUtils_ApplyPatches           12
     cJSONUtils_ApplyPatchesCaseSensitive
                                       12
     cJSONUtils_FindPointerFromObjectTo
                                       24
     cJSONUtils_GenerateMergePatch      4
     cJSONUtils_GenerateMergePatchCaseSensitive
                                        4
     cJSONUtils_GeneratePatches        20
     cJSONUtils_GeneratePatchesCaseSensitive
                                       20
     cJSONUtils_GetPointer              4
     cJSONUtils_GetPointerCaseSensitive
                                        4
     cJSONUtils_MergePatch              4
     cJSONUtils_MergePatchCaseSensitive
                                        4
     cJSONUtils_SortObject              4
     cJSONUtils_SortObjectCaseSensitive
                                        4
     cJSONUtils_strdup                 16
     compare_json                      16
     compare_pointers                  20
     compare_strings                   16
     compose_patch                     36
     create_patches                    40
     decode_array_index_from_pointer
                                        4
     decode_pointer_inplace             0
     detach_path                       32
     encode_string_as_pointer           0
     generate_merge_patch              20
     get_item_from_pointer             24
     get_object_item                    4
     merge_patch                       16
     overwrite_item                     8
     pointer_encoded_length             0
     sort_list                         28
     sort_object                        8
     tolower                            0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     tolower                          20
     cJSONUtils_strdup                56
     compare_strings                 128
     compare_pointers                212
     ?Subroutine34                     8
     pointer_encoded_length           48
     encode_string_as_pointer         76
     cJSONUtils_FindPointerFromObjectTo
                                     280
     decode_array_index_from_pointer
                                     128
     get_item_from_pointer           232
     cJSONUtils_GetPointer             8
     cJSONUtils_GetPointerCaseSensitive
                                       8
     decode_pointer_inplace           96
     detach_path                     272
     sort_list                       348
     sort_object                      28
     compare_json                    360
     get_object_item                  16
     overwrite_item                   92
     apply_patch                    1144
     invalid                         108
     cJSONUtils_ApplyPatches          92
     ?Subroutine35                     8
     cJSONUtils_ApplyPatchesCaseSensitive
                                      88
     compose_patch                   268
     cJSONUtils_AddPatchToArray       20
     create_patches                  704
     cJSONUtils_GeneratePatches       44
     ?Subroutine33                    36
     cJSONUtils_GeneratePatchesCaseSensitive
                                      40
     cJSONUtils_SortObject             8
     cJSONUtils_SortObjectCaseSensitive
                                       8
     merge_patch                     224
     cJSONUtils_MergePatch             8
     cJSONUtils_MergePatchCaseSensitive
                                       8
     generate_merge_patch            320
     cJSONUtils_GenerateMergePatch     8
     cJSONUtils_GenerateMergePatchCaseSensitive
                                       8
     ??DataTable0                      4
     ??DataTable1                      4
     ??DataTable3                      4
     ??DataTable6                      4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable10                     4
     ??DataTable11                     4
     ?<Constant "">                    1
     ?<Constant "/%lu%s">              8
     ?<Constant "op">                  3
     ?<Constant "add">                 4
     ?<Constant "-">                   2
     ?<Constant "%s/">                 4
     ?<Constant "%lu">                 4
      Others                         396

 
 5 880 bytes in segment CODE
   134 bytes in segment DATA_C
 
 5 464 bytes of CODE  memory (+ 416 bytes shared)
   134 bytes of CONST memory

Errors: none
Warnings: 3
