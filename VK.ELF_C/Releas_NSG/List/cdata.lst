##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    15/Dec/2019  12:18:37 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\cdat #
#                       a.c                                                  #
#    Command line    =  D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\cdat #
#                       a.c -D NEWSGOLD -D DEBUG -lCN                        #
#                       D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\Rele #
#                       as_NSG\List\ -la D:\alfinant\Documents\Siemens\alfin #
#                       ant\VK.ELF_C\Releas_NSG\List\ -o                     #
#                       D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\Rele #
#                       as_NSG\Obj\ -z9 --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5tpainl8 #
#                       n.h -I D:\alfinant\Documents\Siemens\IAR\ARM\INC\    #
#                       --inline_threshold=2                                 #
#    List file       =  D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\Rele #
#                       as_NSG\List\cdata.lst                                #
#    Object file     =  D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\Rele #
#                       as_NSG\Obj\cdata.r79                                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\alfinant\Documents\Siemens\alfinant\VK.ELF_C\cdata.c
      1          #include "cdata.h"
      2          #include "url_utils.h"
      3          #include <siemens/swilib.h>
      4          

   \                                 In segment DATA_I, align 4, align-sorted
      5          static LIST_HEAD(connection_list);
   \                     connection_list:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for connection_list>`
      6          

   \                                 In segment CODE, align 4, keep-with-next
      7          CONNECTION *CONNECTION_new(char *url, int flag)
      8          {
   \                     CONNECTION_new:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0160A0E1           MOV      R6,R1
      9            CONNECTION *con = malloc(sizeof(CONNECTION));
   \   0000000C   6C00A0E3           MOV      R0,#+108
   \   00000010   140000EF           SWI      +20
   \   00000014   0040A0E1           MOV      R4,R0
     10            INIT_LIST_HEAD(&con->list);
     11            list_add(&con->list, &connection_list);
   \   00000018   ........           LDR      R0,??DataTable5  ;; connection_list
   \   0000001C   004084E5           STR      R4,[R4, #+0]
   \   00000020   044084E5           STR      R4,[R4, #+4]
   \   00000024   001090E5           LDR      R1,[R0, #+0]
     12            get_host_from_url(con->hostname, url);
     13            con->url = malloc(strlen(url)+1);
     14            strcpy(con->url, url);
     15            con->state = -1;
     16            con->DNR_ID = 0;
   \   00000028   0070A0E3           MOV      R7,#+0
   \   0000002C   044081E5           STR      R4,[R1, #+4]
   \   00000030   001084E5           STR      R1,[R4, #+0]
   \   00000034   040084E5           STR      R0,[R4, #+4]
   \   00000038   004080E5           STR      R4,[R0, #+0]
   \   0000003C   0510A0E1           MOV      R1,R5
   \   00000040   1C0084E2           ADD      R0,R4,#+28
   \   00000044   ........           _BLF     get_host_from_url,??get_host_from_url??rA
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   1B0000EF           SWI      +27
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   140000EF           SWI      +20
   \   00000058   5C0084E5           STR      R0,[R4, #+92]
   \   0000005C   0510A0E1           MOV      R1,R5
   \   00000060   1A0000EF           SWI      +26
   \   00000064   0000E0E3           MVN      R0,#+0
   \   00000068   100084E5           STR      R0,[R4, #+16]
   \   0000006C   087084E5           STR      R7,[R4, #+8]
     17            con->DNR_TRIES = 3;
   \   00000070   0310A0E3           MOV      R1,#+3
   \   00000074   0C1084E5           STR      R1,[R4, #+12]
     18            con->socket = -1;
     19            con->keepalive = flag;
     20            
     21            if (strncmp(url, "https://", 8)==0)
   \   00000078   34109FE5           LDR      R1,??CONNECTION_new_0  ;; `?<Constant "https://">`
   \   0000007C   140084E5           STR      R0,[R4, #+20]
   \   00000080   606084E5           STR      R6,[R4, #+96]
   \   00000084   0820A0E3           MOV      R2,#+8
   \   00000088   0500A0E1           MOV      R0,R5
   \   0000008C   150100EF           SWI      +277
   \   00000090   000050E3           CMP      R0,#+0
     22              con->port=443;
   \   00000094   BB00A003           MOVEQ    R0,#+187
   \   00000098   400F8003           ORREQ    R0,R0,#0x100
     23            else
     24              con->port=80;
   \   0000009C   5000A013           MOVNE    R0,#+80
   \   000000A0   180084E5           STR      R0,[R4, #+24]
     25            
     26            con->ssl = NULL;
   \   000000A4   647084E5           STR      R7,[R4, #+100]
     27            con->ssl_session = NULL;
   \   000000A8   687084E5           STR      R7,[R4, #+104]
     28            
     29            return con;
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??CONNECTION_new_0:
   \   000000B4   ........           DC32     `?<Constant "https://">`
     30          }
     31          

   \                                 In segment CODE, align 4, keep-with-next
     32          CONNECTION * CONNECTION_getTop()
     33          {
     34            return list_empty(&connection_list) ? 0 : (CONNECTION*)connection_list.next;
   \                     CONNECTION_getTop:
   \   00000000   ........           LDR      R1,??DataTable5  ;; connection_list
   \   00000004   000091E5           LDR      R0,[R1, #+0]
   \   00000008   010050E1           CMP      R0,R1
   \   0000000C   0000A003           MOVEQ    R0,#+0
   \   00000010   1EFF2FE1           BX       LR               ;; return
     35          }
     36          

   \                                 In segment CODE, align 4, keep-with-next
     37          void CONNECTION_set2Top(CONNECTION *con) 
     38          {
     39            list_move(&connection_list, (struct list_head*) con);
   \                     CONNECTION_set2Top:
   \   00000000   ........           LDR      R1,??DataTable5  ;; connection_list
   \   00000004   002091E5           LDR      R2,[R1, #+0]
   \   00000008   043091E5           LDR      R3,[R1, #+4]
   \   0000000C   043082E5           STR      R3,[R2, #+4]
   \   00000010   002083E5           STR      R2,[R3, #+0]
   \   00000014   002090E5           LDR      R2,[R0, #+0]
   \   00000018   041082E5           STR      R1,[R2, #+4]
   \   0000001C   002081E5           STR      R2,[R1, #+0]
   \   00000020   040081E5           STR      R0,[R1, #+4]
   \   00000024   001080E5           STR      R1,[R0, #+0]
     40          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
     41          

   \                                 In segment CODE, align 4, keep-with-next
     42          CONNECTION *CONNECTION_findBySSL(SSL *ssl)
     43          {
     44            struct list_head *iter;
     45            
     46            list_for_each(iter, &connection_list)
   \                     CONNECTION_findBySSL:
   \   00000000   ........           LDR      R2,??DataTable5  ;; connection_list
   \   00000004   001092E5           LDR      R1,[R2, #+0]
   \   00000008   000000EA           B        ??CONNECTION_findBySSL_0
   \                     ??CONNECTION_findBySSL_1:
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \                     ??CONNECTION_findBySSL_0:
   \   00000010   020051E1           CMP      R1,R2
   \   00000014   0300000A           BEQ      ??CONNECTION_findBySSL_2
     47            {
     48              CONNECTION *entry = list_entry(iter, CONNECTION, list);
     49              
     50              if (entry->ssl == ssl)
   \   00000018   643091E5           LDR      R3,[R1, #+100]
   \   0000001C   000053E1           CMP      R3,R0
   \   00000020   F9FFFF1A           BNE      ??CONNECTION_findBySSL_1
     51                return entry;
   \   00000024   ........           B        ?Subroutine7
     52            }
     53            return(0);  
   \                     ??CONNECTION_findBySSL_2:
   \   00000028   ........           B        ?Subroutine6
     54          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0100A0E1           MOV      R0,R1
   \   00000004   1EFF2FE1           BX       LR

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
     55          
     56          

   \                                 In segment CODE, align 4, keep-with-next
     57          CONNECTION * CONNECTION_findBySock(unsigned int sock)
     58          {
     59            struct list_head *iter;
     60            
     61            list_for_each(iter, &connection_list)
   \                     CONNECTION_findBySock:
   \   00000000   ........           LDR      R2,??DataTable5  ;; connection_list
   \   00000004   001092E5           LDR      R1,[R2, #+0]
   \   00000008   000000EA           B        ??CONNECTION_findBySock_0
   \                     ??CONNECTION_findBySock_1:
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \                     ??CONNECTION_findBySock_0:
   \   00000010   020051E1           CMP      R1,R2
   \   00000014   0600000A           BEQ      ??CONNECTION_findBySock_2
     62            {
     63              CONNECTION *entry = list_entry(iter, CONNECTION, list);
     64              
     65              if (entry->socket == sock && entry->ssl)
   \   00000018   143091E5           LDR      R3,[R1, #+20]
   \   0000001C   000053E1           CMP      R3,R0
   \   00000020   F9FFFF1A           BNE      ??CONNECTION_findBySock_1
   \   00000024   643091E5           LDR      R3,[R1, #+100]
   \   00000028   000053E3           CMP      R3,#+0
   \   0000002C   F6FFFF0A           BEQ      ??CONNECTION_findBySock_1
     66                return entry;
   \   00000030   ........           B        ?Subroutine7
     67            }
     68            return(0);  
   \                     ??CONNECTION_findBySock_2:
   \   00000034   ........           B        ?Subroutine6
     69          }
     70          
     71          

   \                                 In segment CODE, align 4, keep-with-next
     72          CONNECTION *CONNECTION_findByHostname(char *hostname)
     73          {
   \                     CONNECTION_findByHostname:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
     74            struct list_head *iter;
     75            
     76            list_for_each(iter, &connection_list)
   \   00000004   ........           LDR      R5,??DataTable5  ;; connection_list
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   000000EA           B        ??CONNECTION_findByHostname_0
   \                     ??CONNECTION_findByHostname_1:
   \   00000014   006096E5           LDR      R6,[R6, #+0]
   \                     ??CONNECTION_findByHostname_0:
   \   00000018   050056E1           CMP      R6,R5
   \   0000001C   0600000A           BEQ      ??CONNECTION_findByHostname_2
     77            {
     78              CONNECTION *entry = list_entry(iter, CONNECTION, list);
     79              if (strcmp(entry->hostname, hostname) == 0)
   \   00000020   0410A0E1           MOV      R1,R4
   \   00000024   1C0086E2           ADD      R0,R6,#+28
   \   00000028   190000EF           SWI      +25
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   F7FFFF1A           BNE      ??CONNECTION_findByHostname_1
     80                return entry;
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   7080BDE8           POP      {R4-R6,PC}
     81            }
     82            return(0);
   \                     ??CONNECTION_findByHostname_2:
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   7080BDE8           POP      {R4-R6,PC}       ;; return
     83          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     connection_list

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for connection_list>`:
   \   00000000   ............       DC32 connection_list, connection_list
   \              ....        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "https://">`:
   \   00000000   68747470733A       DC8 "https://"
   \              2F2F00      
   \   00000009   000000             DC8 0, 0, 0
     84          

   Maximum stack usage in bytes:

     Function                  CSTACK
     --------                  ------
     CONNECTION_findByHostname    16
     CONNECTION_findBySSL          0
     CONNECTION_findBySock         0
     CONNECTION_getTop             0
     CONNECTION_new               20
     CONNECTION_set2Top            0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     connection_list                   8
     CONNECTION_new                  184
     CONNECTION_getTop                20
     CONNECTION_set2Top               44
     CONNECTION_findBySSL             44
     ?Subroutine7                      8
     ?Subroutine6                      8
     CONNECTION_findBySock            56
     CONNECTION_findByHostname        68
     ??DataTable5                      4
     ?<Initializer for connection_list>
                                       8
     ?<Constant "https://">           12
      Others                          48

 
 472 bytes in segment CODE
  12 bytes in segment DATA_C
   8 bytes in segment DATA_I
   8 bytes in segment DATA_ID
  12 bytes in segment INITTAB
 
 436 bytes of CODE  memory (+ 48 bytes shared)
  20 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
