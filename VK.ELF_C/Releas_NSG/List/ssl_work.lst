##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    15/Mar/2023  22:35:41 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \ssl_work.c                                          #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \ssl_work.c -D NEWSGOLD -D DEBUG -lCN                #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ -la D:\Users\alfinant\Documents\Si #
#                       emens\Dev\IAR\VK.ELF_C\Releas_NSG\List\ -o           #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ -s9 --cpu_mode arm --endian little  #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ssl_work.lst                        #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ssl_work.r79                         #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\ssl_work.c
      1          //******************************************************************************
      2          // Имеем: openssl-0.9.5a скомпилированный с дефайном NO_DH(Диффи и Хеллман отсутствуют)
      3          // Проблем: vk.com перестал поддерживать наши древние наборы шифров
      4          // Mission: добавить поддержку AES128-SHA из AES ciphersuites from RFC3268(extending TLS v1.0)
      5          
      6          /*
      7          Siemens S75 ciphersuites:
      8          1. DES-CBC-SHA  0x0A
      9          2. RC4-SHA 0x05
     10          3. RC4-MD5 0x04
     11          4. EXP1024-RC4-SHA 0x64
     12          5. EXP1024-DES-CBC-SHA 0x62
     13          6. EXP1024-RC4-MD5 0x60
     14          7. DES-CBS-SHA 0x09
     15          8. EXP-DES-CBC-SHA 0x08
     16          9. EXP-RC4-MD5 0x03
     17          */
     18          
     19          //для теста на компе
     20          //s_client -connect m.vk.com:443 -tls1 -cipher AES128-SHA
     21          
     22          //s75v52
     23          //int EVP_add_cipher(const EVP_CIPHER *c); 0xA0E8F2B9
     24          
     25          /* int SSL_library_init(void):
     26          #ifndef OPENSSL_NO_AES
     27          	EVP_add_cipher(EVP_aes_128_cbc());
     28          	EVP_add_cipher(EVP_aes_192_cbc());
     29          	EVP_add_cipher(EVP_aes_256_cbc());
     30          #endif
     31          
     32          
     33          */
     34          //******************************************************************************
     35          #include "ssl_work.h"
     36          #include "socket_work.h"
     37          #include "buffer.h"
     38          #include <siemens/swilib.h>
     39          #include <openssl/ssl.h>
     40          #include "ssl_ext.h"
     41          
     42          #include "http.h"
     43          
     44          extern char logmsg[];
     45          extern void SMART_REDRAW();
     46          
     47          static SSL_CTX *ctx = NULL;

   \                                 In segment DATA_I, align 4, align-sorted
     48          int SSL_MAX_SESS_COUNT = 1;
   \                     SSL_MAX_SESS_COUNT:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for SSL_MAX_SESS_COUNT>`
     49          
     50          //******************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
     51          const char* tls1_alert_code_text(int code)
     52          {
     53            switch(code)
   \                     tls1_alert_code_text:
   \   00000000   A8109FE5           LDR      R1,??tls1_alert_code_text_1  ;; `?<Constant "close_notify">`
   \   00000004   2F0050E3           CMP      R0,#+47
   \   00000008   2600008A           BHI      ??tls1_alert_code_text_2
   \   0000000C   012F8FE2           ADR      R2,??tls1_alert_code_text_0
   \   00000010   0020D2E7           LDRB     R2,[R2, R0]
   \   00000014   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??tls1_alert_code_text_0:
   \   00000018   0B232323           DC8      +11,+35,+35,+35
   \   0000001C   23232323           DC8      +35,+35,+35,+35
   \   00000020   23230D23           DC8      +35,+35,+13,+35
   \   00000024   23232323           DC8      +35,+35,+35,+35
   \   00000028   23232323           DC8      +35,+35,+35,+35
   \   0000002C   0F232323           DC8      +15,+35,+35,+35
   \   00000030   23232323           DC8      +35,+35,+35,+35
   \   00000034   23231123           DC8      +35,+35,+17,+35
   \   00000038   23232323           DC8      +35,+35,+35,+35
   \   0000003C   23232323           DC8      +35,+35,+35,+35
   \   00000040   13151719           DC8      +19,+21,+23,+25
   \   00000044   1B1D1F21           DC8      +27,+29,+31,+33
     54            {
     55            case SSL3_AD_CLOSE_NOTIFY: return "close_notify";
   \                     ??tls1_alert_code_text_3:
   \   00000048   0100A0E1           MOV      R0,R1
   \   0000004C   1EFF2FE1           BX       LR
     56            case SSL3_AD_UNEXPECTED_MESSAGE: return "unexpected_message";
   \                     ??tls1_alert_code_text_4:
   \   00000050   100081E2           ADD      R0,R1,#+16
   \   00000054   1EFF2FE1           BX       LR
     57            case SSL3_AD_BAD_RECORD_MAC: return "bad_record_mac";
   \                     ??tls1_alert_code_text_5:
   \   00000058   240081E2           ADD      R0,R1,#+36
   \   0000005C   1EFF2FE1           BX       LR
     58            case SSL3_AD_DECOMPRESSION_FAILURE: return "decompression_failure";
   \                     ??tls1_alert_code_text_6:
   \   00000060   340081E2           ADD      R0,R1,#+52
   \   00000064   1EFF2FE1           BX       LR
     59            case SSL3_AD_HANDSHAKE_FAILURE: return  "handshake_failure";
   \                     ??tls1_alert_code_text_7:
   \   00000068   4C0081E2           ADD      R0,R1,#+76
   \   0000006C   1EFF2FE1           BX       LR
     60            case SSL3_AD_NO_CERTIFICATE: return "no_certificate";
   \                     ??tls1_alert_code_text_8:
   \   00000070   600081E2           ADD      R0,R1,#+96
   \   00000074   1EFF2FE1           BX       LR
     61            case SSL3_AD_BAD_CERTIFICATE: return "bad_certificate";
   \                     ??tls1_alert_code_text_9:
   \   00000078   700081E2           ADD      R0,R1,#+112
   \   0000007C   1EFF2FE1           BX       LR
     62            case SSL3_AD_UNSUPPORTED_CERTIFICATE: return "unsupported_certificate";
   \                     ??tls1_alert_code_text_10:
   \   00000080   800081E2           ADD      R0,R1,#+128
   \   00000084   1EFF2FE1           BX       LR
     63            case SSL3_AD_CERTIFICATE_REVOKED: return "certificate_revoked";
   \                     ??tls1_alert_code_text_11:
   \   00000088   980081E2           ADD      R0,R1,#+152
   \   0000008C   1EFF2FE1           BX       LR
     64            case SSL3_AD_CERTIFICATE_EXPIRED: return "certificate_expired";
   \                     ??tls1_alert_code_text_12:
   \   00000090   AC0081E2           ADD      R0,R1,#+172
   \   00000094   1EFF2FE1           BX       LR
     65            case SSL3_AD_CERTIFICATE_UNKNOWN: return "certificate_unknown";
   \                     ??tls1_alert_code_text_13:
   \   00000098   C00081E2           ADD      R0,R1,#+192
   \   0000009C   1EFF2FE1           BX       LR
     66            case SSL3_AD_ILLEGAL_PARAMETER: return "illegal_parameter";
   \                     ??tls1_alert_code_text_14:
   \   000000A0   D40081E2           ADD      R0,R1,#+212
   \   000000A4   1EFF2FE1           BX       LR
     67            default: return NULL;
   \                     ??tls1_alert_code_text_2:
   \   000000A8   0000A0E3           MOV      R0,#+0
   \   000000AC   1EFF2FE1           BX       LR               ;; return
   \                     ??tls1_alert_code_text_1:
   \   000000B0   ........           DC32     `?<Constant "close_notify">`
     68            }
     69          }
     70          

   \                                 In segment CODE, align 4, keep-with-next
     71          int SSL_session_reused(SSL *ssl)
     72          {
     73            return ssl->hit;
   \                     SSL_session_reused:
   \   00000000   5C0090E5           LDR      R0,[R0, #+92]
   \   00000004   1EFF2FE1           BX       LR               ;; return
     74          }
     75          
     76          //Чтобы SSL_connect() работал корректно, методы BIO реализуем сами. Ибо прошивочные BIO функции связаны со стандартным браузером.

   \                                 In segment CODE, align 4, keep-with-next
     77          int bread(BIO *b, char *data, int len)
     78          {
   \                     bread:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
     79            CONNDATA *conn=CONNDATA_getTop();
   \   0000000C   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000010   0060A0E1           MOV      R6,R0
     80             
     81            *socklasterr() = 0;
   \   00000014   7C8100EF           SWI      +33148
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   001080E5           STR      R1,[R0, #+0]
     82            
     83            int recv_res = recv(/*b->num*/conn->sock, data, len, 0);
   \   00000020   4C0096E5           LDR      R0,[R6, #+76]
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   0410A0E1           MOV      R1,R4
   \   00000030   780100EF           SWI      +376
   \   00000034   0050A0E1           MOV      R5,R0
     84            
     85            if (recv_res == -1 && *socklasterr() == 0xC9)
   \   00000038   010075E3           CMN      R5,#+1
   \   0000003C   0E00001A           BNE      ??bread_0
   \   00000040   7C8100EF           SWI      +33148
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   C90050E3           CMP      R0,#+201
   \   0000004C   0A00001A           BNE      ??bread_0
     86              
     87            {
     88              if(data[0] == SSL3_RT_ALERT)
   \   00000050   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000054   150050E3           CMP      R0,#+21
   \   00000058   0500001A           BNE      ??bread_1
     89              {
     90                sprintf(logmsg, tls1_alert_code_text(data[6]));
   \   0000005C   0600D4E5           LDRB     R0,[R4, #+6]
   \   00000060   ........           BL       tls1_alert_code_text
   \   00000064   0010A0E1           MOV      R1,R0
   \   00000068   ........           LDR      R0,??DataTable15  ;; logmsg
   \   0000006C   160000EF           SWI      +22
     91                SMART_REDRAW();
   \   00000070   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
     92              }
     93              return 0;
   \                     ??bread_1:
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   7080BDE8           POP      {R4-R6,PC}
     94            }
     95            
     96            return recv_res;  
   \                     ??bread_0:
   \   0000007C   0500A0E1           MOV      R0,R5
   \   00000080   7080BDE8           POP      {R4-R6,PC}       ;; return
     97          }
     98          

   \                                 In segment CODE, align 4, keep-with-next
     99          int bwrite(BIO *b, const char *data, int len)
    100          { 
   \                     bwrite:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0070A0E1           MOV      R7,R0
    101            CONNDATA *conn=CONNDATA_getTop();
   \   00000010   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000014   0060A0E1           MOV      R6,R0
    102            
    103            *socklasterr() = 0; 
   \   00000018   7C8100EF           SWI      +33148
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   001080E5           STR      R1,[R0, #+0]
    104            
    105            if (b->num == 0)
   \   00000024   1C0097E5           LDR      R0,[R7, #+28]
   \   00000028   000050E3           CMP      R0,#+0
    106              b->num = conn->sock;
   \   0000002C   4C009605           LDREQ    R0,[R6, #+76]
   \   00000030   1C008705           STREQ    R0,[R7, #+28]
    107            
    108            if (conn->ssl->bbio)
   \   00000034   900096E5           LDR      R0,[R6, #+144]
   \   00000038   141090E5           LDR      R1,[R0, #+20]
   \   0000003C   000051E3           CMP      R1,#+0
   \   00000040   0600000A           BEQ      ??bwrite_0
    109            {
    110              conn->ssl->bbio->method->bread = bread;
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   ........           LDR      R2,??DataTable12  ;; bread
   \   0000004C   0C2081E5           STR      R2,[R1, #+12]
    111              conn->ssl->bbio->method->bwrite = bwrite;
   \   00000050   140090E5           LDR      R0,[R0, #+20]
   \   00000054   ........           LDR      R1,??DataTable13  ;; bwrite
   \   00000058   000090E5           LDR      R0,[R0, #+0]
   \   0000005C   081080E5           STR      R1,[R0, #+8]
    112            }
    113            
    114            int send_res = send(/*b->num*/conn->sock, data, len, 0);//bio->num может быть пустым...
   \                     ??bwrite_0:
   \   00000060   4C0096E5           LDR      R0,[R6, #+76]
   \   00000064   0030A0E3           MOV      R3,#+0
   \   00000068   0520A0E1           MOV      R2,R5
   \   0000006C   0410A0E1           MOV      R1,R4
   \   00000070   790100EF           SWI      +377
   \   00000074   0040A0E1           MOV      R4,R0
    115            
    116            if (send_res == -1 && *socklasterr() == 0xC9)
   \   00000078   010074E3           CMN      R4,#+1
   \   0000007C   0400001A           BNE      ??bwrite_1
   \   00000080   7C8100EF           SWI      +33148
   \   00000084   000090E5           LDR      R0,[R0, #+0]
   \   00000088   C90050E3           CMP      R0,#+201
    117              return 0;
   \   0000008C   0000A003           MOVEQ    R0,#+0
   \   00000090   F080BD08           POPEQ    {R4-R7,PC}
    118            
    119            return send_res;
   \                     ??bwrite_1:
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   F080BDE8           POP      {R4-R7,PC}       ;; return
    120          }
    121          //******************************************************************************
    122          

   \                                 In segment CODE, align 4, keep-with-next
    123          void tmr_connect_timeout_handler()
    124          {
   \                     tmr_connect_timeout_handler:
   \   00000000   00402DE9           PUSH     {LR}
    125            end_ssl(CONNDATA_getTop());
   \   00000004   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000008   ........           BL       end_ssl
    126            if (sock_error_handler)
   \   0000000C   ........           LDR      R0,??DataTable17  ;; sock_error_handler
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    127              sock_error_handler(ERROR_SSL_CONNECT_TIMEOUT);
   \   0000001C   0A00A0E3           MOV      R0,#+10
   \   00000020   31FF2FE1           BLX      R1
    128          }
   \   00000024   0080BDE8           POP      {PC}             ;; return
    129          

   \                                 In segment CODE, align 4, keep-with-next
    130          void tmr_read_timeout_handler(/**/)
    131          {
   \                     tmr_read_timeout_handler:
   \   00000000   00402DE9           PUSH     {LR}
    132            end_ssl(CONNDATA_getTop());
   \   00000004   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000008   ........           BL       end_ssl
    133            if (sock_error_handler)
   \   0000000C   ........           LDR      R0,??DataTable17  ;; sock_error_handler
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    134              sock_error_handler(ERROR_READ_TIMEOUT);
   \   0000001C   0800A0E3           MOV      R0,#+8
   \   00000020   31FF2FE1           BLX      R1
    135          }
   \   00000024   0080BDE8           POP      {PC}             ;; return
    136          
    137          //******************************************************************************
    138          

   \                                 In segment CODE, align 4, keep-with-next
    139          void end_ssl(CONNDATA *conn)
    140          {
   \                     end_ssl:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    141            if (conn == NULL)
   \   00000008   1080BD08           POPEQ    {R4,PC}
    142              return;
    143            
    144            GBS_DelTimer(&conn->tmr_read);
   \   0000000C   800084E2           ADD      R0,R4,#+128
   \   00000010   8C0100EF           SWI      +396
    145            
    146            SSL_shutdown(conn->ssl);//Отправим серверу "close notify".Ожидать подтверждения конечно же не будем   
   \   00000014   900094E5           LDR      R0,[R4, #+144]
   \   00000018   9C0300EF           SWI      +924
    147            SSL_free(conn->ssl);
   \   0000001C   900094E5           LDR      R0,[R4, #+144]
   \   00000020   A00300EF           SWI      +928
    148            closesocket(conn->sock);
   \   00000024   4C0094E5           LDR      R0,[R4, #+76]
   \   00000028   760100EF           SWI      +374
    149            CONNDATA_free(conn);  
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           _BLF     CONNDATA_free,??CONNDATA_free??rA
    150          }
   \   00000034   1080BDE8           POP      {R4,PC}          ;; return
    151          

   \                                 In segment CODE, align 4, keep-with-next
    152          void end_ssl_work()
    153          {
   \                     end_ssl_work:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   000000EA           B        ??end_ssl_work_0
    154            CONNDATA *conn;
    155              
    156            while (conn=CONNDATA_getTop())
    157              end_ssl(conn);
   \                     ??end_ssl_work_1:
   \   00000008   ........           BL       end_ssl
   \                     ??end_ssl_work_0:
   \   0000000C   ........           _BLF     CONNDATA_getTop,??CONNDATA_getTop??rA
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   FBFFFF1A           BNE      ??end_ssl_work_1
    158          }
   \   00000018   0080BDE8           POP      {PC}             ;; return
    159          
    160          //******************************************************************************
    161          

   \                                 In segment CODE, align 4, keep-with-next
    162          static int ssl_get_answer(CONNDATA *conn)
    163          {
   \                     ssl_get_answer:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    164            char tmp_dat[4096];
    165            static int recv_size;
    166            
    167            if (recv_buf == NULL)
   \   00000004   D8609FE5           LDR      R6,??ssl_get_answer_0  ;; ??recv_size
   \   00000008   D8709FE5           LDR      R7,??ssl_get_answer_0+0x4  ;; recv_buf
   \   0000000C   40DD4DE2           SUB      SP,SP,#+4096
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   000097E5           LDR      R0,[R7, #+0]
    168              recv_size = 0;
    169                        
    170            int res = SSL_read(conn->ssl, tmp_dat, 4096);
   \   00000018   402DA0E3           MOV      R2,#+4096
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   00008605           STREQ    R0,[R6, #+0]
   \   00000024   900094E5           LDR      R0,[R4, #+144]
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   9D0300EF           SWI      +925
   \   00000030   0050A0E1           MOV      R5,R0
    171            
    172            if (res > 0)
   \   00000034   010055E3           CMP      R5,#+1
   \   00000038   140000BA           BLT      ??ssl_get_answer_1
    173            {
    174              recv_buf=realloc(recv_buf, recv_size+res);
   \   0000003C   000096E5           LDR      R0,[R6, #+0]
   \   00000040   001085E0           ADD      R1,R5,R0
   \   00000044   000097E5           LDR      R0,[R7, #+0]
   \   00000048   BA0000EF           SWI      +186
   \   0000004C   000087E5           STR      R0,[R7, #+0]
    175              memcpy(recv_buf+recv_size, tmp_dat, res);
   \   00000050   000096E5           LDR      R0,[R6, #+0]
   \   00000054   003097E5           LDR      R3,[R7, #+0]
   \   00000058   0520A0E1           MOV      R2,R5
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   030080E0           ADD      R0,R0,R3
   \   00000064   1E0100EF           SWI      +286
    176              recv_size+=res;
   \   00000068   000096E5           LDR      R0,[R6, #+0]
   \   0000006C   000085E0           ADD      R0,R5,R0
   \   00000070   000086E5           STR      R0,[R6, #+0]
    177              conn->TOTALRECEIVED+=res;
   \   00000074   6C0094E5           LDR      R0,[R4, #+108]
   \   00000078   000085E0           ADD      R0,R5,R0
   \   0000007C   6C0084E5           STR      R0,[R4, #+108]
    178              ALLTOTALRECEIVED+=res;
   \   00000080   64009FE5           LDR      R0,??ssl_get_answer_0+0x8  ;; ALLTOTALRECEIVED
   \   00000084   001090E5           LDR      R1,[R0, #+0]
   \   00000088   011085E0           ADD      R1,R5,R1
   \   0000008C   001080E5           STR      R1,[R0, #+0]
    179            } 
    180          
    181          #ifdef DEBUG
    182            sprintf(logmsg,"SSL_Read..\nlength: %d\nreceived: %d",HTTP_CONTENT_LENGTH,conn->TOTALRECEIVED-HTTP_HEADER_LENGTH);
   \                     ??ssl_get_answer_1:
   \   00000090   58109FE5           LDR      R1,??ssl_get_answer_0+0xC  ;; HTTP_HEADER_LENGTH
   \   00000094   6C0094E5           LDR      R0,[R4, #+108]
   \   00000098   001091E5           LDR      R1,[R1, #+0]
   \   0000009C   ........           LDR      R6,??DataTable15  ;; logmsg
   \   000000A0   4C709FE5           LDR      R7,??ssl_get_answer_0+0x10  ;; `?<Constant "SSL_read error!">`
   \   000000A4   013040E0           SUB      R3,R0,R1
   \   000000A8   48009FE5           LDR      R0,??ssl_get_answer_0+0x14  ;; HTTP_CONTENT_LENGTH
   \   000000AC   101087E2           ADD      R1,R7,#+16
   \   000000B0   002090E5           LDR      R2,[R0, #+0]
   \   000000B4   0600A0E1           MOV      R0,R6
   \   000000B8   160000EF           SWI      +22
    183            SMART_REDRAW();
   \   000000BC   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    184          #endif
    185            
    186          #ifdef DEBUG  
    187            if (res == -1)
   \   000000C0   010075E3           CMN      R5,#+1
   \   000000C4   0300001A           BNE      ??ssl_get_answer_2
    188            {
    189              sprintf(logmsg,"SSL_read error!"); 
   \   000000C8   0710A0E1           MOV      R1,R7
   \   000000CC   0600A0E1           MOV      R0,R6
   \   000000D0   160000EF           SWI      +22
    190              SMART_REDRAW();
   \   000000D4   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    191            }
    192          #endif
    193            
    194            return res;
   \                     ??ssl_get_answer_2:
   \   000000D8   0500A0E1           MOV      R0,R5
   \   000000DC   40DD8DE2           ADD      SP,SP,#+4096
   \   000000E0   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??ssl_get_answer_0:
   \   000000E4   ........           DC32     ??recv_size
   \   000000E8   ........           DC32     recv_buf
   \   000000EC   ........           DC32     ALLTOTALRECEIVED
   \   000000F0   ........           DC32     HTTP_HEADER_LENGTH
   \   000000F4   ........           DC32     `?<Constant "SSL_read error!">`
   \   000000F8   ........           DC32     HTTP_CONTENT_LENGTH
    195          }
    196          //******************************************************************************
    197          //

   \                                 In segment CODE, align 4, keep-with-next
    198          void ssl_send_answer(const char *url, char *buf, int len, int flag)
    199          {
   \                     ssl_send_answer:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    200            static CONNDATA *conn;
    201            static int send_q_size;
    202            
    203            if (url)//если первый вызов функции
   \   00000004   70419FE5           LDR      R4,??ssl_send_answer_0  ;; ??conn
   \   00000008   70519FE5           LDR      R5,??ssl_send_answer_0+0x4  ;; send_buf_len
   \   0000000C   70619FE5           LDR      R6,??ssl_send_answer_0+0x8  ;; send_buf
   \   00000010   0070A0E1           MOV      R7,R0
   \   00000014   0190A0E1           MOV      R9,R1
   \   00000018   02A0A0E1           MOV      R10,R2
   \   0000001C   0380A0E1           MOV      R8,R3
   \   00000020   000057E3           CMP      R7,#+0
   \   00000024   0E00000A           BEQ      ??ssl_send_answer_1
    204            {
    205              free_send_buf();
   \   00000028   ........           _BLF     free_send_buf,??free_send_buf??rA
    206              send_buf = buf;
   \   0000002C   009086E5           STR      R9,[R6, #+0]
    207              send_buf_len = len;
   \   00000030   00A085E5           STR      R10,[R5, #+0]
    208              send_q_size = len;
   \   00000034   04A084E5           STR      R10,[R4, #+4]
    209              free_recv_buf();
   \   00000038   ........           _BLF     free_recv_buf,??free_recv_buf??rA
    210          
    211              conn = CONNDATA_findByURL(url);
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           _BLF     CONNDATA_findByURL,??CONNDATA_findByURL??rA
   \   00000044   000084E5           STR      R0,[R4, #+0]
    212             
    213              if (conn && conn->ssl)//коннект активен(keep-alive)
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   90109015           LDRNE    R1,[R0, #+144]
   \   00000050   00005113           CMPNE    R1,#+0
   \   00000054   2C00000A           BEQ      ??ssl_send_answer_2
    214              {
    215                conn->TOTALSENDED=0;//сброс счетчиков
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   681080E5           STR      R1,[R0, #+104]
    216                conn->TOTALRECEIVED=0;
   \   00000060   6C1080E5           STR      R1,[R0, #+108]
    217              }
    218              
    219              else//если соединение не установлено
    220              {
    221                conn = CONNDATA_new(url, flag);
    222                connect_socket(conn);
    223                return;
    224              }
    225            }
    226            
    227           int res = SSL_write(conn->ssl, send_buf+(send_buf_len-send_q_size), send_buf_len);
   \                     ??ssl_send_answer_1:
   \   00000064   000095E5           LDR      R0,[R5, #+0]
   \   00000068   041094E5           LDR      R1,[R4, #+4]
   \   0000006C   0020A0E1           MOV      R2,R0
   \   00000070   010040E0           SUB      R0,R0,R1
   \   00000074   001096E5           LDR      R1,[R6, #+0]
   \   00000078   011080E0           ADD      R1,R0,R1
   \   0000007C   000094E5           LDR      R0,[R4, #+0]
   \   00000080   900090E5           LDR      R0,[R0, #+144]
   \   00000084   9F0300EF           SWI      +927
    228           
    229           conn->recv_mode = 1;
   \   00000088   001094E5           LDR      R1,[R4, #+0]
   \   0000008C   0120A0E3           MOV      R2,#+1
   \   00000090   582081E5           STR      R2,[R1, #+88]
    230             
    231            if (res !=-1)
   \   00000094   002062E2           RSB      R2,R2,#+0
   \   00000098   020050E1           CMP      R0,R2
   \   0000009C   0900000A           BEQ      ??ssl_send_answer_3
    232            {
    233              send_q_size -= res;
   \   000000A0   043094E5           LDR      R3,[R4, #+4]
   \   000000A4   003043E0           SUB      R3,R3,R0
   \   000000A8   043084E5           STR      R3,[R4, #+4]
    234              conn->TOTALSENDED += res;
   \   000000AC   683091E5           LDR      R3,[R1, #+104]
   \   000000B0   033080E0           ADD      R3,R0,R3
   \   000000B4   683081E5           STR      R3,[R1, #+104]
    235              ALLTOTALSENDED += res;
   \   000000B8   C8309FE5           LDR      R3,??ssl_send_answer_0+0xC  ;; ALLTOTALSENDED
   \   000000BC   005093E5           LDR      R5,[R3, #+0]
   \   000000C0   055080E0           ADD      R5,R0,R5
   \   000000C4   005083E5           STR      R5,[R3, #+0]
    236            }
    237            
    238            if (res > 0)
   \                     ??ssl_send_answer_3:
   \   000000C8   ........           LDR      R5,??DataTable15  ;; logmsg
   \   000000CC   B8609FE5           LDR      R6,??ssl_send_answer_0+0x10  ;; `?<Constant "SSL_write Ok">`
   \   000000D0   010050E3           CMP      R0,#+1
   \   000000D4   120000BA           BLT      ??ssl_send_answer_4
    239            {
    240              if (send_q_size)//послали меньше чем заказывали
   \   000000D8   040094E5           LDR      R0,[R4, #+4]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   F087BD18           POPNE    {R4-R10,PC}
    241              {
    242          #ifdef DEVELOP
    243              ShowMSG(1,(int)"send_q_size");
    244          #endif
    245                  return;//ожидаем сообщения ENIP_BUFFER_FREE???
    246              }
    247              
    248              //free_recv_buf();нафига это здесь?
    249              GBS_DelTimer(&conn->tmr_read);
   \   000000E4   800081E2           ADD      R0,R1,#+128
   \   000000E8   8C0100EF           SWI      +396
    250              GBS_StartTimerProc(&conn->tmr_read, 216* 30 , tmr_read_timeout_handler);
   \   000000EC   000094E5           LDR      R0,[R4, #+0]
   \   000000F0   ........           LDR      R2,??DataTable18  ;; tmr_read_timeout_handler
   \   000000F4   5010A0E3           MOV      R1,#+80
   \   000000F8   641D81E3           ORR      R1,R1,#0x1900
   \   000000FC   800080E2           ADD      R0,R0,#+128
   \   00000100   4D0000EF           SWI      +77
    251              
    252          #ifdef DEBUG      
    253              sprintf(logmsg,"SSL_write Ok");
   \   00000104   0610A0E1           MOV      R1,R6
   \   00000108   0F0000EA           B        ??ssl_send_answer_5
    254              SMART_REDRAW();
    255          #endif
    256              
    257              return;
    258            }
   \                     ??ssl_send_answer_2:
   \   0000010C   0810A0E1           MOV      R1,R8
   \   00000110   0700A0E1           MOV      R0,R7
   \   00000114   ........           _BLF     CONNDATA_new,??CONNDATA_new??rA
   \   00000118   000084E5           STR      R0,[R4, #+0]
   \   0000011C   ........           _BLF     connect_socket,??connect_socket??rA
   \   00000120   F087BDE8           POP      {R4-R10,PC}
    259            
    260            if (res ==0)//...? 
   \                     ??ssl_send_answer_4:
   \   00000124   ........           LDR      R4,??DataTable17  ;; sock_error_handler
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   0A00001A           BNE      ??ssl_send_answer_6
    261            {
    262              //end_ssl_last();
    263              sock_error_handler(ERROR_WRITE);
   \   00000130   001094E5           LDR      R1,[R4, #+0]
   \   00000134   0600A0E3           MOV      R0,#+6
   \   00000138   31FF2FE1           BLX      R1
    264              
    265          #ifdef DEBUG
    266              ShowMSG(1,(int)"SSL write==0");
   \   0000013C   101086E2           ADD      R1,R6,#+16
   \   00000140   0100A0E3           MOV      R0,#+1
   \   00000144   480100EF           SWI      +328
    267              sprintf(logmsg,"ssl_write==0");
   \   00000148   201086E2           ADD      R1,R6,#+32
   \                     ??ssl_send_answer_5:
   \   0000014C   0500A0E1           MOV      R0,R5
   \   00000150   160000EF           SWI      +22
    268              SMART_REDRAW();
   \   00000154   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    269          #endif
    270              
    271              return;
   \   00000158   F087BDE8           POP      {R4-R10,PC}
    272            } 
    273            
    274            if(res ==-1)
   \                     ??ssl_send_answer_6:
   \   0000015C   020050E1           CMP      R0,R2
   \   00000160   F087BD18           POPNE    {R4-R10,PC}
    275            {
    276              end_ssl(conn);
   \   00000164   0100A0E1           MOV      R0,R1
   \   00000168   ........           BL       end_ssl
    277              sock_error_handler(ERROR_WRITE);
   \   0000016C   001094E5           LDR      R1,[R4, #+0]
   \   00000170   0600A0E3           MOV      R0,#+6
   \   00000174   31FF2FE1           BLX      R1
    278              return;
   \   00000178   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_send_answer_0:
   \   0000017C   ........           DC32     ??conn
   \   00000180   ........           DC32     send_buf_len
   \   00000184   ........           DC32     send_buf
   \   00000188   ........           DC32     ALLTOTALSENDED
   \   0000018C   ........           DC32     `?<Constant "SSL_write Ok">`
    279            }
    280          }
    281          
    282          //******************************************************************************
    283          /*
    284          static int verify_callback(int mode, X509_STORE_CTX *ctx)
    285          {
    286            return 0;
    287          }
    288          */
    289          //****************************************************************************
    290          
    291          //Вызывается после создания новой сессии

   \                                 In segment CODE, align 4, keep-with-next
    292          static int new_session(SSL *ssl, SSL_SESSION *new_session)
    293          {
   \                     new_session:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    294            CONNDATA *conn = CONNDATA_findBySSL(ssl);
   \   00000008   ........           _BLF     CONNDATA_findBySSL,??CONNDATA_findBySSL??rA
    295            
    296            if (conn)
    297              conn->ssl_sess = new_session;
    298            
    299          #ifdef DEBUG
    300            sprintf(logmsg,"SSL new session");
   \   0000000C   18109FE5           LDR      R1,??new_session_0  ;; `?<Constant "SSL new session">`
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   98408015           STRNE    R4,[R0, #+152]
   \   00000018   ........           LDR      R0,??DataTable15  ;; logmsg
   \   0000001C   160000EF           SWI      +22
    301            SMART_REDRAW();
   \   00000020   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    302          #endif  
    303            //else ERROR;   
    304            //TOTALNEWSSLSESSIONS++;
    305          
    306            return(1);
   \   00000024   0100A0E3           MOV      R0,#+1
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??new_session_0:
   \   0000002C   ........           DC32     `?<Constant "SSL new session">`
    307          }
    308          

   \                                 In segment CODE, align 4, keep-with-next
    309          static void remove_session(SSL_CTX *ctx, SSL_SESSION *sess)
    310          {//Вызваетя в случае если сессия удаляется из кэша по причине истечения таймаута или некорректного завершения
   \                     remove_session:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0100A0E1           MOV      R0,R1
    311            
    312            CONNDATA *conn;
    313            
    314            sess->references = 1;  //сессия больше не нужна
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   9C1080E5           STR      R1,[R0, #+156]
    315            
    316            if (conn = CONNDATA_findBySession(sess))//ищем соединение по сессии
   \   00000010   ........           _BLF     CONNDATA_findBySession,??CONNDATA_findBySession??rA
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0080BD08           POPEQ    {PC}
    317            {
    318              conn->ssl_sess = NULL; 
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   981080E5           STR      R1,[R0, #+152]
    319              
    320          #ifdef DEBUG
    321              sprintf(logmsg,"SSL session remove: %s",conn->hostname);
   \   00000024   0C109FE5           LDR      R1,??remove_session_0  ;; `?<Constant "SSL session remove: %s">`
   \   00000028   0C2080E2           ADD      R2,R0,#+12
   \   0000002C   ........           LDR      R0,??DataTable15  ;; logmsg
   \   00000030   160000EF           SWI      +22
    322              //ShowMSG(1,(int)"Session Remove");//как будто, если вызвать ShowMSG при AnimWidget то краш обеспечен
    323          #endif    
    324            } 
    325          }
   \   00000034   0080BDE8           POP      {PC}             ;; return
   \                     ??remove_session_0:
   \   00000038   ........           DC32     `?<Constant "SSL session remove: %s">`
    326          
    327          //******************************************************************************
    328          /*
    329          //ищем в кэше нужную сессию(при работе с внутренним кэшем)
    330          static SSL_SESSION *get_session(SSL* ssl, unsigned char *data, int len, int *copy)
    331          {
    332          //Не разобрался еще..
    333            return 0;
    334          }
    335          */
    336          //******************************************************************************
    337           

   \                                 In segment CODE, align 4, keep-with-next
    338          static int ssl_connect(int sock)
    339          {
   \                     ssl_connect:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    340            static int __sock;
    341           
    342            if (sock)
   \   00000004   4C919FE5           LDR      R9,??ssl_connect_0  ;; ctx
    343              __sock = sock;
    344            
    345            CONNDATA *conn = CONNDATA_findBySock(__sock);
    346            
    347          #ifdef DEBUG
    348            sprintf(logmsg,"SSL connect...");
   \   00000008   ........           LDR      R6,??DataTable15  ;; logmsg
   \   0000000C   48719FE5           LDR      R7,??ssl_connect_0+0x4  ;; `?<Constant "SSL connect...">`
   \   00000010   0040B0E1           MOVS     R4,R0
   \   00000014   04408915           STRNE    R4,[R9, #+4]
   \   00000018   040099E5           LDR      R0,[R9, #+4]
    349            SMART_REDRAW();
    350          #endif
    351           
    352            if (sock)
   \   0000001C   0080E0E3           MVN      R8,#+0
   \   00000020   ........           _BLF     CONNDATA_findBySock,??CONNDATA_findBySock??rA
   \   00000024   0050A0E1           MOV      R5,R0
   \   00000028   0710A0E1           MOV      R1,R7
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   160000EF           SWI      +22
   \   00000034   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
   \   00000038   000054E3           CMP      R4,#+0
   \   0000003C   2E00000A           BEQ      ??ssl_connect_1
    353            {
    354              conn->ssl_state = -1;
   \   00000040   948085E5           STR      R8,[R5, #+148]
    355              
    356              if (!ctx)
   \   00000044   000099E5           LDR      R0,[R9, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0C00001A           BNE      ??ssl_connect_2
    357              {    
    358                ctx = SSL_CTX_new(TLSv1_client_method());
   \   00000050   950300EF           SWI      +917
   \   00000054   960300EF           SWI      +918
   \   00000058   000089E5           STR      R0,[R9, #+0]
    359                
    360                //Расширение: добавляем  шифры в cipher_list
    361                //sk_push((STACK*)ctx->cipher_list, (char*)&cipher_2F);
    362                //sk_push((STACK*)ctx->cipher_list_by_id, (char*)&cipher_2F);
    363                
    364                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL_LOOKUP, 0);//запрещаем внутренний кэш сессий(не знаю как корректно с ним работать)
   \   0000005C   0030A0E3           MOV      R3,#+0
   \   00000060   0120A0E3           MOV      R2,#+1
   \   00000064   402F82E3           ORR      R2,R2,#0x100
   \   00000068   2C10A0E3           MOV      R1,#+44
   \   0000006C   980300EF           SWI      +920
    365                //ssl_ctx_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, 5, 0);
    366                SSL_CTX_sess_set_new_cb(ctx, new_session);
   \   00000070   000099E5           LDR      R0,[R9, #+0]
   \   00000074   E4109FE5           LDR      R1,??ssl_connect_0+0x8  ;; new_session
   \   00000078   301080E5           STR      R1,[R0, #+48]
    367                SSL_CTX_sess_set_remove_cb(ctx, remove_session);
   \   0000007C   E0109FE5           LDR      R1,??ssl_connect_0+0xC  ;; remove_session
   \   00000080   341080E5           STR      R1,[R0, #+52]
    368                //SSL_CTX_sess_set_get_cb(ctx, get_session);
    369              }   
    370              
    371              SSL *ssl = SSL_new(ctx);  
   \                     ??ssl_connect_2:
   \   00000084   000099E5           LDR      R0,[R9, #+0]
   \   00000088   990300EF           SWI      +921
   \   0000008C   0090A0E1           MOV      R9,R0
    372              conn->ssl = ssl;
   \   00000090   909085E5           STR      R9,[R5, #+144]
    373              
    374              //Расширение: метод get_cipher_by_char меняем на свой/
    375              //get_cipher_by_char_old=ssl->method->get_cipher_by_char;
    376              //ssl->method->get_cipher_by_char = get_cipher_by_char_new;
    377                 
    378                if (conn->ssl_sess)
   \   00000094   981095E5           LDR      R1,[R5, #+152]
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0C00000A           BEQ      ??ssl_connect_3
    379                {
    380                  if (conn->ssl_sess->not_resumable)//на всякий случай
   \   000000A0   8C0091E5           LDR      R0,[R1, #+140]
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0500000A           BEQ      ??ssl_connect_4
    381                  {
    382                    conn->ssl_sess->references = 0;
   \   000000AC   00A0A0E3           MOV      R10,#+0
   \   000000B0   9CA081E5           STR      R10,[R1, #+156]
    383                    SSL_SESSION_free(conn->ssl_sess);
   \   000000B4   0100A0E1           MOV      R0,R1
   \   000000B8   A20300EF           SWI      +930
    384                    conn->ssl_sess = NULL;
   \   000000BC   98A085E5           STR      R10,[R5, #+152]
   \   000000C0   030000EA           B        ??ssl_connect_3
    385                  }
    386                  else
    387                  {     
    388                    conn->ssl_sess->references = 2;//если 1я-сессия удаляется.Хз почему...
   \                     ??ssl_connect_4:
   \   000000C4   0200A0E3           MOV      R0,#+2
   \   000000C8   9C0081E5           STR      R0,[R1, #+156]
    389                    SSL_set_session(ssl, conn->ssl_sess);
   \   000000CC   0900A0E1           MOV      R0,R9
   \   000000D0   A10300EF           SWI      +929
    390                  }
    391                }
    392              
    393              SSL_set_fd(ssl, sock);
   \                     ??ssl_connect_3:
   \   000000D4   0410A0E1           MOV      R1,R4
   \   000000D8   0900A0E1           MOV      R0,R9
   \   000000DC   9A0300EF           SWI      +922
    394              
    395              ssl->rbio->method->bread = bread;
   \   000000E0   0C0099E5           LDR      R0,[R9, #+12]
   \   000000E4   ........           LDR      R2,??DataTable12  ;; bread
   \   000000E8   001090E5           LDR      R1,[R0, #+0]
   \   000000EC   0C2081E5           STR      R2,[R1, #+12]
    396              ssl->rbio->method->bwrite = bwrite;    
   \   000000F0   000090E5           LDR      R0,[R0, #+0]
   \   000000F4   ........           LDR      R1,??DataTable13  ;; bwrite
   \   000000F8   081080E5           STR      R1,[R0, #+8]
    397            }
    398            
    399            conn->ssl_state = SSL_connect(conn->ssl);
   \                     ??ssl_connect_1:
   \   000000FC   900095E5           LDR      R0,[R5, #+144]
   \   00000100   9B0300EF           SWI      +923
   \   00000104   940085E5           STR      R0,[R5, #+148]
    400            
    401            if (conn->ssl_state == -1)//error
   \   00000108   080050E1           CMP      R0,R8
   \   0000010C   0900001A           BNE      ??ssl_connect_5
    402            {
    403              end_ssl(conn);
   \   00000110   0500A0E1           MOV      R0,R5
   \   00000114   ........           BL       end_ssl
    404              
    405              sock_error_handler(ERROR_SSL_CONNECTION);
   \   00000118   ........           LDR      R1,??DataTable17  ;; sock_error_handler
   \   0000011C   0900A0E3           MOV      R0,#+9
   \   00000120   001091E5           LDR      R1,[R1, #+0]
   \   00000124   31FF2FE1           BLX      R1
    406          #ifdef DEBUG    
    407              sprintf(logmsg, "SSL_connect Error!");
   \   00000128   101087E2           ADD      R1,R7,#+16
   \   0000012C   0600A0E1           MOV      R0,R6
   \   00000130   160000EF           SWI      +22
    408              SMART_REDRAW();
   \   00000134   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    409          #endif
    410            }
    411            
    412          #ifdef DEBUG  
    413            if (conn->ssl_state == 1)//ok
   \                     ??ssl_connect_5:
   \   00000138   940095E5           LDR      R0,[R5, #+148]
   \   0000013C   010050E3           CMP      R0,#+1
   \   00000140   0200001A           BNE      ??ssl_connect_6
    414              sprintf(logmsg,"SSL_connect Ok!");
   \   00000144   241087E2           ADD      R1,R7,#+36
   \   00000148   0600A0E1           MOV      R0,R6
   \   0000014C   160000EF           SWI      +22
    415          #endif
    416            return conn->ssl_state;
   \                     ??ssl_connect_6:
   \   00000150   940095E5           LDR      R0,[R5, #+148]
   \   00000154   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_connect_0:
   \   00000158   ........           DC32     ctx
   \   0000015C   ........           DC32     `?<Constant "SSL connect...">`
   \   00000160   ........           DC32     new_session
   \   00000164   ........           DC32     remove_session
    417          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ctx:
   \   00000000                      DS8 4
   \   00000004                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??recv_size:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??conn:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
    418          
    419          //******************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    420          void ssl_socket_msg_handler(GBS_MSG* msg)
    421          {
   \                     ssl_socket_msg_handler:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    422            CONNDATA *conn;
    423            
    424            switch((int)msg->data0)
   \   00000004   ........           LDR      R6,??DataTable15  ;; logmsg
   \   00000008   00729FE5           LDR      R7,??ssl_socket_msg_handler_1  ;; `?<Constant "buffer free!!!">`
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0C1095E5           LDR      R1,[R5, #+12]
   \   00000014   F8019FE5           LDR      R0,??ssl_socket_msg_handler_1+0x4  ;; is_gprs_online
   \   00000018   0180A0E3           MOV      R8,#+1
   \   0000001C   0040A0E3           MOV      R4,#+0
   \   00000020   801051E2           SUBS     R1,R1,#+128
   \   00000024   0B00000A           BEQ      ??ssl_socket_msg_handler_2
   \   00000028   021051E2           SUBS     R1,R1,#+2
   \   0000002C   0200000A           BEQ      ??ssl_socket_msg_handler_3
   \   00000030   121051E2           SUBS     R1,R1,#+18
   \   00000034   2C00000A           BEQ      ??ssl_socket_msg_handler_4
   \   00000038   140000EA           B        ??ssl_socket_msg_handler_5
    425            {
    426          //------------------------------------------------------------------------------    
    427            case LMAN_DISCONNECT_IND:
    428              is_gprs_online=0;
    429              sock_error_handler(GPRS_OFFLINE);
   \                     ??ssl_socket_msg_handler_3:
   \   0000003C   ........           LDR      R1,??DataTable17  ;; sock_error_handler
   \   00000040   004080E5           STR      R4,[R0, #+0]
   \   00000044   001091E5           LDR      R1,[R1, #+0]
   \   00000048   0400A0E3           MOV      R0,#+4
   \   0000004C   31FF2FE1           BLX      R1
    430              
    431          #ifdef DEBUG      
    432              sprintf(logmsg,"GPRS offline...");
   \   00000050   3C1087E2           ADD      R1,R7,#+60
   \   00000054   590000EA           B        ??ssl_socket_msg_handler_6
    433              SMART_REDRAW();
    434          #endif    
    435              return;
    436          //------------------------------------------------------------------------------  
    437            case LMAN_CONNECT_CNF:
    438              //start_vibra(VIBR_ON_CONNECT);
    439              is_gprs_online=1;
    440              sock_error_handler(GPRS_ONLINE);
   \                     ??ssl_socket_msg_handler_2:
   \   00000058   ........           LDR      R1,??DataTable17  ;; sock_error_handler
   \   0000005C   008080E5           STR      R8,[R0, #+0]
   \   00000060   001091E5           LDR      R1,[R1, #+0]
   \   00000064   0500A0E3           MOV      R0,#+5
   \   00000068   31FF2FE1           BLX      R1
    441                if (!disautorecconect)
   \   0000006C   A4019FE5           LDR      R0,??ssl_socket_msg_handler_1+0x8  ;; disautorecconect
   \   00000070   000090E5           LDR      R0,[R0, #+0]
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   0400001A           BNE      ??ssl_socket_msg_handler_5
    442                {
    443          #ifdef DEBUG          
    444                  sprintf(logmsg,"GPRS online");
   \   0000007C   4C1087E2           ADD      R1,R7,#+76
   \   00000080   0600A0E1           MOV      R0,R6
   \   00000084   160000EF           SWI      +22
    445                  SMART_REDRAW();
   \   00000088   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    446          #endif
    447                  reconnect();
   \   0000008C   ........           _BLF     reconnect,??reconnect??rA
    448                }
    449              break; 
    450          //------------------------------------------------------------------------------  
    451            case ENIP_DNR_HOST_BY_NAME:
    452              
    453              conn=CONNDATA_findByDNR((int)msg->data1);
    454              
    455              if (conn && conn->DNR_TRIES)
    456                connect_socket(NULL);
    457              
    458              return;
    459            }
    460          //------------------------------------------------------------------------------
    461          
    462            if (conn=CONNDATA_findBySock((int)msg->data1))//если наш сокет
   \                     ??ssl_socket_msg_handler_5:
   \   00000090   100095E5           LDR      R0,[R5, #+16]
   \   00000094   ........           _BLF     CONNDATA_findBySock,??CONNDATA_findBySock??rA
   \   00000098   00A0B0E1           MOVS     R10,R0
   \   0000009C   F087BD08           POPEQ    {R4-R10,PC}
    463            {
    464              switch((int)msg->data0)
   \   000000A0   0C0095E5           LDR      R0,[R5, #+12]
   \   000000A4   5090A0E3           MOV      R9,#+80
   \   000000A8   649D89E3           ORR      R9,R9,#0x1900
   \   000000AC   8A0040E2           SUB      R0,R0,#+138
   \   000000B0   050050E3           CMP      R0,#+5
   \   000000B4   F087BD88           POPHI    {R4-R10,PC}
   \   000000B8   011F8FE2           ADR      R1,??ssl_socket_msg_handler_0
   \   000000BC   0010D1E7           LDRB     R1,[R1, R0]
   \   000000C0   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??ssl_socket_msg_handler_0:
   \   000000C4   3A3A1201           DC8      +58,+58,+18,+1
   \   000000C8   51420000           DC8      +81,+66,+0,+0
    465              {
    466              case ENIP_SOCK_CONNECTED:
    467                conn->sock_state=1;
   \                     ??ssl_socket_msg_handler_7:
   \   000000CC   54808AE5           STR      R8,[R10, #+84]
    468                ssl_connect(conn->sock);       
   \   000000D0   4C009AE5           LDR      R0,[R10, #+76]
   \   000000D4   ........           BL       ssl_connect
    469                GBS_StartTimerProc(&conn->tmr_connect, 216* 30 , tmr_connect_timeout_handler);
   \   000000D8   3C219FE5           LDR      R2,??ssl_socket_msg_handler_1+0xC  ;; tmr_connect_timeout_handler
   \   000000DC   0910A0E1           MOV      R1,R9
   \   000000E0   70008AE2           ADD      R0,R10,#+112
   \   000000E4   4D0000EF           SWI      +77
   \   000000E8   F087BDE8           POP      {R4-R10,PC}
   \                     ??ssl_socket_msg_handler_4:
   \   000000EC   100095E5           LDR      R0,[R5, #+16]
   \   000000F0   ........           _BLF     CONNDATA_findByDNR,??CONNDATA_findByDNR??rA
   \   000000F4   00A0B0E1           MOVS     R10,R0
   \   000000F8   60009015           LDRNE    R0,[R0, #+96]
   \   000000FC   00005013           CMPNE    R0,#+0
   \   00000100   F087BD08           POPEQ    {R4-R10,PC}
   \   00000104   0000A0E3           MOV      R0,#+0
   \   00000108   ........           _BLF     connect_socket,??connect_socket??rA
   \   0000010C   F087BDE8           POP      {R4-R10,PC}
    470                break;
    471          //------------------------------------------------------------------------------
    472              case ENIP_SOCK_DATA_READ:
    473                
    474                  if (conn->ssl_state == 0)//если в процессе хэндшейка
   \                     ??ssl_socket_msg_handler_8:
   \   00000110   94009AE5           LDR      R0,[R10, #+148]
   \   00000114   000050E3           CMP      R0,#+0
   \   00000118   0B00001A           BNE      ??ssl_socket_msg_handler_9
    475                  {
    476                    ssl_connect(0);//повторно вызываем 
   \   0000011C   ........           BL       ssl_connect
    477                    
    478                    if (conn->ssl_state == 1)//SSL соединение установлено
   \   00000120   94009AE5           LDR      R0,[R10, #+148]
   \   00000124   010050E3           CMP      R0,#+1
   \   00000128   F087BD18           POPNE    {R4-R10,PC}
    479                    {
    480                      GBS_DelTimer(&conn->tmr_connect);
   \   0000012C   70008AE2           ADD      R0,R10,#+112
   \   00000130   8C0100EF           SWI      +396
    481                      ssl_send_answer(0, 0, 0, 0);//возобновляем передачу данных
   \   00000134   0030A0E3           MOV      R3,#+0
   \   00000138   0320A0E1           MOV      R2,R3
   \   0000013C   0210A0E1           MOV      R1,R2
   \   00000140   0100A0E1           MOV      R0,R1
   \   00000144   ........           BL       ssl_send_answer
   \   00000148   F087BDE8           POP      {R4-R10,PC}
    482                    }
    483                    return;
    484                  }
    485                
    486                if (conn->ssl_state == 1 && conn->recv_mode == 1 )////если посылали send
   \                     ??ssl_socket_msg_handler_9:
   \   0000014C   010050E3           CMP      R0,#+1
   \   00000150   58009A05           LDREQ    R0,[R10, #+88]
   \   00000154   01005003           CMPEQ    R0,#+1
   \   00000158   F087BD18           POPNE    {R4-R10,PC}
    487                {
    488                  if (ssl_get_answer(conn) > 0)//если есть данные
   \   0000015C   0A00A0E1           MOV      R0,R10
   \   00000160   ........           BL       ssl_get_answer
   \   00000164   010050E3           CMP      R0,#+1
   \   00000168   F087BDB8           POPLT    {R4-R10,PC}
    489                    {
    490                      if (sock_data_read_handler(conn))//все данные получены
   \   0000016C   AC109FE5           LDR      R1,??ssl_socket_msg_handler_1+0x10  ;; sock_data_read_handler
   \   00000170   0A00A0E1           MOV      R0,R10
   \   00000174   001091E5           LDR      R1,[R1, #+0]
   \   00000178   31FF2FE1           BLX      R1
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   0300000A           BEQ      ??ssl_socket_msg_handler_10
    491                      {
    492                        conn->recv_mode = 0;
   \   00000184   58408AE5           STR      R4,[R10, #+88]
    493                        GBS_DelTimer(&conn->tmr_read);
   \   00000188   80008AE2           ADD      R0,R10,#+128
   \   0000018C   8C0100EF           SWI      +396
    494          #ifdef DEBUG
    495                       // sprintf(logmsg,"SSL_Read OK");
    496                       // SMART_REDRAW();
    497          #endif
    498                      return;
   \   00000190   F087BDE8           POP      {R4-R10,PC}
    499                      }
    500                      GBS_DelTimer(&conn->tmr_read);
   \                     ??ssl_socket_msg_handler_10:
   \   00000194   80008AE2           ADD      R0,R10,#+128
   \   00000198   8C0100EF           SWI      +396
    501                      GBS_StartTimerProc(&conn->tmr_read, 216* 30 , tmr_read_timeout_handler);
   \   0000019C   ........           LDR      R2,??DataTable18  ;; tmr_read_timeout_handler
   \   000001A0   0910A0E1           MOV      R1,R9
   \   000001A4   80008AE2           ADD      R0,R10,#+128
   \   000001A8   4D0000EF           SWI      +77
   \   000001AC   F087BDE8           POP      {R4-R10,PC}
    502                    }
    503                }
    504                break;
    505          //------------------------------------------------------------------------------
    506              case ENIP_BUFFER_FREE://Досылаем очередь
    507              case ENIP_BUFFER_FREE1:     
    508                //ssl_send_answer(0, 0, 0); 
    509          #ifdef DEBUG
    510                ShowMSG(1, (int)"buffer free!!!");
   \                     ??ssl_socket_msg_handler_11:
   \   000001B0   0710A0E1           MOV      R1,R7
   \   000001B4   0100A0E3           MOV      R0,#+1
   \   000001B8   480100EF           SWI      +328
    511                sprintf(logmsg,"ENIP_BUFFER_FREE");
   \   000001BC   101087E2           ADD      R1,R7,#+16
   \                     ??ssl_socket_msg_handler_6:
   \   000001C0   0600A0E1           MOV      R0,R6
   \   000001C4   160000EF           SWI      +22
    512                SMART_REDRAW();
   \   000001C8   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
   \   000001CC   F087BDE8           POP      {R4-R10,PC}
    513          #endif
    514                break;
    515          //------------------------------------------------------------------------------
    516              case ENIP_SOCK_REMOTE_CLOSED://Закрыт со стороны сервера
    517          #ifdef DEBUG
    518                sprintf(logmsg,"Сервер %s закрыл соед.", conn->hostname);
   \                     ??ssl_socket_msg_handler_12:
   \   000001D0   0C208AE2           ADD      R2,R10,#+12
   \   000001D4   241087E2           ADD      R1,R7,#+36
   \   000001D8   0600A0E1           MOV      R0,R6
   \   000001DC   160000EF           SWI      +22
    519                SMART_REDRAW();
   \   000001E0   ........           _BLF     SMART_REDRAW,??SMART_REDRAW??rA
    520          #endif
    521                GBS_DelTimer(&conn->tmr_read); 
   \   000001E4   80008AE2           ADD      R0,R10,#+128
   \   000001E8   8C0100EF           SWI      +396
    522                sock_remote_closed_handler(conn->sock);
   \   000001EC   4C009AE5           LDR      R0,[R10, #+76]
   \   000001F0   2C109FE5           LDR      R1,??ssl_socket_msg_handler_1+0x14  ;; sock_remote_closed_handler
   \   000001F4   0008A0E1           MOV      R0,R0, LSL #+16
   \   000001F8   001091E5           LDR      R1,[R1, #+0]
   \   000001FC   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000200   31FF2FE1           BLX      R1
    523                end_ssl(conn);
   \   00000204   0A00A0E1           MOV      R0,R10
   \   00000208   ........           BL       end_ssl
   \                     ??ssl_socket_msg_handler_13:
   \   0000020C   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??ssl_socket_msg_handler_1:
   \   00000210   ........           DC32     `?<Constant "buffer free!!!">`
   \   00000214   ........           DC32     is_gprs_online
   \   00000218   ........           DC32     disautorecconect
   \   0000021C   ........           DC32     tmr_connect_timeout_handler
   \   00000220   ........           DC32     sock_data_read_handler
   \   00000224   ........           DC32     sock_remote_closed_handler
    524                break;
    525          //------------------------------------------------------------------------------
    526              case ENIP_SOCK_CLOSED:
    527                //Закрыт вызовом closesocket
    528                //sprintf(logmsg,"Соединение закрыто вызовом closesocket");
    529                break;
    530              }
    531            }
    532          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     bread

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     bwrite

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     logmsg

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     sock_error_handler

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   ........           DC32     tmr_read_timeout_handler

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for SSL_MAX_SESS_COUNT>`:
   \   00000000   01000000           DC32 1

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL_read error!">`:
   \   00000000   53534C5F7265       DC8 "SSL_read error!"
   \              616420657272
   \              6F722100    
   \   00000010   53534C5F5265       DC8 "SSL_Read..\012length: %d\012received: %d"
   \              61642E2E0A6C
   \              656E6774683A
   \              2025640A7265
   \              636569766564
   \              3A20256400  
   \   00000033   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "buffer free!!!">`:
   \   00000000   627566666572       DC8 "buffer free!!!"
   \              206672656521
   \              212100      
   \   0000000F   00                 DC8 0
   \   00000010   454E49505F42       DC8 "ENIP_BUFFER_FREE"
   \              55464645525F
   \              4652454500  
   \   00000021   000000             DC8 0, 0, 0
   \   00000024   D1E5F0E2E5F0       DC8 "\321\345\360\342\345\360 %s \347\340\352\360\373\353 \361\356\345\344."
   \              20257320E7E0
   \              EAF0FBEB20F1
   \              EEE5E42E00  
   \   0000003B   00                 DC8 0
   \   0000003C   47505253206F       DC8 "GPRS offline..."
   \              66666C696E65
   \              2E2E2E00    
   \   0000004C   47505253206F       DC8 "GPRS online"
   \              6E6C696E6500

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "close_notify">`:
   \   00000000   636C6F73655F       DC8 "close_notify"
   \              6E6F74696679
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   756E65787065       DC8 "unexpected_message"
   \              637465645F6D
   \              657373616765
   \              00          
   \   00000023   00                 DC8 0
   \   00000024   6261645F7265       DC8 "bad_record_mac"
   \              636F72645F6D
   \              616300      
   \   00000033   00                 DC8 0
   \   00000034   6465636F6D70       DC8 "decompression_failure"
   \              72657373696F
   \              6E5F6661696C
   \              75726500    
   \   0000004A   0000               DC8 0, 0
   \   0000004C   68616E647368       DC8 "handshake_failure"
   \              616B655F6661
   \              696C75726500
   \   0000005E   0000               DC8 0, 0
   \   00000060   6E6F5F636572       DC8 "no_certificate"
   \              746966696361
   \              746500      
   \   0000006F   00                 DC8 0
   \   00000070   6261645F6365       DC8 "bad_certificate"
   \              727469666963
   \              61746500    
   \   00000080   756E73757070       DC8 "unsupported_certificate"
   \              6F727465645F
   \              636572746966
   \              696361746500
   \   00000098   636572746966       DC8 "certificate_revoked"
   \              69636174655F
   \              7265766F6B65
   \              6400        
   \   000000AC   636572746966       DC8 "certificate_expired"
   \              69636174655F
   \              657870697265
   \              6400        
   \   000000C0   636572746966       DC8 "certificate_unknown"
   \              69636174655F
   \              756E6B6E6F77
   \              6E00        
   \   000000D4   696C6C656761       DC8 "illegal_parameter"
   \              6C5F70617261
   \              6D6574657200
   \   000000E6   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL_write Ok">`:
   \   00000000   53534C5F7772       DC8 "SSL_write Ok"
   \              697465204F6B
   \              00          
   \   0000000D   000000             DC8 0, 0, 0
   \   00000010   53534C207772       DC8 "SSL write==0"
   \              6974653D3D30
   \              00          
   \   0000001D   000000             DC8 0, 0, 0
   \   00000020   73736C5F7772       DC8 "ssl_write==0"
   \              6974653D3D30
   \              00          
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL new session">`:
   \   00000000   53534C206E65       DC8 "SSL new session"
   \              772073657373
   \              696F6E00    

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL session remove: %s">`:
   \   00000000   53534C207365       DC8 "SSL session remove: %s"
   \              7373696F6E20
   \              72656D6F7665
   \              3A20257300  
   \   00000017   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "SSL connect...">`:
   \   00000000   53534C20636F       DC8 "SSL connect..."
   \              6E6E6563742E
   \              2E2E00      
   \   0000000F   00                 DC8 0
   \   00000010   53534C5F636F       DC8 "SSL_connect Error!"
   \              6E6E65637420
   \              4572726F7221
   \              00          
   \   00000023   00                 DC8 0
   \   00000024   53534C5F636F       DC8 "SSL_connect Ok!"
   \              6E6E65637420
   \              4F6B2100    
    533          

   Maximum stack usage in bytes:

     Function                    CSTACK
     --------                    ------
     SSL_session_reused              0
     bread                          16
     bwrite                         20
     end_ssl                         8
     end_ssl_work                    4
     new_session                     8
     remove_session                  4
     ssl_connect                    32
     ssl_get_answer               4116
     ssl_send_answer                32
     ssl_socket_msg_handler         32
     tls1_alert_code_text            0
     tmr_connect_timeout_handler     4
     tmr_read_timeout_handler        4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SSL_MAX_SESS_COUNT                4
     tls1_alert_code_text            180
     SSL_session_reused                8
     bread                           132
     bwrite                          156
     tmr_connect_timeout_handler      40
     tmr_read_timeout_handler         40
     end_ssl                          56
     end_ssl_work                     28
     ssl_get_answer                  252
     ssl_send_answer                 400
     new_session                      48
     remove_session                   60
     ssl_connect                     360
     ctx                               8
     recv_size                         4
     conn                              8
     ssl_socket_msg_handler          552
     ??DataTable12                     4
     ??DataTable13                     4
     ??DataTable15                     4
     ??DataTable17                     4
     ??DataTable18                     4
     ?<Initializer for SSL_MAX_SESS_COUNT>
                                       4
     ?<Constant "SSL_read error!">    52
     ?<Constant "buffer free!!!">     88
     ?<Constant "close_notify">      232
     ?<Constant "SSL_write Ok">       48
     ?<Constant "SSL new session">    16
     ?<Constant "SSL session remove: %s">
                                      24
     ?<Constant "SSL connect...">     52
      Others                         236

 
 2 544 bytes in segment CODE
   512 bytes in segment DATA_C
     4 bytes in segment DATA_I
     4 bytes in segment DATA_ID
    20 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 2 332 bytes of CODE  memory (+ 236 bytes shared)
   516 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
