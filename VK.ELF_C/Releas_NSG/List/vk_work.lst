##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    05/Mar/2023  23:09:59 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \vk_work.c                                           #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \vk_work.c -D NEWSGOLD -D DEBUG -lCN                 #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ -la D:\Users\alfinant\Documents\Si #
#                       emens\Dev\IAR\VK.ELF_C\Releas_NSG\List\ -o           #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ -s9 --cpu_mode arm --endian little  #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\vk_work.lst                         #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\vk_work.r79                          #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\vk_work.c
      1          #include "vk_work.h"
      2          #include "parser_wall.h"
      3          
      4          #include <siemens\swilib.h>
      5          #include "string_util.h"
      6          
      7          //Инициализируем головы списков

   \                                 In segment DATA_I, align 4, align-sorted
      8          LIST_HEAD(dialogs);
   \                     dialogs:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for dialogs>`

   \                                 In segment DATA_I, align 4, align-sorted
      9          LIST_HEAD(my_groups);
   \                     my_groups:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for my_groups>`

   \                                 In segment DATA_I, align 4, align-sorted
     10          LIST_HEAD(friends);
   \                     friends:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for friends>`

   \                                 In segment DATA_I, align 4, align-sorted
     11          LIST_HEAD(profiles);//в этом списке будут пользователи
   \                     profiles:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for profiles>`

   \                                 In segment DATA_I, align 4, align-sorted
     12          LIST_HEAD(groups);//в этом списке группы
   \                     groups:
   \   00000000                      DS8 8
   \   00000008                      REQUIRE `?<Initializer for groups>`
     13          
     14          static int dialogs_cout = 0;//кол-во диалогов на сервере
     15          

   \                                 In segment DATA_C, align 4, align-sorted
     16          static const char percent_d[]="%d,";
   \                     percent_d:
   \   00000000   25642C00           DC8 "%d,"
     17          

   \                                 In segment CODE, align 4, keep-with-next
     18          WSHDR * CreateWS_emoji(char *utf8_str)
     19          {//подмена в utf8 тексте символов эмоджи и перевод в WSHDR
   \                     CreateWS_emoji:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
     20            if (utf8_str == 0 || *utf8_str == 0)//Если указатель нулевой или строка пуста
   \   00000008   0000D415           LDRBNE   R0,[R4, #+0]
   \   0000000C   00005013           CMPNE    R0,#+0
   \   00000010   0200001A           BNE      ??CreateWS_emoji_0
     21              return AllocWS(4);
   \   00000014   0400A0E3           MOV      R0,#+4
   \   00000018   250100EF           SWI      +293
   \   0000001C   7080BDE8           POP      {R4-R6,PC}
     22          
     23            int len = strlen(utf8_str);
   \                     ??CreateWS_emoji_0:
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   1B0000EF           SWI      +27
     24            char* __utf8_str = malloc(len + 1);
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   140000EF           SWI      +20
   \   00000030   0050A0E1           MOV      R5,R0
     25            strcpy(__utf8_str, utf8_str);
   \   00000034   0410A0E1           MOV      R1,R4
   \   00000038   1A0000EF           SWI      +26
     26            len = Replace_Smiles_Syms(__utf8_str);
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           _BLF     Replace_Smiles_Syms,??Replace_Smiles_Syms??rA
   \   00000044   0040A0E1           MOV      R4,R0
     27            WSHDR *ws = AllocWS(utf8_syms_n(__utf8_str, len));
   \   00000048   0410A0E1           MOV      R1,R4
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           _BLF     utf8_syms_n,??utf8_syms_n??rA
   \   00000054   250100EF           SWI      +293
   \   00000058   0060A0E1           MOV      R6,R0
     28            utf8_2ws(ws, __utf8_str, len);
   \   0000005C   0420A0E1           MOV      R2,R4
   \   00000060   0510A0E1           MOV      R1,R5
   \   00000064   E30100EF           SWI      +483
     29            mfree(__utf8_str);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   150000EF           SWI      +21
     30            
     31            return ws;
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
     32          }
     33          

   \                                 In segment CODE, align 4, keep-with-next
     34          int utf8_2ws_emoji(WSHDR *ws, char *utf8_str, unsigned int maxLen)
     35          {
   \                     utf8_2ws_emoji:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     36            //подмена в utf8 тексте символов эмоджи на сименсовские и перевод в WSHDR
     37            //char* s = malloc(strlen(utf8_str) + 1);
     38            int len = Replace_Smiles_Syms(utf8_str);
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     Replace_Smiles_Syms,??Replace_Smiles_Syms??rA
     39            return utf8_2ws(ws, utf8_str, len);
   \   00000014   0020A0E1           MOV      R2,R0
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   E30100EF           SWI      +483
   \   00000024   3080BDE8           POP      {R4,R5,PC}       ;; return
     40            //mfree(s);
     41          }
     42          
     43          /******************************************************************************/
     44          

   \                                 In segment CODE, align 4, keep-with-next
     45          VkUser *new_User(struct user_args *args)
     46          { 
   \                     new_User:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0050A0E1           MOV      R5,R0
     47            VkUser *user = malloc(sizeof(VkUser));
   \   00000008   2C00A0E3           MOV      R0,#+44
   \   0000000C   140000EF           SWI      +20
   \   00000010   0040A0E1           MOV      R4,R0
     48            INIT_LIST_HEAD(&user->list); 
   \   00000014   004084E5           STR      R4,[R4, #+0]
   \   00000018   044084E5           STR      R4,[R4, #+4]
     49            user->id = args->id;
   \   0000001C   000095E5           LDR      R0,[R5, #+0]
   \   00000020   080084E5           STR      R0,[R4, #+8]
     50            user->first_name = CreateWS_emoji(args->first_name);
   \   00000024   040095E5           LDR      R0,[R5, #+4]
   \   00000028   ........           BL       CreateWS_emoji
   \   0000002C   0C0084E5           STR      R0,[R4, #+12]
     51            user->last_name = CreateWS_emoji(args->last_name); 
   \   00000030   080095E5           LDR      R0,[R5, #+8]
   \   00000034   ........           BL       CreateWS_emoji
   \   00000038   100084E5           STR      R0,[R4, #+16]
     52            //CreateLocalWS(&user->first_name, user->first_name_body, 63);
     53            //CreateLocalWS(&user->last_name, user->last_name_body, 63);
     54            //utf8_2ws_emoji(&user->first_name, args->first_name, 31);
     55            //utf8_2ws_emoji(&user->last_name, args->last_name, 31);
     56            user->deactivated = args->deactivated;
   \   0000003C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000040   140084E5           STR      R0,[R4, #+20]
     57            user->friend_status = args->friend_status;
   \   00000044   1C0095E5           LDR      R0,[R5, #+28]
   \   00000048   180084E5           STR      R0,[R4, #+24]
     58            user->online = args->online;
   \   0000004C   180095E5           LDR      R0,[R5, #+24]
   \   00000050   280084E5           STR      R0,[R4, #+40]
     59            user->has_photo = args->has_photo;
   \   00000054   240095E5           LDR      R0,[R5, #+36]
   \   00000058   1C0084E5           STR      R0,[R4, #+28]
     60            if (args->photo_50)
   \   0000005C   200095E5           LDR      R0,[R5, #+32]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0600000A           BEQ      ??new_User_0
     61            {
     62              user->photo_50 = malloc(strlen(args->photo_50) + 1);
   \   00000068   1B0000EF           SWI      +27
   \   0000006C   010080E2           ADD      R0,R0,#+1
   \   00000070   140000EF           SWI      +20
   \   00000074   200084E5           STR      R0,[R4, #+32]
     63              strcpy(user->photo_50, args->photo_50);
   \   00000078   201095E5           LDR      R1,[R5, #+32]
   \   0000007C   1A0000EF           SWI      +26
     64            }
     65            user->photo_50_img = NULL;
   \   00000080   0000A0E3           MOV      R0,#+0
   \                     ??new_User_0:
   \   00000084   240084E5           STR      R0,[R4, #+36]
     66            return user;
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   3080BDE8           POP      {R4,R5,PC}       ;; return
     67          }
     68          

   \                                 In segment CODE, align 4, keep-with-next
     69          VkUser *find_User(struct list_head *head, int id)
     70          { 
     71            LIST_HEAD *iter;
     72            
     73            list_for_each(iter, head)
   \                     find_User:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   000000EA           B        ??find_User_0
   \                     ??find_User_1:
   \   00000008   002092E5           LDR      R2,[R2, #+0]
   \                     ??find_User_0:
   \   0000000C   000052E1           CMP      R2,R0
   \   00000010   0400000A           BEQ      ??find_User_2
     74            {
     75              VkUser *entry = list_entry(iter, VkUser, list);
     76              if (entry->id == id)
   \   00000014   083092E5           LDR      R3,[R2, #+8]
   \   00000018   010053E1           CMP      R3,R1
   \   0000001C   F9FFFF1A           BNE      ??find_User_1
     77                return entry;
   \   00000020   0200A0E1           MOV      R0,R2
   \   00000024   1EFF2FE1           BX       LR
     78            }
     79            return NULL;
   \                     ??find_User_2:
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR               ;; return
     80          }
     81          

   \                                 In segment CODE, align 4, keep-with-next
     82          void del_User(VkUser *user)
     83          {
   \                     del_User:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     84            if (user->first_name)
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      ??del_User_0
     85              FreeWS(user->first_name); 
   \   00000014   290100EF           SWI      +297
     86            
     87            if (user->last_name)
   \                     ??del_User_0:
   \   00000018   100094E5           LDR      R0,[R4, #+16]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0000000A           BEQ      ??del_User_1
     88              FreeWS(user->last_name); 
   \   00000024   290100EF           SWI      +297
     89            
     90            if (user->photo_50)
   \                     ??del_User_1:
   \   00000028   200094E5           LDR      R0,[R4, #+32]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0000000A           BEQ      ??del_User_2
     91              mfree(user->photo_50);
   \   00000034   150000EF           SWI      +21
     92            
     93            if (user->photo_50_img)
   \                     ??del_User_2:
   \   00000038   240094E5           LDR      R0,[R4, #+36]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0300000A           BEQ      ??del_User_3
     94            {
     95              mfree(user->photo_50_img->bitmap);
   \   00000044   040090E5           LDR      R0,[R0, #+4]
   \   00000048   150000EF           SWI      +21
     96              mfree(user->photo_50_img);    
   \   0000004C   240094E5           LDR      R0,[R4, #+36]
   \   00000050   150000EF           SWI      +21
     97            }
     98            
     99            list_del(&user->list);
   \                     ??del_User_3:
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   041094E5           LDR      R1,[R4, #+4]
   \   0000005C   041080E5           STR      R1,[R0, #+4]
   \   00000060   000081E5           STR      R0,[R1, #+0]
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   000084E5           STR      R0,[R4, #+0]
   \   0000006C   040084E5           STR      R0,[R4, #+4]
    100            mfree(user);
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   150000EF           SWI      +21
    101          }  
   \   00000078   1080BDE8           POP      {R4,PC}          ;; return
    102          //------------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    103          void del_wall_attachments(LIST_HEAD *head)
    104          {
   \                     del_wall_attachments:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    105            struct list_head *iter, *n;
    106            
    107            list_for_each_safe(iter, n, head)
   \   00000008   005094E5           LDR      R5,[R4, #+0]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   040055E1           CMP      R5,R4
   \   00000014   0900000A           BEQ      ??del_wall_attachments_0
    108            {
    109              ATTACH_WALL *entry = list_entry(iter, ATTACH_WALL, list);
    110              if(entry->url)
   \                     ??del_wall_attachments_1:
   \   00000018   0C0095E5           LDR      R0,[R5, #+12]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0000000A           BEQ      ??del_wall_attachments_2
    111                mfree(entry->url);
   \   00000024   150000EF           SWI      +21
    112              mfree(entry);
   \                     ??del_wall_attachments_2:
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   150000EF           SWI      +21
    113            }
   \   00000030   0650A0E1           MOV      R5,R6
   \   00000034   006095E5           LDR      R6,[R5, #+0]
   \   00000038   040055E1           CMP      R5,R4
   \   0000003C   F5FFFF1A           BNE      ??del_wall_attachments_1
    114            
    115            INIT_LIST_HEAD(head);
   \                     ??del_wall_attachments_0:
   \   00000040   004084E5           STR      R4,[R4, #+0]
   \   00000044   044084E5           STR      R4,[R4, #+4]
    116          }
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
    117          

   \                                 In segment CODE, align 4, keep-with-next
    118          void _del_Profiles(LIST_HEAD *head)
    119          { 
   \                     _del_Profiles:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    120            struct list_head *iter, *n;
    121              
    122            list_for_each_safe(iter, n, head)
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   3080BD08           POPEQ    {R4,R5,PC}
    123            {
    124              VkUser *entry = list_entry(iter, VkUser, list);
    125              del_User(entry);
   \                     ??_del_Profiles_0:
   \   00000018   ........           BL       del_User
    126            }
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   005090E5           LDR      R5,[R0, #+0]
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   FAFFFF1A           BNE      ??_del_Profiles_0
    127          }
   \   0000002C   3080BDE8           POP      {R4,R5,PC}       ;; return
    128          

   \                                 In segment CODE, align 4, keep-with-next
    129          void FreeWALL(WALL_MSG* wall)
    130          {
   \                     FreeWALL:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    131            if(wall == 0)
   \   00000008   7080BD08           POPEQ    {R4-R6,PC}
    132              return;
    133            
    134            struct list_head *iter, *n;
    135            list_for_each_safe(iter, n, &wall->list)
   \   0000000C   005094E5           LDR      R5,[R4, #+0]
   \   00000010   006095E5           LDR      R6,[R5, #+0]
   \   00000014   040055E1           CMP      R5,R4
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
    136            {
    137              WALL_MSG* entry = list_entry(iter, WALL_MSG, list);
    138              
    139              if(entry->text)
   \                     ??FreeWALL_0:
   \   0000001C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0000000A           BEQ      ??FreeWALL_1
    140                FreeWS(entry->text);
   \   00000028   290100EF           SWI      +297
    141              
    142              if (!list_empty(&entry->attachments))
   \                     ??FreeWALL_1:
   \   0000002C   340085E2           ADD      R0,R5,#+52
   \   00000030   001090E5           LDR      R1,[R0, #+0]
   \   00000034   000051E1           CMP      R1,R0
   \   00000038   0000000A           BEQ      ??FreeWALL_2
    143                del_wall_attachments(&entry->attachments);
   \   0000003C   ........           BL       del_wall_attachments
    144          
    145              if (!list_empty(&entry->profiles))
   \                     ??FreeWALL_2:
   \   00000040   3C0085E2           ADD      R0,R5,#+60
   \   00000044   001090E5           LDR      R1,[R0, #+0]
   \   00000048   000051E1           CMP      R1,R0
   \   0000004C   0000000A           BEQ      ??FreeWALL_3
    146                _del_Profiles(&entry->profiles);
   \   00000050   ........           BL       _del_Profiles
    147              
    148              list_del(&entry->list);
   \                     ??FreeWALL_3:
   \   00000054   000095E5           LDR      R0,[R5, #+0]
   \   00000058   041095E5           LDR      R1,[R5, #+4]
   \   0000005C   041080E5           STR      R1,[R0, #+4]
   \   00000060   000081E5           STR      R0,[R1, #+0]
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   000085E5           STR      R0,[R5, #+0]
   \   0000006C   040085E5           STR      R0,[R5, #+4]
    149              mfree(entry);
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   150000EF           SWI      +21
    150            }
   \   00000078   0650A0E1           MOV      R5,R6
   \   0000007C   006095E5           LDR      R6,[R5, #+0]
   \   00000080   040055E1           CMP      R5,R4
   \   00000084   E4FFFF1A           BNE      ??FreeWALL_0
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
    151          }
    152          
    153          
    154          //------------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    155          void del_Profiles()
    156          { 
   \                     del_Profiles:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    157            struct list_head *iter, *n;
    158              
    159            list_for_each_safe(iter, n, &profiles)
   \   00000004   2C409FE5           LDR      R4,??del_Profiles_0  ;; profiles
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   0400000A           BEQ      ??del_Profiles_1
    160            {
    161              VkUser *entry = list_entry(iter, VkUser, list);
    162              del_User(entry);
   \                     ??del_Profiles_2:
   \   00000018   ........           BL       del_User
    163            }
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   005090E5           LDR      R5,[R0, #+0]
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   FAFFFF1A           BNE      ??del_Profiles_2
    164            INIT_LIST_HEAD(&profiles);
   \                     ??del_Profiles_1:
   \   0000002C   004084E5           STR      R4,[R4, #+0]
   \   00000030   044084E5           STR      R4,[R4, #+4]
    165          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??del_Profiles_0:
   \   00000038   ........           DC32     profiles
    166          
    167          /******************************************************************************/
    168          

   \                                 In segment CODE, align 4, keep-with-next
    169          void del_attachments(LIST_HEAD *head)
    170          {
   \                     del_attachments:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    171            struct list_head *iter, *n;
    172            
    173            list_for_each_safe(iter, n, head)
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   0400000A           BEQ      ??del_attachments_0
    174            {
    175              //VkAttach *a = list_entry(iter, VkAttach, list);
    176              mfree(iter);
   \                     ??del_attachments_1:
   \   00000018   150000EF           SWI      +21
    177            }
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   005090E5           LDR      R5,[R0, #+0]
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   FAFFFF1A           BNE      ??del_attachments_1
    178            INIT_LIST_HEAD(head);
   \                     ??del_attachments_0:
   \   0000002C   004084E5           STR      R4,[R4, #+0]
   \   00000030   044084E5           STR      R4,[R4, #+4]
    179          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    180          
    181          /******************************************************************************/
    182          

   \                                 In segment CODE, align 4, keep-with-next
    183          VkMsg *new_Message(struct message_args *args, struct list_head *attachments)
    184          {
   \                     new_Message:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0060A0E1           MOV      R6,R0
   \   00000008   0150A0E1           MOV      R5,R1
    185            VkMsg *message = malloc(sizeof(VkMsg));
   \   0000000C   2800A0E3           MOV      R0,#+40
   \   00000010   140000EF           SWI      +20
   \   00000014   0040A0E1           MOV      R4,R0
    186            INIT_LIST_HEAD(&message->list);  
   \   00000018   004084E5           STR      R4,[R4, #+0]
   \   0000001C   044084E5           STR      R4,[R4, #+4]
    187            message->id = args->id;
   \   00000020   000096E5           LDR      R0,[R6, #+0]
   \   00000024   080084E5           STR      R0,[R4, #+8]
    188            message->date = args->date;
   \   00000028   040096E5           LDR      R0,[R6, #+4]
   \   0000002C   0C0084E5           STR      R0,[R4, #+12]
    189            message->from_id = args->from_id;
   \   00000030   080096E5           LDR      R0,[R6, #+8]
   \   00000034   100084E5           STR      R0,[R4, #+16]
    190            message->peer_id = args->peer_id;
   \   00000038   0C0096E5           LDR      R0,[R6, #+12]
   \   0000003C   140084E5           STR      R0,[R4, #+20]
    191            message->out = args->out;
   \   00000040   140096E5           LDR      R0,[R6, #+20]
   \   00000044   1C0084E5           STR      R0,[R4, #+28]
    192            message->text = CreateWS_emoji(args->text);
   \   00000048   100096E5           LDR      R0,[R6, #+16]
   \   0000004C   ........           BL       CreateWS_emoji
   \   00000050   180084E5           STR      R0,[R4, #+24]
    193            INIT_LIST_HEAD(&message->attachments);
   \   00000054   200084E2           ADD      R0,R4,#+32
   \   00000058   200084E5           STR      R0,[R4, #+32]
   \   0000005C   240084E5           STR      R0,[R4, #+36]
    194            if (!list_empty(attachments))
   \   00000060   000095E5           LDR      R0,[R5, #+0]
   \   00000064   050050E1           CMP      R0,R5
   \   00000068   0600000A           BEQ      ??new_Message_0
    195              list_splice(attachments, &message->attachments);
   \   0000006C   042095E5           LDR      R2,[R5, #+4]
   \   00000070   201084E2           ADD      R1,R4,#+32
   \   00000074   0130A0E1           MOV      R3,R1
   \   00000078   041080E5           STR      R1,[R0, #+4]
   \   0000007C   000081E5           STR      R0,[R1, #+0]
   \   00000080   003082E5           STR      R3,[R2, #+0]
   \   00000084   042083E5           STR      R2,[R3, #+4]
    196            return message;
   \                     ??new_Message_0:
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   7080BDE8           POP      {R4-R6,PC}       ;; return
    197          }
    198          

   \                                 In segment CODE, align 4, keep-with-next
    199          void del_Message(VkMsg *msg)
    200          {
   \                     del_Message:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    201            list_del(&msg->list);
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   041094E5           LDR      R1,[R4, #+4]
   \   00000010   041080E5           STR      R1,[R0, #+4]
   \   00000014   000081E5           STR      R0,[R1, #+0]
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   000084E5           STR      R0,[R4, #+0]
   \   00000020   040084E5           STR      R0,[R4, #+4]
    202            FreeWS(msg->text);
   \   00000024   180094E5           LDR      R0,[R4, #+24]
   \   00000028   290100EF           SWI      +297
    203            del_attachments(&msg->attachments);
   \   0000002C   200084E2           ADD      R0,R4,#+32
   \   00000030   ........           BL       del_attachments
    204            mfree(msg);
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   150000EF           SWI      +21
    205          }
   \   0000003C   1080BDE8           POP      {R4,PC}          ;; return
    206          

   \                                 In segment CODE, align 4, keep-with-next
    207          void del_Messages(LIST_HEAD *head)
    208          { 
   \                     del_Messages:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    209            struct list_head *iter, *n;
    210            
    211            list_for_each_safe(iter, n, head)
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   0400000A           BEQ      ??del_Messages_0
    212            {
    213              VkMsg *msg = list_entry(iter, VkMsg, list);
    214              del_Message(msg);
   \                     ??del_Messages_1:
   \   00000018   ........           BL       del_Message
    215            }
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   005090E5           LDR      R5,[R0, #+0]
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   FAFFFF1A           BNE      ??del_Messages_1
    216            INIT_LIST_HEAD(head);
   \                     ??del_Messages_0:
   \   0000002C   004084E5           STR      R4,[R4, #+0]
   \   00000030   044084E5           STR      R4,[R4, #+4]
    217          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
    218          
    219          /******************************************************************************/
    220          

   \                                 In segment CODE, align 4, keep-with-next
    221          VkGroup *new_Group(struct group_args *args)
    222          { 
   \                     new_Group:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    223            VkGroup *group = malloc(sizeof(VkGroup));
   \   00000008   3000A0E3           MOV      R0,#+48
   \   0000000C   140000EF           SWI      +20
   \   00000010   0050A0E1           MOV      R5,R0
    224            INIT_LIST_HEAD(&group->list); 
   \   00000014   005085E5           STR      R5,[R5, #+0]
   \   00000018   045085E5           STR      R5,[R5, #+4]
    225            group->id = args->id;
   \   0000001C   000094E5           LDR      R0,[R4, #+0]
   \   00000020   080085E5           STR      R0,[R5, #+8]
    226            group->name = CreateWS_emoji(args->name);
   \   00000024   040094E5           LDR      R0,[R4, #+4]
   \   00000028   ........           BL       CreateWS_emoji
   \   0000002C   0C0085E5           STR      R0,[R5, #+12]
    227            group->screen_name = CreateWS_emoji(args->screen_name); 
   \   00000030   080094E5           LDR      R0,[R4, #+8]
   \   00000034   ........           BL       CreateWS_emoji
   \   00000038   100085E5           STR      R0,[R5, #+16]
    228            //CreateLocalWS(&group->name, group->name_body, 63);
    229            //CreateLocalWS(&group->screen_name, group->screen_name_body, 63);
    230            //utf8_2ws_emoji(&group->name, args->name, 31);
    231            //utf8_2ws_emoji(&group->screen_name, args->screen_name, 31);
    232            group->is_closed = args->is_closed;
   \   0000003C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000040   280085E5           STR      R0,[R5, #+40]
    233            group->deactivated = args->deactivated;
   \   00000044   100094E5           LDR      R0,[R4, #+16]
   \   00000048   140085E5           STR      R0,[R5, #+20]
    234            group->is_member = args->is_member;
   \   0000004C   180094E5           LDR      R0,[R4, #+24]
   \   00000050   180085E5           STR      R0,[R5, #+24]
    235            group->type = args->type;
   \   00000054   140094E5           LDR      R0,[R4, #+20]
   \   00000058   2C0085E5           STR      R0,[R5, #+44]
    236            group->has_photo = args->has_photo;  
   \   0000005C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000060   1C0085E5           STR      R0,[R5, #+28]
    237            if (args->photo_50)
   \   00000064   200094E5           LDR      R0,[R4, #+32]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   0600000A           BEQ      ??new_Group_0
    238            {
    239              group->photo_50 = malloc(strlen(args->photo_50) + 1);
   \   00000070   1B0000EF           SWI      +27
   \   00000074   010080E2           ADD      R0,R0,#+1
   \   00000078   140000EF           SWI      +20
   \   0000007C   200085E5           STR      R0,[R5, #+32]
    240              strcpy(group->photo_50, args->photo_50);
   \   00000080   201094E5           LDR      R1,[R4, #+32]
   \   00000084   1A0000EF           SWI      +26
    241            }
    242            group->photo_50_img = NULL;
   \   00000088   0000A0E3           MOV      R0,#+0
   \                     ??new_Group_0:
   \   0000008C   240085E5           STR      R0,[R5, #+36]
    243            return group;
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   3080BDE8           POP      {R4,R5,PC}       ;; return
    244          }  
    245            

   \                                 In segment CODE, align 4, keep-with-next
    246          VkGroup *find_Group(struct list_head *head, int id)
    247          { 
    248            LIST_HEAD *iter;
    249            
    250            list_for_each(iter, head)
   \                     find_Group:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   000000EA           B        ??find_Group_0
   \                     ??find_Group_1:
   \   00000008   002092E5           LDR      R2,[R2, #+0]
   \                     ??find_Group_0:
   \   0000000C   000052E1           CMP      R2,R0
   \   00000010   0400000A           BEQ      ??find_Group_2
    251            {
    252              VkGroup *entry = list_entry(iter, VkGroup, list);
    253              if (entry->id == id)
   \   00000014   083092E5           LDR      R3,[R2, #+8]
   \   00000018   010053E1           CMP      R3,R1
   \   0000001C   F9FFFF1A           BNE      ??find_Group_1
    254                return entry;
   \   00000020   0200A0E1           MOV      R0,R2
   \   00000024   1EFF2FE1           BX       LR
    255            }
    256            return NULL;
   \                     ??find_Group_2:
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    257          }
    258          

   \                                 In segment CODE, align 4, keep-with-next
    259          void del_Group(VkGroup *group)
    260          {
   \                     del_Group:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    261            if (group->name)
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      ??del_Group_0
    262              FreeWS(group->name); 
   \   00000014   290100EF           SWI      +297
    263            
    264            if (group->screen_name)
   \                     ??del_Group_0:
   \   00000018   100094E5           LDR      R0,[R4, #+16]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0000000A           BEQ      ??del_Group_1
    265              FreeWS(group->screen_name); 
   \   00000024   290100EF           SWI      +297
    266            
    267            if (group->photo_50)
   \                     ??del_Group_1:
   \   00000028   200094E5           LDR      R0,[R4, #+32]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0000000A           BEQ      ??del_Group_2
    268              mfree(group->photo_50);
   \   00000034   150000EF           SWI      +21
    269            
    270            if (group->photo_50_img)
   \                     ??del_Group_2:
   \   00000038   240094E5           LDR      R0,[R4, #+36]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0300000A           BEQ      ??del_Group_3
    271            {
    272              mfree(group->photo_50_img->bitmap);
   \   00000044   040090E5           LDR      R0,[R0, #+4]
   \   00000048   150000EF           SWI      +21
    273              mfree(group->photo_50_img);    
   \   0000004C   240094E5           LDR      R0,[R4, #+36]
   \   00000050   150000EF           SWI      +21
    274            }
    275            
    276            list_del(&group->list);
   \                     ??del_Group_3:
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   041094E5           LDR      R1,[R4, #+4]
   \   0000005C   041080E5           STR      R1,[R0, #+4]
   \   00000060   000081E5           STR      R0,[R1, #+0]
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   000084E5           STR      R0,[R4, #+0]
   \   0000006C   040084E5           STR      R0,[R4, #+4]
    277            mfree(group);
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   150000EF           SWI      +21
    278          }
   \   00000078   1080BDE8           POP      {R4,PC}          ;; return
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          void del_Groups()
    281          { 
   \                     del_Groups:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    282            struct list_head *iter, *n;
    283              
    284            list_for_each_safe(iter, n, &groups)
   \   00000004   2C409FE5           LDR      R4,??del_Groups_0  ;; groups
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   005090E5           LDR      R5,[R0, #+0]
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   0400000A           BEQ      ??del_Groups_1
    285            {
    286              VkGroup *entry = list_entry(iter, VkGroup, list);
    287              del_Group(entry);
   \                     ??del_Groups_2:
   \   00000018   ........           BL       del_Group
    288            }
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   005090E5           LDR      R5,[R0, #+0]
   \   00000024   040050E1           CMP      R0,R4
   \   00000028   FAFFFF1A           BNE      ??del_Groups_2
    289            INIT_LIST_HEAD(&groups);
   \                     ??del_Groups_1:
   \   0000002C   004084E5           STR      R4,[R4, #+0]
   \   00000030   044084E5           STR      R4,[R4, #+4]
    290          }
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??del_Groups_0:
   \   00000038   ........           DC32     groups
    291          /******************************************************************************/
    292          

   \                                 In segment CODE, align 4, keep-with-next
    293          VkDialog *new_Dialog(VkMsg *msg, int from_id, int unread, int out_read)
    294          {
   \                     new_Dialog:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0360A0E1           MOV      R6,R3
    295            VkDialog *dialog = malloc(sizeof(VkDialog));
   \   00000010   2400A0E3           MOV      R0,#+36
   \   00000014   140000EF           SWI      +20
    296            INIT_LIST_HEAD(&dialog->list);
   \   00000018   000080E5           STR      R0,[R0, #+0]
   \   0000001C   040080E5           STR      R0,[R0, #+4]
    297            if (msg->out)
   \   00000020   1C1094E5           LDR      R1,[R4, #+28]
   \   00000024   000051E3           CMP      R1,#+0
    298              dialog->from_id = msg->peer_id;
   \   00000028   14109415           LDRNE    R1,[R4, #+20]
    299            else
    300              dialog->from_id = msg->from_id;  
   \   0000002C   10109405           LDREQ    R1,[R4, #+16]
   \   00000030   081080E5           STR      R1,[R0, #+8]
    301            dialog->unread_count = unread;
   \   00000034   0C5080E5           STR      R5,[R0, #+12]
    302            dialog->out_read = out_read;
   \   00000038   106080E5           STR      R6,[R0, #+16]
    303            INIT_LIST_HEAD(&dialog->messages);
   \   0000003C   141080E2           ADD      R1,R0,#+20
   \   00000040   141080E5           STR      R1,[R0, #+20]
   \   00000044   181080E5           STR      R1,[R0, #+24]
    304            list_add(&msg->list, &dialog->messages);
   \   00000048   0120A0E1           MOV      R2,R1
   \   0000004C   044082E5           STR      R4,[R2, #+4]
   \   00000050   002084E5           STR      R2,[R4, #+0]
   \   00000054   041084E5           STR      R1,[R4, #+4]
   \   00000058   004081E5           STR      R4,[R1, #+0]
    305            dialog->user = NULL;
   \   0000005C   0010A0E3           MOV      R1,#+0
   \   00000060   1C1080E5           STR      R1,[R0, #+28]
    306            dialog->group =NULL;
   \   00000064   201080E5           STR      R1,[R0, #+32]
    307            return dialog;
   \   00000068   7080BDE8           POP      {R4-R6,PC}       ;; return
    308          }
    309          

   \                                 In segment CODE, align 4, keep-with-next
    310          VkDialog *FindDialog(LIST_HEAD *head, int from_id)
    311          { 
    312            LIST_HEAD *iter;
    313            
    314            list_for_each(iter, head)
   \                     FindDialog:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   030000EA           B        ??FindDialog_0
    315            {
    316              VkDialog *entry = list_entry(iter, VkDialog, list);
    317              
    318              if (!list_empty(&entry->messages))
    319              {
    320                VkMsg *msg = list_entry(entry->messages.next, VkMsg, list);
    321                if (msg->out)
    322                {
    323                  if (msg->peer_id == from_id)
    324                    return entry;
    325                }
    326                else
    327                  if (msg->from_id == from_id)
   \                     ??FindDialog_1:
   \   00000008   103093E5           LDR      R3,[R3, #+16]
   \   0000000C   010053E1           CMP      R3,R1
   \   00000010   0D00000A           BEQ      ??FindDialog_2
   \                     ??FindDialog_3:
   \   00000014   002092E5           LDR      R2,[R2, #+0]
   \                     ??FindDialog_0:
   \   00000018   000052E1           CMP      R2,R0
   \   0000001C   0C00000A           BEQ      ??FindDialog_4
   \   00000020   143082E2           ADD      R3,R2,#+20
   \   00000024   00C093E5           LDR      R12,[R3, #+0]
   \   00000028   03005CE1           CMP      R12,R3
   \   0000002C   F8FFFF0A           BEQ      ??FindDialog_3
   \   00000030   0C30A0E1           MOV      R3,R12
   \   00000034   1CC093E5           LDR      R12,[R3, #+28]
   \   00000038   00005CE3           CMP      R12,#+0
   \   0000003C   F1FFFF0A           BEQ      ??FindDialog_1
   \   00000040   143093E5           LDR      R3,[R3, #+20]
   \   00000044   010053E1           CMP      R3,R1
   \   00000048   F1FFFF1A           BNE      ??FindDialog_3
   \                     ??FindDialog_2:
   \   0000004C   0200A0E1           MOV      R0,R2
   \   00000050   1EFF2FE1           BX       LR
    328                    return entry;
    329              }     
    330            }
    331            return NULL;
   \                     ??FindDialog_4:
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   1EFF2FE1           BX       LR               ;; return
    332          }
    333          

   \                                 In segment CODE, align 4, keep-with-next
    334          VkMsg *get_DialogMsg(VkDialog *dialog)
    335          {
    336            VkMsg *msg = NULL;
    337            
    338            if (!list_empty(&dialog->messages))
   \                     get_DialogMsg:
   \   00000000   142080E2           ADD      R2,R0,#+20
   \   00000004   003092E5           LDR      R3,[R2, #+0]
   \   00000008   0010A0E3           MOV      R1,#+0
   \   0000000C   020053E1           CMP      R3,R2
    339              msg = list_entry(dialog->messages.next, VkMsg, list);
   \   00000010   0310A011           MOVNE    R1,R3
    340            
    341            return msg;
   \   00000014   0100A0E1           MOV      R0,R1
   \   00000018   1EFF2FE1           BX       LR               ;; return
    342          }
    343          

   \                                 In segment CODE, align 4, keep-with-next
    344          void del_Dialogs()
    345          { 
   \                     del_Dialogs:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    346            struct list_head *iter, *n;
    347              
    348            list_for_each_safe(iter, n, &dialogs)
   \   00000004   80409FE5           LDR      R4,??del_Dialogs_0  ;; dialogs
   \   00000008   005094E5           LDR      R5,[R4, #+0]
   \   0000000C   006095E5           LDR      R6,[R5, #+0]
   \   00000010   040055E1           CMP      R5,R4
   \   00000014   1900000A           BEQ      ??del_Dialogs_1
    349            {
    350              VkDialog *entry = list_entry(iter, VkDialog, list);
    351              
    352              if (!list_empty(&entry->messages))
   \                     ??del_Dialogs_2:
   \   00000018   140085E2           ADD      R0,R5,#+20
   \   0000001C   001090E5           LDR      R1,[R0, #+0]
   \   00000020   000051E1           CMP      R1,R0
   \   00000024   0000000A           BEQ      ??del_Dialogs_3
    353                del_Messages(&entry->messages);
   \   00000028   ........           BL       del_Messages
    354              
    355              if (entry->user)
   \                     ??del_Dialogs_3:
   \   0000002C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0000000A           BEQ      ??del_Dialogs_4
    356                del_User(entry->user);
   \   00000038   ........           BL       del_User
    357              
    358              if (entry->group)
   \                     ??del_Dialogs_4:
   \   0000003C   200095E5           LDR      R0,[R5, #+32]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0000000A           BEQ      ??del_Dialogs_5
    359                del_Group(entry->group);
   \   00000048   ........           BL       del_Group
    360              
    361              list_del(iter);
   \                     ??del_Dialogs_5:
   \   0000004C   000095E5           LDR      R0,[R5, #+0]
   \   00000050   041095E5           LDR      R1,[R5, #+4]
   \   00000054   041080E5           STR      R1,[R0, #+4]
   \   00000058   000081E5           STR      R0,[R1, #+0]
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   000085E5           STR      R0,[R5, #+0]
   \   00000064   040085E5           STR      R0,[R5, #+4]
    362              mfree(entry);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   150000EF           SWI      +21
    363            }
   \   00000070   0650A0E1           MOV      R5,R6
   \   00000074   006095E5           LDR      R6,[R5, #+0]
   \   00000078   040055E1           CMP      R5,R4
   \   0000007C   E5FFFF1A           BNE      ??del_Dialogs_2
    364            INIT_LIST_HEAD(&dialogs);
   \                     ??del_Dialogs_1:
   \   00000080   004084E5           STR      R4,[R4, #+0]
   \   00000084   044084E5           STR      R4,[R4, #+4]
    365          }
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??del_Dialogs_0:
   \   0000008C   ........           DC32     dialogs
    366          
    367          /******************************************************************************/
    368          

   \                                 In segment CODE, align 4, keep-with-next
    369          int count_ListElements(LIST_HEAD *head)
    370          {
    371            struct list_head *iter;
    372            int i = 0;
    373            
    374            list_for_each(iter, head)
   \                     count_ListElements:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   000052E1           CMP      R2,R0
   \   0000000C   0300000A           BEQ      ??count_ListElements_0
    375              i++;
   \                     ??count_ListElements_1:
   \   00000010   002092E5           LDR      R2,[R2, #+0]
   \   00000014   011081E2           ADD      R1,R1,#+1
   \   00000018   000052E1           CMP      R2,R0
   \   0000001C   FBFFFF1A           BNE      ??count_ListElements_1
    376            
    377            return i;
   \                     ??count_ListElements_0:
   \   00000020   0100A0E1           MOV      R0,R1
   \   00000024   1EFF2FE1           BX       LR               ;; return
    378          }
    379          

   \                                 In segment CODE, align 4, keep-with-next
    380          struct list_head *get_ListByIndex(LIST_HEAD *head, int index)
    381          {
    382            struct list_head *iter;
    383            int i = 0;
    384            
    385            list_for_each(iter, head)
   \                     get_ListByIndex:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   010000EA           B        ??get_ListByIndex_0
    386            {
    387              if (i == index)
    388                return iter;
    389              i++;
   \                     ??get_ListByIndex_1:
   \   0000000C   002092E5           LDR      R2,[R2, #+0]
   \   00000010   013083E2           ADD      R3,R3,#+1
   \                     ??get_ListByIndex_0:
   \   00000014   000052E1           CMP      R2,R0
   \   00000018   0300000A           BEQ      ??get_ListByIndex_2
   \   0000001C   010053E1           CMP      R3,R1
   \   00000020   F9FFFF1A           BNE      ??get_ListByIndex_1
   \   00000024   0200A0E1           MOV      R0,R2
   \   00000028   1EFF2FE1           BX       LR
    390            }
    391            
    392            return 0;
   \                     ??get_ListByIndex_2:
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
    393          }
    394          
    395          
    396          /*
    397          int AddMsg2Dialog(PRS_MSG* msg)
    398          {
    399            DIALOG* d = FindDialog(msg->from_id);
    400            
    401            if (d == NULL)//если диалога нет, то создаем
    402              d = new_Dialog(from_id, NULL);
    403            
    404            PRS_MSG* msg = FindMsgById(id);
    405            
    406            if (msg)//если сообщение уже есть в списке
    407              return 1;
    408            
    409            list_add(&d->message, &msg->list); 
    410            return 0;
    411          }
    412          
    413          void FreeAtachments(ATTACH* a)
    414          {
    415            while (a)
    416            {
    417              if (a->url)
    418                mfree(a->url);
    419              void* next=a->next;
    420              mfree(a);
    421              a=next;
    422            }
    423          }
    424          
    425          WALL_ATTACH* FindAttachByIndex(WALL_MSG* msg, int i)
    426          {
    427            WALL_ATTACH* attach=msg->attach_list;
    428            int n=0;
    429            
    430            while(attach)
    431            {
    432              if (i == n)
    433                break;
    434              n++;
    435              attach=attach->next;
    436            }
    437            return attach;  
    438          }
    439          
    440          PERSONAL_MSG* AllocMSG()
    441          {
    442            PERSONAL_MSG* msg;
    443            
    444            msg=malloc(sizeof(PERSONAL_MSG));
    445            msg->prev=0;  
    446            msg->next=0;
    447            msg->body=NULL;  
    448            msg->id=0;
    449            msg->date=0;  
    450            msg->user_id=0;
    451            msg->read_state=0;
    452            msg->out=0;
    453            msg->emoji=0;
    454            msg->attach=0;
    455            
    456            return msg;
    457          };
    458          
    459          void FreeWALLMSG(CLIST* c)
    460          {
    461            WALL_MSG* msg=(WALL_MSG*)c->wall_msglist;
    462            c->wall_msglist=NULL;
    463            
    464            while (msg)
    465            {
    466              if (msg->text)
    467                FreeWS(msg->text);
    468              if (msg->attach_list)
    469                FreeAtachments(msg->attach_list);
    470              if (msg->profiles)
    471                CLIST_Free(&msg->profiles);
    472              void* next=msg->next;
    473              mfree(msg);
    474              msg=next;
    475            }
    476          }
    477          
    478          void FreeMSGLIST(CLIST* c)
    479          {
    480            PERSONAL_MSG* msg=c->msglist;
    481            
    482            while (msg)
    483            {
    484              void* next=msg->next;
    485              if (msg->body)
    486                FreeWS(msg->body);
    487              mfree(msg);
    488              msg=next;
    489            }
    490            c->msglist=NULL;
    491          }
    492          
    493          PERSONAL_MSG* FindMsgById(CLIST* c, int id)
    494          {
    495            PERSONAL_MSG* msg;
    496            
    497            if (c==NULL)
    498              return(0);
    499            
    500            msg=c->msglist;
    501            
    502            while(msg)
    503            {
    504              if (msg->id==id)
    505                return msg;
    506              msg=msg->next;
    507            }
    508            return(0);  
    509          }
    510          
    511          void AddMsg(CLIST* c, PERSONAL_MSG* msg)
    512          {
    513            PERSONAL_MSG* msg_i; 
    514            PERSONAL_MSG* msg_prev;
    515            
    516            c->msg_count++;//счетчик сообщений
    517            
    518            if (msg->out==0 && msg->read_state==0)//если не прочитано
    519              c->unread++;
    520            
    521            if (c->msglist==NULL)//добавляем первое сообщение
    522            {
    523               c->msglist=msg;
    524              return;
    525            }
    526            
    527            msg_i=c->msglist;
    528            
    529            while (msg_i)
    530            {
    531              if (msg->id > msg_i->id)//ищем мессагу с id мньше нашего
    532              {
    533                msg_prev=msg_i->prev;
    534                if (msg_prev==0)//значит топ
    535                  c->msglist=msg;
    536                else
    537                  msg_prev->next=msg;
    538                msg->next=msg_i;
    539                msg->prev=msg_prev;
    540                msg_i->prev=msg;
    541                break;
    542              }
    543              else
    544                if (msg_i->next==NULL)//не нашли,вставляем в конец списка
    545                {
    546                  msg->next=0;
    547                  msg->prev=msg_i;
    548                  msg_i->next=msg;     
    549                  break;
    550                }
    551              msg_i=msg_i->next;
    552            }  
    553          }
    554          
    555          
    556          void AddUserInfo(int id, int deactivated, char* first_name, char* last_name, char* photo_50)
    557          {
    558            if (id == my_id)//свои данные пока не обновляем
    559              return;
    560            
    561            CLIST* c = FindContactById(csm->dialogs_list, id);
    562            
    563            if (c == NULL)//если контакта нет в списке
    564              return;
    565               
    566            if (first_name)
    567            {
    568              if (c->first_name == NULL)
    569                c->first_name = AllocWS(65);     
    570              utf8_2ws(c->first_name, first_name, strlen(first_name));
    571          
    572            }
    573            
    574            if (last_name)
    575            {
    576              if (c->last_name == NULL)
    577                c->last_name = AllocWS(65);     
    578              utf8_2ws(c->last_name, last_name, strlen(last_name));
    579            }
    580            
    581            if (photo_50)
    582            {
    583              if (c->photo_url == NULL)
    584                c->photo_url = malloc(strlen(photo_50));
    585              c->photo_url = photo_50;
    586            }
    587           
    588          }
    589          
    590          
    591          CLIST* CreateContact(int id)
    592          {
    593            CLIST* c;
    594            
    595            c=malloc(sizeof(CLIST));
    596            c->next=NULL;
    597            c->prev=NULL;
    598            c->msglist=NULL;
    599            c->wall_msglist=NULL;
    600            c->user_id=id;
    601            c->first_name=NULL;
    602            c->last_name=NULL;
    603            c->photo=NULL;
    604            c->photo_url=NULL;
    605            c->flag_load_photo=0;
    606            c->deactivated=0;
    607            c->msg_count=0;  
    608            c->unread=0;
    609            return c;
    610          }
    611          
    612          static void FreeContact(CLIST* c)
    613          {
    614            if (c->first_name)
    615              FreeWS(c->first_name);
    616            
    617            if (c->last_name)
    618              FreeWS(c->last_name);
    619            
    620            if (c->msglist)
    621              FreeMSGLIST(c);
    622          
    623            if (c->wall_msglist)
    624              FreeWALLMSG(c);
    625            
    626            if (c->photo_url)
    627              mfree(c->photo_url);
    628            
    629            if (c->photo)
    630            {
    631              mfree(c->photo->bitmap);
    632              mfree(c->photo);
    633            }
    634            mfree(c);
    635          }
    636          
    637          void CLIST_Free(CLIST** cl)
    638          {
    639            CLIST* c=*cl;
    640          
    641            while(c)
    642            {
    643              CLIST* c_next=c->next;
    644              FreeContact(c);
    645              c=c_next;
    646            }
    647            *cl=NULL;
    648          }
    649          
    650          static int FindContact(CLIST* cl, CLIST* c)
    651          {
    652            CLIST* c_next=cl;
    653            
    654            while(c_next)
    655            {
    656              if (c_next == c)
    657                return (1);
    658              c_next=c_next->next;
    659            }
    660            return(0);
    661          }
    662          
    663          CLIST* FindContactById(CLIST* cl, int user_id)
    664          {
    665            CLIST* c=cl;
    666            
    667            while(c)
    668            {
    669              if (c->user_id==user_id)
    670                return c;
    671              c=c->next;
    672            }
    673            return(0);
    674          }
    675          
    676          static void CutContactFromList(CLIST** cl, CLIST* c)
    677          { 
    678            CLIST* c_prev=c->prev;
    679            CLIST* c_next=c->next;
    680            c->prev=0;
    681            c->next=0;
    682            if (c_prev)
    683              c_prev->next=c_next;
    684            else//если контакт был в топе
    685              *cl=c_next;
    686            if (c_next)
    687              c_next->prev=c_prev;
    688          }
    689          
    690          void DeleteContact(CLIST** cl, int user_id)
    691          {
    692            CLIST* c;
    693            
    694            if (c=FindContactById(*cl, user_id))
    695            {
    696              CutContactFromList(cl, c);
    697              FreeContact(c);
    698            }
    699          }
    700          
    701          void AddContactToList(CLIST** cl, CLIST* c)//добавление с сортировкой по дате
    702          {
    703            CLIST* c_next;
    704            CLIST* c_prev;
    705            
    706            if (*cl==NULL)
    707            {
    708              *cl=c;
    709              return;
    710            }
    711            
    712            if (FindContact(*cl, c))
    713            {
    714              if (c->next==NULL && c->prev==0)//если в списке только наш контакт
    715                return;
    716              else 
    717                CutContactFromList(cl, c);  
    718            }
    719            
    720            c_next=*cl;
    721            
    722            while (c_next)
    723            {
    724              if (c->msglist->date > c_next->msglist->date)//ищем сообщение с date меньше нашего
    725              {
    726                c_prev=c_next->prev;
    727                
    728                if (c_prev == 0)//непорядок-контакт с меньшим id сообщения в топе.
    729                  *cl=c;
    730                else
    731                  c_prev->next=c;
    732                c->next=c_next;
    733                c->prev=c_prev;
    734                c_next->prev=c;
    735                break;
    736              }
    737              else
    738                if (c_next->next==NULL)//не нашли,вставляем в конец списка
    739                {
    740                  c->next=0;
    741                  c->prev=c_next;
    742                  c_next->next=c;
    743                  break;
    744                }
    745              
    746              c_next=c_next->next;
    747            } 
    748          }
    749          
    750          
    751          CLIST* FindContactByN(CLIST* cl, int n)
    752          {
    753            CLIST* c;
    754            int i=0;
    755            
    756            c=cl;
    757            
    758            while(c)
    759            {
    760              if (i == n)
    761                break;
    762              i++;
    763              c=c->next;
    764            }
    765            return c;
    766          }
    767          
    768          int GetContactN(CLIST* cl, CLIST* c)
    769          {
    770            CLIST* c_next;
    771            int i=0;
    772            
    773            c_next=cl;
    774            
    775            while(c_next)
    776            {
    777              if (c_next == c)
    778                break;
    779              i++;
    780              c_next=c->next;
    781            }
    782            return i;
    783          }
    784          
    785          CLIST* FindLastContact(CLIST* cl)
    786          {
    787            CLIST* c=cl;
    788            
    789            if(c==NULL)
    790              return(0);
    791            
    792            while(c)
    793            {
    794              if (c->next == NULL)
    795                break;
    796              c=c->next;
    797            }
    798            
    799            return c;     
    800          }
    801          
    802          int CLIST_GetCount(CLIST* cl)
    803          {
    804            CLIST* c=cl;
    805            int count=0;
    806            
    807            if(c==NULL)
    808              return(0);
    809            
    810            while(c)
    811            {
    812              count++;
    813              c=c->next;
    814            }
    815            
    816            return count;  
    817          }
    818          
    819          
    820          char* create_noninfo_users_ids(CLIST* cl) 
    821          {
    822            int len_c=0;
    823            int len_s=0;
    824            char* s=NULL;
    825            char c[32];
    826            
    827            CLIST* user=cl;
    828            
    829            while (user)
    830            {
    831              if (user->first_name==NULL && user->user_id > 0)
    832              {
    833                sprintf(c, percent_d, user_id);
    834                len_c=strlen(c);
    835                if (s)
    836                  len_s=strlen(s);
    837                s=realloc(s, len_s+len_c+2);
    838                if (len_s)
    839                {
    840                  s[len_s]=',';
    841                  s[len_s+1]='\0';
    842                }
    843                strcat(s, c);
    844              }
    845              user=user->next;
    846            }
    847            
    848            return s;
    849          }
    850          */
    851          

   \                                 In segment CODE, align 4, keep-with-next
    852          char* create_noninfo_dialog_users_ids(LIST_HEAD *head) 
    853          {
   \                     create_noninfo_dialog_users_ids:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    854            char* s;
    855            char* s1;
    856            int i=0;
    857            
    858            struct list_head *iter;
    859            
    860            list_for_each(iter, head)
   \   00000008   005094E5           LDR      R5,[R4, #+0]
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   040055E1           CMP      R5,R4
   \   00000014   0700000A           BEQ      ??create_noninfo_dialog_users_ids_0
    861            {
    862              VkDialog *dialog = list_entry(iter, VkDialog, list);
    863              if (dialog->user == NULL)
   \                     ??create_noninfo_dialog_users_ids_1:
   \   00000018   1C1095E5           LDR      R1,[R5, #+28]
    864                i++;
    865            }
   \   0000001C   005095E5           LDR      R5,[R5, #+0]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   01008002           ADDEQ    R0,R0,#+1
   \   00000028   040055E1           CMP      R5,R4
   \   0000002C   F9FFFF1A           BNE      ??create_noninfo_dialog_users_ids_1
    866           
    867            if (i == 0)
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0100001A           BNE      ??create_noninfo_dialog_users_ids_2
    868              return NULL;
   \                     ??create_noninfo_dialog_users_ids_0:
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   F080BDE8           POP      {R4-R7,PC}
    869            
    870            s=malloc(16 * i);
   \                     ??create_noninfo_dialog_users_ids_2:
   \   00000040   0002A0E1           LSL      R0,R0,#+4
   \   00000044   140000EF           SWI      +20
    871            s1=s;
    872            
    873            list_for_each(iter, head)
   \   00000048   005094E5           LDR      R5,[R4, #+0]
   \   0000004C   0060A0E1           MOV      R6,R0
   \   00000050   0670A0E1           MOV      R7,R6
   \   00000054   040055E1           CMP      R5,R4
   \   00000058   0F00000A           BEQ      ??create_noninfo_dialog_users_ids_3
    874            {
    875              VkDialog *dialog = list_entry(iter, VkDialog, list);
    876              if (dialog->user == NULL)
   \                     ??create_noninfo_dialog_users_ids_4:
   \   0000005C   1C0095E5           LDR      R0,[R5, #+28]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0900001A           BNE      ??create_noninfo_dialog_users_ids_5
    877              {
    878                VkMsg *msg = get_DialogMsg(dialog);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           BL       get_DialogMsg
    879                int user_id;
    880                if (msg->out == 0)
   \   00000070   1C1090E5           LDR      R1,[R0, #+28]
   \   00000074   000051E3           CMP      R1,#+0
    881                  user_id = msg->from_id;
   \   00000078   10209005           LDREQ    R2,[R0, #+16]
    882                else
    883                  user_id = msg->peer_id;
    884                s1 += sprintf(s1, percent_d, user_id);
   \   0000007C   20109FE5           LDR      R1,??create_noninfo_dialog_users_ids_6  ;; percent_d
   \   00000080   14209015           LDRNE    R2,[R0, #+20]
   \   00000084   0700A0E1           MOV      R0,R7
   \   00000088   160000EF           SWI      +22
   \   0000008C   077080E0           ADD      R7,R0,R7
    885              }    
    886            }
   \                     ??create_noninfo_dialog_users_ids_5:
   \   00000090   005095E5           LDR      R5,[R5, #+0]
   \   00000094   040055E1           CMP      R5,R4
   \   00000098   EFFFFF1A           BNE      ??create_noninfo_dialog_users_ids_4
    887            
    888            return s;
   \                     ??create_noninfo_dialog_users_ids_3:
   \   0000009C   0600A0E1           MOV      R0,R6
   \   000000A0   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??create_noninfo_dialog_users_ids_6:
   \   000000A4   ........           DC32     percent_d
    889          }

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for dialogs>`:
   \   00000000   ............       DC32 dialogs, dialogs
   \              ....        

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for my_groups>`:
   \   00000000   ............       DC32 my_groups, my_groups
   \              ....        

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for friends>`:
   \   00000000   ............       DC32 friends, friends
   \              ....        

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for profiles>`:
   \   00000000   ............       DC32 profiles, profiles
   \              ....        

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for groups>`:
   \   00000000   ............       DC32 groups, groups
   \              ....        
    890          //******************************************************************************
    891          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     CreateWS_emoji                    16
     FindDialog                         0
     FreeWALL                          16
     _del_Profiles                     12
     count_ListElements                 0
     create_noninfo_dialog_users_ids
                                       20
     del_Dialogs                       16
     del_Group                          8
     del_Groups                        12
     del_Message                        8
     del_Messages                      12
     del_Profiles                      12
     del_User                           8
     del_attachments                   12
     del_wall_attachments              16
     find_Group                         0
     find_User                          0
     get_DialogMsg                      0
     get_ListByIndex                    0
     new_Dialog                        16
     new_Group                         12
     new_Message                       16
     new_User                          12
     utf8_2ws_emoji                    12


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     dialogs                           8
     my_groups                         8
     friends                           8
     profiles                          8
     groups                            8
     percent_d                         4
     CreateWS_emoji                  120
     utf8_2ws_emoji                   40
     new_User                        144
     find_User                        48
     del_User                        124
     del_wall_attachments             76
     _del_Profiles                    48
     FreeWALL                        140
     del_Profiles                     60
     del_attachments                  56
     new_Message                     144
     del_Message                      64
     del_Messages                     56
     new_Group                       152
     find_Group                       48
     del_Group                       124
     del_Groups                       60
     new_Dialog                      108
     FindDialog                       92
     get_DialogMsg                    28
     del_Dialogs                     144
     count_ListElements               40
     get_ListByIndex                  52
     create_noninfo_dialog_users_ids
                                     168
     ?<Initializer for dialogs>        8
     ?<Initializer for my_groups>      8
     ?<Initializer for friends>        8
     ?<Initializer for profiles>       8
     ?<Initializer for groups>         8
      Others                         132

 
 2 256 bytes in segment CODE
     4 bytes in segment DATA_C
    40 bytes in segment DATA_I
    40 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 2 136 bytes of CODE  memory (+ 132 bytes shared)
    44 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: 1
