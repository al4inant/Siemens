##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    17/Nov/2019  22:06:55 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\openssl\crypto\aes\aes_ctr.c                       #
#    Command line    =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\openssl\crypto\aes\aes_ctr.c -D NEWSGOLD -D DEBUG  #
#                       -lCN E:\Users\alfinant7\Documents\Siemens\alfinant\s #
#                       rc_iar\VK.ELF_C\Releas_NSG\List\ -la                 #
#                       E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\List\ -o                       #
#                       E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\Obj\ -z9 --cpu_mode arm        #
#                       --endian little --cpu ARM926EJ-S --stack_align 4     #
#                       --interwork --diag_suppress Pe301 -e --fpu None      #
#                       --dlib_config E:\Users\alfinant7\Documents\Siemens\I #
#                       AR\ARM\LIB\dl5tpainl8n.h -I                          #
#                       E:\Users\alfinant7\Documents\Siemens\IAR\ARM\INC\    #
#                       --inline_threshold=2                                 #
#    List file       =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\List\aes_ctr.lst               #
#    Object file     =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\Obj\aes_ctr.r79                #
#                                                                            #
#                                                                            #
##############################################################################

E:\Users\alfinant7\Documents\Siemens\alfinant\src_iar\openssl\crypto\aes\aes_ctr.c
      1          /* crypto/aes/aes_ctr.c -*- mode:C; c-file-style: "eay" -*- */
      2          /* ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          
     52          #ifndef AES_DEBUG
     53          # ifndef NDEBUG
     54          #  define NDEBUG
     55          # endif
     56          #endif
     57          #include <assert.h>
     58          
     59          #include <openssl/aes.h>
     60          #include "aes_locl.h"
     61          
     62          /* NOTE: the IV/counter CTR mode is big-endian.  The rest of the AES code
     63           * is endian-neutral. */
     64          
     65          /* increment counter (128-bit int) by 1 */

   \                                 In segment CODE, align 4, keep-with-next
     66          static void AES_ctr128_inc(unsigned char *counter) {
     67          	unsigned long c;
     68          
     69          	/* Grab bottom dword of counter and increment */
     70          	c = GETU32(counter + 12);
     71          	c++;	c &= 0xFFFFFFFF;
   \                     AES_ctr128_inc:
   \   00000000   0C10D0E5           LDRB     R1,[R0, #+12]
   \   00000004   0D20D0E5           LDRB     R2,[R0, #+13]
   \   00000008   0228A0E1           LSL      R2,R2,#+16
   \   0000000C   011C22E0           EOR      R1,R2,R1, LSL #+24
   \   00000010   0E20D0E5           LDRB     R2,[R0, #+14]
   \   00000014   021421E0           EOR      R1,R1,R2, LSL #+8
   \   00000018   0F20D0E5           LDRB     R2,[R0, #+15]
   \   0000001C   011022E0           EOR      R1,R2,R1
   \   00000020   011081E2           ADD      R1,R1,#+1
     72          	PUTU32(counter + 12, c);
   \   00000024   212CA0E1           LSR      R2,R1,#+24
   \   00000028   0C20C0E5           STRB     R2,[R0, #+12]
   \   0000002C   2128A0E1           LSR      R2,R1,#+16
   \   00000030   0D20C0E5           STRB     R2,[R0, #+13]
   \   00000034   2124A0E1           LSR      R2,R1,#+8
   \   00000038   0E20C0E5           STRB     R2,[R0, #+14]
   \   0000003C   0F10C0E5           STRB     R1,[R0, #+15]
     73          
     74          	/* if no overflow, we're done */
     75          	if (c)
   \   00000040   000051E3           CMP      R1,#+0
   \   00000044   1EFF2F11           BXNE     LR
     76          		return;
     77          
     78          	/* Grab 1st dword of counter and increment */
     79          	c = GETU32(counter +  8);
     80          	c++;	c &= 0xFFFFFFFF;
   \   00000048   0810D0E5           LDRB     R1,[R0, #+8]
   \   0000004C   0920D0E5           LDRB     R2,[R0, #+9]
   \   00000050   0228A0E1           LSL      R2,R2,#+16
   \   00000054   011C22E0           EOR      R1,R2,R1, LSL #+24
   \   00000058   0A20D0E5           LDRB     R2,[R0, #+10]
   \   0000005C   021421E0           EOR      R1,R1,R2, LSL #+8
   \   00000060   0B20D0E5           LDRB     R2,[R0, #+11]
   \   00000064   011022E0           EOR      R1,R2,R1
   \   00000068   011081E2           ADD      R1,R1,#+1
     81          	PUTU32(counter +  8, c);
   \   0000006C   212CA0E1           LSR      R2,R1,#+24
   \   00000070   0820C0E5           STRB     R2,[R0, #+8]
   \   00000074   2128A0E1           LSR      R2,R1,#+16
   \   00000078   0920C0E5           STRB     R2,[R0, #+9]
   \   0000007C   2124A0E1           LSR      R2,R1,#+8
   \   00000080   0A20C0E5           STRB     R2,[R0, #+10]
   \   00000084   0B10C0E5           STRB     R1,[R0, #+11]
     82          
     83          	/* if no overflow, we're done */
     84          	if (c)
   \   00000088   000051E3           CMP      R1,#+0
   \   0000008C   1EFF2F11           BXNE     LR
     85          		return;
     86          
     87          	/* Grab 2nd dword of counter and increment */
     88          	c = GETU32(counter +  4);
     89          	c++;	c &= 0xFFFFFFFF;
   \   00000090   0410D0E5           LDRB     R1,[R0, #+4]
   \   00000094   0520D0E5           LDRB     R2,[R0, #+5]
   \   00000098   0228A0E1           LSL      R2,R2,#+16
   \   0000009C   011C22E0           EOR      R1,R2,R1, LSL #+24
   \   000000A0   0620D0E5           LDRB     R2,[R0, #+6]
   \   000000A4   021421E0           EOR      R1,R1,R2, LSL #+8
   \   000000A8   0720D0E5           LDRB     R2,[R0, #+7]
   \   000000AC   011022E0           EOR      R1,R2,R1
   \   000000B0   011081E2           ADD      R1,R1,#+1
     90          	PUTU32(counter +  4, c);
   \   000000B4   212CA0E1           LSR      R2,R1,#+24
   \   000000B8   0420C0E5           STRB     R2,[R0, #+4]
   \   000000BC   2128A0E1           LSR      R2,R1,#+16
   \   000000C0   0520C0E5           STRB     R2,[R0, #+5]
   \   000000C4   2124A0E1           LSR      R2,R1,#+8
   \   000000C8   0620C0E5           STRB     R2,[R0, #+6]
   \   000000CC   0710C0E5           STRB     R1,[R0, #+7]
     91          
     92          	/* if no overflow, we're done */
     93          	if (c)
   \   000000D0   000051E3           CMP      R1,#+0
   \   000000D4   1EFF2F11           BXNE     LR
     94          		return;
     95          
     96          	/* Grab top dword of counter and increment */
     97          	c = GETU32(counter +  0);
     98          	c++;	c &= 0xFFFFFFFF;
   \   000000D8   0010D0E5           LDRB     R1,[R0, #+0]
   \   000000DC   0120D0E5           LDRB     R2,[R0, #+1]
   \   000000E0   0228A0E1           LSL      R2,R2,#+16
   \   000000E4   011C22E0           EOR      R1,R2,R1, LSL #+24
   \   000000E8   0220D0E5           LDRB     R2,[R0, #+2]
   \   000000EC   021421E0           EOR      R1,R1,R2, LSL #+8
   \   000000F0   0320D0E5           LDRB     R2,[R0, #+3]
   \   000000F4   011022E0           EOR      R1,R2,R1
   \   000000F8   011081E2           ADD      R1,R1,#+1
     99          	PUTU32(counter +  0, c);
   \   000000FC   212CA0E1           LSR      R2,R1,#+24
   \   00000100   0020C0E5           STRB     R2,[R0, #+0]
   \   00000104   2128A0E1           LSR      R2,R1,#+16
   \   00000108   0120C0E5           STRB     R2,[R0, #+1]
   \   0000010C   2124A0E1           LSR      R2,R1,#+8
   \   00000110   0220C0E5           STRB     R2,[R0, #+2]
   \   00000114   0310C0E5           STRB     R1,[R0, #+3]
    100          }
   \   00000118   1EFF2FE1           BX       LR               ;; return
    101          
    102          /* The input encrypted as though 128bit counter mode is being
    103           * used.  The extra state information to record how much of the
    104           * 128bit block we have used is contained in *num, and the
    105           * encrypted counter is kept in ecount_buf.  Both *num and
    106           * ecount_buf must be initialised with zeros before the first
    107           * call to AES_ctr128_encrypt().
    108           *
    109           * This algorithm assumes that the counter is in the x lower bits
    110           * of the IV (ivec), and that the application has full control over
    111           * overflow and the rest of the IV.  This implementation takes NO
    112           * responsability for checking that the counter doesn't overflow
    113           * into the rest of the IV when incremented.
    114           */

   \                                 In segment CODE, align 4, keep-with-next
    115          void AES_ctr128_encrypt(const unsigned char *in, unsigned char *out,
    116          	const unsigned long length, const AES_KEY *key,
    117          	unsigned char ivec[AES_BLOCK_SIZE],
    118          	unsigned char ecount_buf[AES_BLOCK_SIZE],
    119          	unsigned int *num) {
   \                     AES_ctr128_encrypt:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   2C909DE5           LDR      R9,[SP, #+44]
   \   00000008   24709DE5           LDR      R7,[SP, #+36]
   \   0000000C   28809DE5           LDR      R8,[SP, #+40]
    120          
    121          	unsigned int n;
    122          	unsigned long l=length;
    123          
    124          	assert(in && out && key && counter && num);
    125          	assert(*num < AES_BLOCK_SIZE);
    126          
    127          	n = *num;
   \   00000010   00A099E5           LDR      R10,[R9, #+0]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   02B0A0E1           MOV      R11,R2
   \   00000020   0360A0E1           MOV      R6,R3
   \   00000024   0D0000EA           B        ??AES_ctr128_encrypt_0
    128          
    129          	while (l--) {
    130          		if (n == 0) {
   \                     ??AES_ctr128_encrypt_1:
   \   00000028   00005AE3           CMP      R10,#+0
   \   0000002C   0500001A           BNE      ??AES_ctr128_encrypt_2
    131          			AES_encrypt(ivec, ecount_buf, key);
   \   00000030   0620A0E1           MOV      R2,R6
   \   00000034   0810A0E1           MOV      R1,R8
   \   00000038   0700A0E1           MOV      R0,R7
   \   0000003C   ........           _BLF     AES_encrypt,??AES_encrypt??rA
    132           			AES_ctr128_inc(ivec);
   \   00000040   0700A0E1           MOV      R0,R7
   \   00000044   ........           BL       AES_ctr128_inc
    133          		}
    134          		*(out++) = *(in++) ^ ecount_buf[n];
   \                     ??AES_ctr128_encrypt_2:
   \   00000048   ........           LDRB     R0,[R4], #+1
   \   0000004C   0810DAE7           LDRB     R1,[R10, +R8]
   \   00000050   000021E0           EOR      R0,R1,R0
   \   00000054   ........           STRB     R0,[R5], #+1
    135          		n = (n+1) % AES_BLOCK_SIZE;
   \   00000058   01008AE2           ADD      R0,R10,#+1
   \   0000005C   0FA000E2           AND      R10,R0,#0xF
    136          	}
   \                     ??AES_ctr128_encrypt_0:
   \   00000060   0B00A0E1           MOV      R0,R11
   \   00000064   01B040E2           SUB      R11,R0,#+1
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   EDFFFF1A           BNE      ??AES_ctr128_encrypt_1
    137          
    138          	*num=n;
   \   00000070   00A089E5           STR      R10,[R9, #+0]
    139          }
   \   00000074   F08FBDE8           POP      {R4-R11,PC}      ;; return

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     AES_ctr128_encrypt    36
     AES_ctr128_inc         0


   Segment part sizes:

     Function/Label     Bytes
     --------------     -----
     AES_ctr128_inc      284
     AES_ctr128_encrypt  120
      Others              20

 
 424 bytes in segment CODE
 
 404 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
