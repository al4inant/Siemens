##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    17/Nov/2019  22:06:58 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\openssl\crypto\aes\aes_cfb.c                       #
#    Command line    =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\openssl\crypto\aes\aes_cfb.c -D NEWSGOLD -D DEBUG  #
#                       -lCN E:\Users\alfinant7\Documents\Siemens\alfinant\s #
#                       rc_iar\VK.ELF_C\Releas_NSG\List\ -la                 #
#                       E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\List\ -o                       #
#                       E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\Obj\ -z9 --cpu_mode arm        #
#                       --endian little --cpu ARM926EJ-S --stack_align 4     #
#                       --interwork --diag_suppress Pe301 -e --fpu None      #
#                       --dlib_config E:\Users\alfinant7\Documents\Siemens\I #
#                       AR\ARM\LIB\dl5tpainl8n.h -I                          #
#                       E:\Users\alfinant7\Documents\Siemens\IAR\ARM\INC\    #
#                       --inline_threshold=2                                 #
#    List file       =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\List\aes_cfb.lst               #
#    Object file     =  E:\Users\alfinant7\Documents\Siemens\alfinant\src_ia #
#                       r\VK.ELF_C\Releas_NSG\Obj\aes_cfb.r79                #
#                                                                            #
#                                                                            #
##############################################################################

E:\Users\alfinant7\Documents\Siemens\alfinant\src_iar\openssl\crypto\aes\aes_cfb.c
      1          /* crypto/aes/aes_cfb.c -*- mode:C; c-file-style: "eay" -*- */
      2          /* ====================================================================
      3           * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           *
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer. 
     11           *
     12           * 2. Redistributions in binary form must reproduce the above copyright
     13           *    notice, this list of conditions and the following disclaimer in
     14           *    the documentation and/or other materials provided with the
     15           *    distribution.
     16           *
     17           * 3. All advertising materials mentioning features or use of this
     18           *    software must display the following acknowledgment:
     19           *    "This product includes software developed by the OpenSSL Project
     20           *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
     21           *
     22           * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
     23           *    endorse or promote products derived from this software without
     24           *    prior written permission. For written permission, please contact
     25           *    openssl-core@openssl.org.
     26           *
     27           * 5. Products derived from this software may not be called "OpenSSL"
     28           *    nor may "OpenSSL" appear in their names without prior written
     29           *    permission of the OpenSSL Project.
     30           *
     31           * 6. Redistributions of any form whatsoever must retain the following
     32           *    acknowledgment:
     33           *    "This product includes software developed by the OpenSSL Project
     34           *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
     35           *
     36           * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
     37           * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     38           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     39           * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
     40           * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     41           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     42           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     43           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     44           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     45           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     46           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     47           * OF THE POSSIBILITY OF SUCH DAMAGE.
     48           * ====================================================================
     49           *
     50           */
     51          /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
     52           * All rights reserved.
     53           *
     54           * This package is an SSL implementation written
     55           * by Eric Young (eay@cryptsoft.com).
     56           * The implementation was written so as to conform with Netscapes SSL.
     57           * 
     58           * This library is free for commercial and non-commercial use as long as
     59           * the following conditions are aheared to.  The following conditions
     60           * apply to all code found in this distribution, be it the RC4, RSA,
     61           * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
     62           * included with this distribution is covered by the same copyright terms
     63           * except that the holder is Tim Hudson (tjh@cryptsoft.com).
     64           * 
     65           * Copyright remains Eric Young's, and as such any Copyright notices in
     66           * the code are not to be removed.
     67           * If this package is used in a product, Eric Young should be given attribution
     68           * as the author of the parts of the library used.
     69           * This can be in the form of a textual message at program startup or
     70           * in documentation (online or textual) provided with the package.
     71           * 
     72           * Redistribution and use in source and binary forms, with or without
     73           * modification, are permitted provided that the following conditions
     74           * are met:
     75           * 1. Redistributions of source code must retain the copyright
     76           *    notice, this list of conditions and the following disclaimer.
     77           * 2. Redistributions in binary form must reproduce the above copyright
     78           *    notice, this list of conditions and the following disclaimer in the
     79           *    documentation and/or other materials provided with the distribution.
     80           * 3. All advertising materials mentioning features or use of this software
     81           *    must display the following acknowledgement:
     82           *    "This product includes cryptographic software written by
     83           *     Eric Young (eay@cryptsoft.com)"
     84           *    The word 'cryptographic' can be left out if the rouines from the library
     85           *    being used are not cryptographic related :-).
     86           * 4. If you include any Windows specific code (or a derivative thereof) from 
     87           *    the apps directory (application code) you must include an acknowledgement:
     88           *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
     89           * 
     90           * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
     91           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     92           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     93           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
     94           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     95           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     96           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     97           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     98           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     99           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    100           * SUCH DAMAGE.
    101           * 
    102           * The licence and distribution terms for any publically available version or
    103           * derivative of this code cannot be changed.  i.e. this code cannot simply be
    104           * copied and put under another distribution licence
    105           * [including the GNU Public Licence.]
    106           */
    107          
    108          #ifndef AES_DEBUG
    109          # ifndef NDEBUG
    110          #  define NDEBUG
    111          # endif
    112          #endif
    113          #include <assert.h>
    114          
    115          #include <siemens/swilib.h>
    116          
    117          #include <openssl/aes.h>
    118          #include "aes_locl.h"
    119          //#include <openssl/e_os.h>
    120          
    121          /* The input and output encrypted as though 128bit cfb mode is being
    122           * used.  The extra state information to record how much of the
    123           * 128bit block we have used is contained in *num;
    124           */
    125          

   \                                 In segment CODE, align 4, keep-with-next
    126          void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,
    127          	const unsigned long length, const AES_KEY *key,
    128          	unsigned char *ivec, int *num, const int enc) {
   \                     AES_cfb128_encrypt:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   24809DE5           LDR      R8,[SP, #+36]
   \   00000008   20709DE5           LDR      R7,[SP, #+32]
    129          
    130          	unsigned int n;
    131          	unsigned long l = length;
    132          	unsigned char c;
    133          
    134          	assert(in && out && key && ivec && num);
    135          
    136          	n = *num;
   \   0000000C   009098E5           LDR      R9,[R8, #+0]
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   28009DE5           LDR      R0,[SP, #+40]
   \   00000018   0150A0E1           MOV      R5,R1
   \   0000001C   02A0A0E1           MOV      R10,R2
   \   00000020   0360A0E1           MOV      R6,R3
    137          
    138          	if (enc) {
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   2100000A           BEQ      ??AES_cfb128_encrypt_0
    139          		while (l--) {
   \                     ??AES_cfb128_encrypt_1:
   \   0000002C   0A00A0E1           MOV      R0,R10
   \   00000030   01A040E2           SUB      R10,R0,#+1
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   2100000A           BEQ      ??AES_cfb128_encrypt_2
    140          			if (n == 0) {
   \   0000003C   000059E3           CMP      R9,#+0
   \   00000040   0300001A           BNE      ??AES_cfb128_encrypt_3
    141          				AES_encrypt(ivec, ivec, key);
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0710A0E1           MOV      R1,R7
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   ........           _BLF     AES_encrypt,??AES_encrypt??rA
    142          			}
    143          			ivec[n] = *(out++) = *(in++) ^ ivec[n];
   \                     ??AES_cfb128_encrypt_3:
   \   00000054   ........           LDRB     R1,[R4], #+1
   \   00000058   070089E0           ADD      R0,R9,R7
   \   0000005C   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000060   011022E0           EOR      R1,R2,R1
   \   00000064   ........           STRB     R1,[R5], #+1
   \   00000068   0010C0E5           STRB     R1,[R0, #+0]
    144          			n = (n+1) % AES_BLOCK_SIZE;
   \   0000006C   010089E2           ADD      R0,R9,#+1
   \   00000070   0F9000E2           AND      R9,R0,#0xF
   \   00000074   ECFFFFEA           B        ??AES_cfb128_encrypt_1
    145          		}
    146          	} else {
    147          		while (l--) {
    148          			if (n == 0) {
   \                     ??AES_cfb128_encrypt_4:
   \   00000078   000059E3           CMP      R9,#+0
   \   0000007C   0300001A           BNE      ??AES_cfb128_encrypt_5
    149          				AES_encrypt(ivec, ivec, key);
   \   00000080   0620A0E1           MOV      R2,R6
   \   00000084   0710A0E1           MOV      R1,R7
   \   00000088   0700A0E1           MOV      R0,R7
   \   0000008C   ........           _BLF     AES_encrypt,??AES_encrypt??rA
    150          			}
    151          			c = *(in);
   \                     ??AES_cfb128_encrypt_5:
   \   00000090   0000D4E5           LDRB     R0,[R4, #+0]
    152          			*(out++) = *(in++) ^ ivec[n];
   \   00000094   ........           LDRB     R2,[R4], #+1
   \   00000098   071089E0           ADD      R1,R9,R7
   \   0000009C   0030D1E5           LDRB     R3,[R1, #+0]
   \   000000A0   022023E0           EOR      R2,R3,R2
   \   000000A4   ........           STRB     R2,[R5], #+1
    153          			ivec[n] = c;
   \   000000A8   0000C1E5           STRB     R0,[R1, #+0]
    154          			n = (n+1) % AES_BLOCK_SIZE;
   \   000000AC   010089E2           ADD      R0,R9,#+1
   \   000000B0   0F9000E2           AND      R9,R0,#0xF
    155          		}
   \                     ??AES_cfb128_encrypt_0:
   \   000000B4   0A00A0E1           MOV      R0,R10
   \   000000B8   01A040E2           SUB      R10,R0,#+1
   \   000000BC   000050E3           CMP      R0,#+0
   \   000000C0   ECFFFF1A           BNE      ??AES_cfb128_encrypt_4
    156          	}
    157          
    158          	*num=n;
   \                     ??AES_cfb128_encrypt_2:
   \   000000C4   009088E5           STR      R9,[R8, #+0]
    159          }
   \   000000C8   F087BDE8           POP      {R4-R10,PC}      ;; return
    160          
    161          /* This expects a single block of size nbits for both in and out. Note that
    162             it corrupts any extra bits in the last byte of out */

   \                                 In segment CODE, align 4, keep-with-next
    163          void AES_cfbr_encrypt_block(const unsigned char *in,unsigned char *out,
    164          			    const int nbits,const AES_KEY *key,
    165          			    unsigned char *ivec,const int enc)
    166              {
   \                     AES_cfbr_encrypt_block:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   20D04DE2           SUB      SP,SP,#+32
   \   00000008   3C509DE5           LDR      R5,[SP, #+60]
   \   0000000C   40809DE5           LDR      R8,[SP, #+64]
   \   00000010   0060A0E1           MOV      R6,R0
   \   00000014   0170A0E1           MOV      R7,R1
   \   00000018   0240A0E1           MOV      R4,R2
   \   0000001C   0390A0E1           MOV      R9,R3
    167              int n,rem,num;
    168              unsigned char ovec[AES_BLOCK_SIZE*2];
    169          
    170              if (nbits<=0 || nbits>128) return;
   \   00000020   010054E3           CMP      R4,#+1
   \   00000024   3F0000BA           BLT      ??AES_cfbr_encrypt_block_0
   \   00000028   810054E3           CMP      R4,#+129
   \   0000002C   3D0000AA           BGE      ??AES_cfbr_encrypt_block_0
    171          
    172          	/* fill in the first half of the new IV with the current IV */
    173          	memcpy(ovec,ivec,AES_BLOCK_SIZE);
   \   00000030   1020A0E3           MOV      R2,#+16
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   0D00A0E1           MOV      R0,SP
   \   0000003C   1E0100EF           SWI      +286
    174          	/* construct the new IV */
    175          	AES_encrypt(ivec,ivec,key);
   \   00000040   0920A0E1           MOV      R2,R9
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           _BLF     AES_encrypt,??AES_encrypt??rA
    176          	num = (nbits+7)/8;
   \   00000050   070084E2           ADD      R0,R4,#+7
   \   00000054   4011A0E1           ASR      R1,R0,#+2
   \   00000058   A10E80E0           ADD      R0,R0,R1, LSR #+29
   \   0000005C   C011A0E1           ASR      R1,R0,#+3
    177          	if (enc)	/* encrypt the input */
   \   00000060   000058E3           CMP      R8,#+0
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   1200000A           BEQ      ??AES_cfbr_encrypt_block_1
    178          	    for(n=0 ; n < num ; ++n)
   \                     ??AES_cfbr_encrypt_block_2:
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   120000AA           BGE      ??AES_cfbr_encrypt_block_3
    179          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n] ^ ivec[n]);
   \   00000074   0620D0E7           LDRB     R2,[R0, +R6]
   \   00000078   0530D0E7           LDRB     R3,[R0, +R5]
   \   0000007C   022023E0           EOR      R2,R3,R2
   \   00000080   0D30A0E1           MOV      R3,SP
   \   00000084   033080E0           ADD      R3,R0,R3
   \   00000088   1020C3E5           STRB     R2,[R3, #+16]
   \   0000008C   0720C0E7           STRB     R2,[R0, +R7]
   \   00000090   010080E2           ADD      R0,R0,#+1
   \   00000094   F4FFFFEA           B        ??AES_cfbr_encrypt_block_2
    180          	else		/* decrypt the input */
    181          	    for(n=0 ; n < num ; ++n)
    182          		out[n] = (ovec[AES_BLOCK_SIZE+n] = in[n]) ^ ivec[n];
   \                     ??AES_cfbr_encrypt_block_4:
   \   00000098   0620D0E7           LDRB     R2,[R0, +R6]
   \   0000009C   0D30A0E1           MOV      R3,SP
   \   000000A0   033080E0           ADD      R3,R0,R3
   \   000000A4   1020C3E5           STRB     R2,[R3, #+16]
   \   000000A8   0530D0E7           LDRB     R3,[R0, +R5]
   \   000000AC   022023E0           EOR      R2,R3,R2
   \   000000B0   0720C0E7           STRB     R2,[R0, +R7]
   \   000000B4   010080E2           ADD      R0,R0,#+1
   \                     ??AES_cfbr_encrypt_block_1:
   \   000000B8   010050E1           CMP      R0,R1
   \   000000BC   F5FFFFBA           BLT      ??AES_cfbr_encrypt_block_4
    183          	/* shift ovec left... */
    184          	rem = nbits%8;
   \                     ??AES_cfbr_encrypt_block_3:
   \   000000C0   4401A0E1           ASR      R0,R4,#+2
   \   000000C4   A00E84E0           ADD      R0,R4,R0, LSR #+29
   \   000000C8   C011A0E1           ASR      R1,R0,#+3
   \   000000CC   812154E0           SUBS     R2,R4,R1, LSL #+3
    185          	num = nbits/8;
    186          	if(rem==0)
   \   000000D0   0500001A           BNE      ??AES_cfbr_encrypt_block_5
    187          	    memcpy(ivec,ovec+num,AES_BLOCK_SIZE);
   \   000000D4   1020A0E3           MOV      R2,#+16
   \   000000D8   0D00A0E1           MOV      R0,SP
   \   000000DC   001081E0           ADD      R1,R1,R0
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   1E0100EF           SWI      +286
   \   000000E8   0E0000EA           B        ??AES_cfbr_encrypt_block_0
    188          	else
    189          	    for(n=0 ; n < AES_BLOCK_SIZE ; ++n)
   \                     ??AES_cfbr_encrypt_block_5:
   \   000000EC   0000A0E3           MOV      R0,#+0
    190          		ivec[n] = ovec[n+num]<<rem | ovec[n+num+1]>>(8-rem);
   \                     ??AES_cfbr_encrypt_block_6:
   \   000000F0   003081E0           ADD      R3,R1,R0
   \   000000F4   0D40A0E1           MOV      R4,SP
   \   000000F8   043083E0           ADD      R3,R3,R4
   \   000000FC   0040D3E5           LDRB     R4,[R3, #+0]
   \   00000100   0130D3E5           LDRB     R3,[R3, #+1]
   \   00000104   0260A0E1           MOV      R6,R2
   \   00000108   1442A0E1           LSL      R4,R4,R2
   \   0000010C   086066E2           RSB      R6,R6,#+8
   \   00000110   5336A0E1           ASR      R3,R3,R6
   \   00000114   043083E1           ORR      R3,R3,R4
   \   00000118   0530C0E7           STRB     R3,[R0, +R5]
   \   0000011C   010080E2           ADD      R0,R0,#+1
   \   00000120   100050E3           CMP      R0,#+16
   \   00000124   F1FFFFBA           BLT      ??AES_cfbr_encrypt_block_6
   \                     ??AES_cfbr_encrypt_block_0:
   \   00000128   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   0000012C   F083BDE8           POP      {R4-R9,PC}       ;; return
    191          
    192              /* it is not necessary to cleanse ovec, since the IV is not secret */
    193              }
    194          
    195          /* N.B. This expects the input to be packed, MS bit first */

   \                                 In segment CODE, align 4, keep-with-next
    196          void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,
    197          		      const unsigned long length, const AES_KEY *key,
    198          		      unsigned char *ivec, int *num, const int enc)
    199              {
   \                     AES_cfb1_encrypt:
   \   00000000   FB4F2DE9           PUSH     {R0,R1,R3-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   38509DE5           LDR      R5,[SP, #+56]
   \   0000000C   40609DE5           LDR      R6,[SP, #+64]
   \   00000010   0240A0E1           MOV      R4,R2
    200              unsigned int n;
    201              unsigned char c[1],d[1];
    202          
    203              assert(in && out && key && ivec && num);
    204              assert(*num == 0);
    205          
    206              memset(out,0,(length+7)/8);
   \   00000014   070084E2           ADD      R0,R4,#+7
   \   00000018   A021A0E1           LSR      R2,R0,#+3
   \   0000001C   0C009DE5           LDR      R0,[SP, #+12]
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   BB0000EF           SWI      +187
    207              for(n=0 ; n < length ; ++n)
   \   00000028   0070A0E3           MOV      R7,#+0
   \   0000002C   0080A0E3           MOV      R8,#+0
   \   00000030   120000EA           B        ??AES_cfb1_encrypt_0
    208          	{
    209          	c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
    210          	AES_cfbr_encrypt_block(c,d,1,key,ivec,enc);
   \                     ??AES_cfb1_encrypt_1:
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   0120A0E3           MOV      R2,#+1
    211          	out[n/8]=(out[n/8]&~(1 << (7-n%8)))|((d[0]&0x80) >> (n%8));
   \   00000040   018088E2           ADD      R8,R8,#+1
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   01002DE9           PUSH     {R0}
   \   0000004C   18309DE5           LDR      R3,[SP, #+24]
   \   00000050   09108DE2           ADD      R1,SP,#+9
   \   00000054   08008DE2           ADD      R0,SP,#+8
   \   00000058   ........           BL       AES_cfbr_encrypt_block
   \   0000005C   14009DE5           LDR      R0,[SP, #+20]
   \   00000060   0920DDE5           LDRB     R2,[SP, #+9]
   \   00000064   00008BE0           ADD      R0,R11,R0
   \   00000068   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000006C   802002E2           AND      R2,R2,#0x80
   \   00000070   0910C1E1           BIC      R1,R1,R9
   \   00000074   321A81E1           ORR      R1,R1,R2, LSR R10
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
   \   0000007C   08D08DE2           ADD      SP,SP,#+8
   \                     ??AES_cfb1_encrypt_0:
   \   00000080   040058E1           CMP      R8,R4
   \   00000084   0B00002A           BCS      ??AES_cfb1_encrypt_2
   \   00000088   07A008E2           AND      R10,R8,#0x7
   \   0000008C   0100A0E3           MOV      R0,#+1
   \   00000090   07106AE2           RSB      R1,R10,#+7
   \   00000094   1091A0E1           LSL      R9,R0,R1
   \   00000098   08009DE5           LDR      R0,[SP, #+8]
   \   0000009C   A8B1A0E1           LSR      R11,R8,#+3
   \   000000A0   0000DBE7           LDRB     R0,[R11, +R0]
   \   000000A4   000019E1           TST      R9,R0
   \   000000A8   0070CD05           STRBEQ   R7,[SP, #+0]
   \   000000AC   8010A013           MOVNE    R1,#+128
   \   000000B0   0010CD15           STRBNE   R1,[SP, #+0]
   \   000000B4   DEFFFFEA           B        ??AES_cfb1_encrypt_1
    212          	}
    213              }
   \                     ??AES_cfb1_encrypt_2:
   \   000000B8   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   000000BC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    214          

   \                                 In segment CODE, align 4, keep-with-next
    215          void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,
    216          		      const unsigned long length, const AES_KEY *key,
    217          		      unsigned char *ivec, int *num, const int enc)
    218              {
   \                     AES_cfb8_encrypt:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20809DE5           LDR      R8,[SP, #+32]
   \   00000008   28909DE5           LDR      R9,[SP, #+40]
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
    219              unsigned int n;
    220          
    221              assert(in && out && key && ivec && num);
    222              assert(*num == 0);
    223          
    224              for(n=0 ; n < length ; ++n)
   \   0000001C   00A0A0E3           MOV      R10,#+0
   \   00000020   0A0000EA           B        ??AES_cfb8_encrypt_0
    225          	AES_cfbr_encrypt_block(&in[n],&out[n],8,key,ivec,enc);
   \                     ??AES_cfb8_encrypt_1:
   \   00000024   0900A0E1           MOV      R0,R9
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   0730A0E1           MOV      R3,R7
   \   00000030   0820A0E3           MOV      R2,#+8
   \   00000034   05108AE0           ADD      R1,R10,R5
   \   00000038   0800A0E1           MOV      R0,R8
   \   0000003C   01002DE9           PUSH     {R0}
   \   00000040   04008AE0           ADD      R0,R10,R4
   \   00000044   01A08AE2           ADD      R10,R10,#+1
   \   00000048   ........           BL       AES_cfbr_encrypt_block
   \   0000004C   08D08DE2           ADD      SP,SP,#+8
   \                     ??AES_cfb8_encrypt_0:
   \   00000050   06005AE1           CMP      R10,R6
   \   00000054   F2FFFF3A           BCC      ??AES_cfb8_encrypt_1
    226              }
   \   00000058   F087BDE8           POP      {R4-R10,PC}      ;; return
    227          

   Maximum stack usage in bytes:

     Function               CSTACK
     --------               ------
     AES_cfb128_encrypt        32
     AES_cfb1_encrypt          64
     AES_cfb8_encrypt          40
     AES_cfbr_encrypt_block    60


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     AES_cfb128_encrypt      204
     AES_cfbr_encrypt_block  304
     AES_cfb1_encrypt        192
     AES_cfb8_encrypt         92
      Others                  28

 
 820 bytes in segment CODE
 
 792 bytes of CODE memory (+ 28 bytes shared)

Errors: none
Warnings: none
