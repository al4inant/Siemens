##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    15/Mar/2023  22:35:40 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON_Utils.c                                  #
#    Command line    =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \json\cJSON_Utils.c -D NEWSGOLD -D DEBUG -lCN        #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\ -la D:\Users\alfinant\Documents\Si #
#                       emens\Dev\IAR\VK.ELF_C\Releas_NSG\List\ -o           #
#                       D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\ -s9 --cpu_mode arm --endian little  #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork         #
#                       --diag_suppress Pe301 -e --fpu None --dlib_config    #
#                       D:\Users\alfinant\Documents\Siemens\IAR\ARM\LIB\dl5t #
#                       painl8n.h -I D:\Users\alfinant\Documents\Siemens\IAR #
#                       \ARM\INC\ --inline_threshold=2                       #
#    List file       =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\List\cJSON_Utils.lst                     #
#    Object file     =  D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C #
#                       \Releas_NSG\Obj\cJSON_Utils.r79                      #
#                                                                            #
#                                                                            #
##############################################################################

D:\Users\alfinant\Documents\Siemens\Dev\IAR\VK.ELF_C\json\cJSON_Utils.c
      1          /*
      2            Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
      3          
      4            Permission is hereby granted, free of charge, to any person obtaining a copy
      5            of this software and associated documentation files (the "Software"), to deal
      6            in the Software without restriction, including without limitation the rights
      7            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8            copies of the Software, and to permit persons to whom the Software is
      9            furnished to do so, subject to the following conditions:
     10          
     11            The above copyright notice and this permission notice shall be included in
     12            all copies or substantial portions of the Software.
     13          
     14            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     20            THE SOFTWARE.
     21          */
     22          
     23          /* disable warnings about old C89 functions in MSVC */
     24          #if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
     25          #define _CRT_SECURE_NO_DEPRECATE
     26          #endif
     27          
     28          #ifdef __GNUCC__
     29          #pragma GCC visibility push(default)
     30          #endif
     31          #if defined(_MSC_VER)
     32          #pragma warning (push)
     33          /* disable warning about single line comments in system headers */
     34          #pragma warning (disable : 4001)
     35          #endif
     36          
     37          #include <siemens\swilib.h>
     38          
     39          #include <ctype.h>
     40          //#include <string.h>
     41          //#include <stdlib.h>
     42          //#include <stdio.h>
     43          #include <limits.h>
     44          
     45          #if defined(_MSC_VER)
     46          #pragma warning (pop)
     47          #endif
     48          #ifdef __GNUCC__
     49          #pragma GCC visibility pop
     50          #endif
     51          
     52          #include "cJSON_Utils.h"
     53          
     54          /* define our own boolean type */
     55          #define true ((cJSON_bool)1)
     56          #define false ((cJSON_bool)0)
     57          
     58          static unsigned char* cJSONUtils_strdup(const unsigned char* const string)
     59          {
     60              size_t length = 0;
     61              unsigned char *copy = NULL;
     62          
     63              length = strlen((const char*)string) + sizeof("");
     64              copy = (unsigned char*) cJSON_malloc(length);
     65              if (copy == NULL)
     66              {
     67                  return NULL;
     68              }
     69              memcpy(copy, string, length);
     70          
     71              return copy;
     72          }
     73          
     74          /* string comparison which doesn't consider NULL pointers equal */

   \                                 In segment CODE, align 4, keep-with-next
     75          static int compare_strings(const unsigned char *string1, const unsigned char *string2, const cJSON_bool case_sensitive)
     76          {
   \                     compare_strings:
   \   00000000   00402DE9           PUSH     {LR}
     77              if ((string1 == NULL) || (string2 == NULL))
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   00005113           CMPNE    R1,#+0
     78              {
     79                  return 1;
   \   0000000C   0100A003           MOVEQ    R0,#+1
   \   00000010   0080BD08           POPEQ    {PC}
     80              }
     81          
     82              if (string1 == string2)
   \   00000014   010050E1           CMP      R0,R1
   \   00000018   0100001A           BNE      ??compare_strings_0
     83              {
     84                  return 0;
   \                     ??compare_strings_1:
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   0080BDE8           POP      {PC}
     85              }
     86          
     87              if (case_sensitive)
   \                     ??compare_strings_0:
   \   00000024   000052E3           CMP      R2,#+0
   \   00000028   0500000A           BEQ      ??compare_strings_2
     88              {
     89                  return strcmp((const char*)string1, (const char*)string2);
   \   0000002C   190000EF           SWI      +25
   \   00000030   0080BDE8           POP      {PC}
     90              }
     91          
     92              for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
     93              {
     94                  if (*string1 == '\0')
   \                     ??compare_strings_3:
   \   00000034   ........           LDRB     R2,[R0], #+1
   \   00000038   000052E3           CMP      R2,#+0
   \   0000003C   F6FFFF0A           BEQ      ??compare_strings_1
     95                  {
     96                      return 0;
     97                  }
     98              }
   \   00000040   011081E2           ADD      R1,R1,#+1
   \                     ??compare_strings_2:
   \   00000044   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000048   410052E3           CMP      R2,#+65
   \   0000004C   010000BA           BLT      ??compare_strings_4
   \   00000050   5B0052E3           CMP      R2,#+91
   \   00000054   202082B2           ADDLT    R2,R2,#+32
   \                     ??compare_strings_4:
   \   00000058   0030D1E5           LDRB     R3,[R1, #+0]
   \   0000005C   410053E3           CMP      R3,#+65
   \   00000060   010000BA           BLT      ??compare_strings_5
   \   00000064   5B0053E3           CMP      R3,#+91
   \   00000068   203083B2           ADDLT    R3,R3,#+32
   \                     ??compare_strings_5:
   \   0000006C   030052E1           CMP      R2,R3
   \   00000070   EFFFFF0A           BEQ      ??compare_strings_3
     99          
    100              return tolower(*string1) - tolower(*string2);
   \   00000074   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000078   410050E3           CMP      R0,#+65
   \   0000007C   010000BA           BLT      ??compare_strings_6
   \   00000080   5B0050E3           CMP      R0,#+91
   \   00000084   200080B2           ADDLT    R0,R0,#+32
   \                     ??compare_strings_6:
   \   00000088   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000008C   410051E3           CMP      R1,#+65
   \   00000090   010000BA           BLT      ??compare_strings_7
   \   00000094   5B0051E3           CMP      R1,#+91
   \   00000098   201081B2           ADDLT    R1,R1,#+32
   \                     ??compare_strings_7:
   \   0000009C   010040E0           SUB      R0,R0,R1
   \   000000A0   0080BDE8           POP      {PC}             ;; return
    101          }
    102          
    103          /* Compare the next path element of two JSON pointers, two NULL pointers are considered unequal: */

   \                                 In segment CODE, align 4, keep-with-next
    104          static cJSON_bool compare_pointers(const unsigned char *name, const unsigned char *pointer, const cJSON_bool case_sensitive)
    105          {
    106              if ((name == NULL) || (pointer == NULL))
   \                     compare_pointers:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   1EFF2F01           BXEQ     LR
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   0A00001A           BNE      ??compare_pointers_0
    107              {
    108                  return false;
   \   00000010   200000EA           B        ??compare_pointers_1
    109              }
    110          
    111              for (; (*name != '\0') && (*pointer != '\0') && (*pointer != '/'); (void)name++, pointer++) /* compare until next '/' */
    112              {
    113                  if (*pointer == '~')
    114                  {
    115                      /* check for escaped '~' (~0) and '/' (~1) */
    116                      if (((pointer[1] != '0') || (*name != '~')) && ((pointer[1] != '1') || (*name != '/')))
   \                     ??compare_pointers_2:
   \   00000014   01C0D1E5           LDRB     R12,[R1, #+1]
   \   00000018   30005CE3           CMP      R12,#+48
   \   0000001C   7E005303           CMPEQ    R3,#+126
   \   00000020   0200000A           BEQ      ??compare_pointers_3
   \   00000024   31005CE3           CMP      R12,#+49
   \   00000028   2F005303           CMPEQ    R3,#+47
   \   0000002C   1900001A           BNE      ??compare_pointers_1
    117                      {
    118                          /* invalid escape sequence or wrong character in *name */
    119                          return false;
    120                      }
    121                      else
    122                      {
    123                          pointer++;
   \                     ??compare_pointers_3:
   \   00000030   011081E2           ADD      R1,R1,#+1
    124                      }
    125                  }
   \                     ??compare_pointers_4:
   \   00000034   010080E2           ADD      R0,R0,#+1
   \   00000038   011081E2           ADD      R1,R1,#+1
   \                     ??compare_pointers_0:
   \   0000003C   0030D0E5           LDRB     R3,[R0, #+0]
   \   00000040   000053E3           CMP      R3,#+0
   \   00000044   00C0D115           LDRBNE   R12,[R1, #+0]
   \   00000048   00005C13           CMPNE    R12,#+0
   \   0000004C   2F005C13           CMPNE    R12,#+47
   \   00000050   1200000A           BEQ      ??compare_pointers_5
   \   00000054   7E005CE3           CMP      R12,#+126
   \   00000058   EDFFFF0A           BEQ      ??compare_pointers_2
    126                  else if ((!case_sensitive && (tolower(*name) != tolower(*pointer))) || (case_sensitive && (*name != *pointer)))
   \   0000005C   000052E3           CMP      R2,#+0
   \   00000060   0A00001A           BNE      ??compare_pointers_6
   \   00000064   410053E3           CMP      R3,#+65
   \   00000068   010000BA           BLT      ??compare_pointers_7
   \   0000006C   5B0053E3           CMP      R3,#+91
   \   00000070   203083B2           ADDLT    R3,R3,#+32
   \                     ??compare_pointers_7:
   \   00000074   41005CE3           CMP      R12,#+65
   \   00000078   010000BA           BLT      ??compare_pointers_8
   \   0000007C   5B005CE3           CMP      R12,#+91
   \   00000080   20C08CB2           ADDLT    R12,R12,#+32
   \                     ??compare_pointers_8:
   \   00000084   0C0053E1           CMP      R3,R12
   \   00000088   0200001A           BNE      ??compare_pointers_1
   \   0000008C   E8FFFFEA           B        ??compare_pointers_4
   \                     ??compare_pointers_6:
   \   00000090   0C0053E1           CMP      R3,R12
   \   00000094   E6FFFF0A           BEQ      ??compare_pointers_4
    127                  {
    128                      return false;
   \                     ??compare_pointers_1:
   \   00000098   0000A0E3           MOV      R0,#+0
   \   0000009C   1EFF2FE1           BX       LR
    129                  }
    130              }
    131              if (((*pointer != 0) && (*pointer != '/')) != (*name != 0))
   \                     ??compare_pointers_5:
   \   000000A0   0010D1E5           LDRB     R1,[R1, #+0]
   \   000000A4   0120A0E3           MOV      R2,#+1
   \   000000A8   000051E3           CMP      R1,#+0
   \   000000AC   2F005113           CMPNE    R1,#+47
   \   000000B0   0110A013           MOVNE    R1,#+1
   \   000000B4   0010A003           MOVEQ    R1,#+0
   \   000000B8   000053E3           CMP      R3,#+0
   \   000000BC   0020A003           MOVEQ    R2,#+0
   \   000000C0   020051E1           CMP      R1,R2
   \   000000C4   F3FFFF1A           BNE      ??compare_pointers_1
    132              {
    133                  /* one string has ended, the other not */
    134                  return false;;
    135              }
    136          
    137              return true;
   \   000000C8   0100A0E3           MOV      R0,#+1
   \   000000CC   1EFF2FE1           BX       LR               ;; return
    138          }
    139          
    140          /* calculate the length of a string if encoded as JSON pointer with ~0 and ~1 escape sequences */
    141          static size_t pointer_encoded_length(const unsigned char *string)
    142          {
    143              size_t length;
    144              for (length = 0; *string != '\0'; (void)string++, length++)
    145              {
    146                  /* character needs to be escaped? */
    147                  if ((*string == '~') || (*string == '/'))
    148                  {
    149                      length++;
    150                  }
    151              }
    152          
    153              return length;
    154          }
    155          
    156          /* copy a string while escaping '~' and '/' with ~0 and ~1 JSON pointer escape codes */

   \                                 In segment CODE, align 4, keep-with-next
    157          static void encode_string_as_pointer(unsigned char *destination, const unsigned char *source)
    158          {
   \                     encode_string_as_pointer:
   \   00000000   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000004   3130A0E3           MOV      R3,#+49
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   0C00000A           BEQ      ??encode_string_as_pointer_0
    159              for (; source[0] != '\0'; (void)source++, destination++)
    160              {
    161                  if (source[0] == '/')
   \                     ??encode_string_as_pointer_1:
   \   00000010   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000014   2F0052E3           CMP      R2,#+47
    162                  {
    163                      destination[1] = '1';
   \   00000018   0130C005           STRBEQ   R3,[R0, #+1]
    164                      destination++;
   \   0000001C   01008002           ADDEQ    R0,R0,#+1
   \   00000020   0300000A           BEQ      ??encode_string_as_pointer_2
    165                  }
    166                  else if (source[0] == '~')
   \   00000024   7E0052E3           CMP      R2,#+126
    167                  {
    168                      destination[0] = '~';
   \   00000028   ........           STRBEQ   R2,[R0], #+1
    169                      destination[1] = '1';
   \   0000002C   0030C005           STRBEQ   R3,[R0, #+0]
    170                      destination++;
    171                  }
    172                  else
    173                  {
    174                      destination[0] = source[0];
   \   00000030   0020C015           STRBNE   R2,[R0, #+0]
    175                  }
    176              }
   \                     ??encode_string_as_pointer_2:
   \   00000034   0120F1E5           LDRB     R2,[R1, #+1]!
   \   00000038   010080E2           ADD      R0,R0,#+1
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   F2FFFF1A           BNE      ??encode_string_as_pointer_1
    177          
    178              destination[0] = '\0';
   \                     ??encode_string_as_pointer_0:
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   0010C0E5           STRB     R1,[R0, #+0]
    179          }
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    180          

   \                                 In segment CODE, align 4, keep-with-next
    181          CJSON_PUBLIC(char *) cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target)
    182          {
   \                     cJSONUtils_FindPointerFromObjectTo:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0070A0E1           MOV      R7,R0
   \   00000008   0180A0E1           MOV      R8,R1
    183              size_t child_index = 0;
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0090A0E3           MOV      R9,#+0
    184              cJSON *current_child = 0;
    185          
    186              if ((object == NULL) || (target == NULL))
   \   00000014   000057E3           CMP      R7,#+0
   \   00000018   00005813           CMPNE    R8,#+0
   \   0000001C   4800000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_0
    187              {
    188                  return NULL;
    189              }
    190          
    191              if (object == target)
   \   00000020   080057E1           CMP      R7,R8
   \   00000024   0D00001A           BNE      ??cJSONUtils_FindPointerFromObjectTo_1
    192              {
    193                  /* found */
    194                  return (char*)cJSONUtils_strdup((const unsigned char*)"");
   \   00000028   ........           ADR      R5,??DataTable0  ;; ""
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   1B0000EF           SWI      +27
   \   00000034   016080E2           ADD      R6,R0,#+1
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000040   0070B0E1           MOVS     R7,R0
   \   00000044   0070A003           MOVEQ    R7,#+0
   \   00000048   0200000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_2
   \   0000004C   0620A0E1           MOV      R2,R6
   \   00000050   0510A0E1           MOV      R1,R5
   \   00000054   1E0100EF           SWI      +286
   \                     ??cJSONUtils_FindPointerFromObjectTo_2:
   \   00000058   0700A0E1           MOV      R0,R7
   \   0000005C   F083BDE8           POP      {R4-R9,PC}
    195              }
    196          
    197              /* recursively search all children of the object or array */
    198              for (current_child = object->child; current_child != NULL; (void)(current_child = current_child->next), child_index++)
   \                     ??cJSONUtils_FindPointerFromObjectTo_1:
   \   00000060   086097E5           LDR      R6,[R7, #+8]
   \   00000064   010000EA           B        ??cJSONUtils_FindPointerFromObjectTo_3
   \                     ??cJSONUtils_FindPointerFromObjectTo_4:
   \   00000068   006096E5           LDR      R6,[R6, #+0]
   \   0000006C   019089E2           ADD      R9,R9,#+1
   \                     ??cJSONUtils_FindPointerFromObjectTo_3:
   \   00000070   000056E3           CMP      R6,#+0
   \   00000074   3200000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_0
    199              {
    200                  unsigned char *target_pointer = (unsigned char*)cJSONUtils_FindPointerFromObjectTo(current_child, target);
   \   00000078   0810A0E1           MOV      R1,R8
   \   0000007C   0600A0E1           MOV      R0,R6
   \   00000080   DEFFFFEB           BL       cJSONUtils_FindPointerFromObjectTo
   \   00000084   0050B0E1           MOVS     R5,R0
    201                  /* found the target? */
    202                  if (target_pointer != NULL)
   \   00000088   F6FFFF0A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_4
    203                  {
    204                      if (cJSON_IsArray(object))
   \   0000008C   0700A0E1           MOV      R0,R7
   \   00000090   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   0900000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_5
    205                      {
    206                          /* reserve enough memory for a 64 bit integer + '/' and '\0' */
    207                          unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + 20 + sizeof("/"));
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   1B0000EF           SWI      +27
   \   000000A4   160080E2           ADD      R0,R0,#+22
   \   000000A8   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
    208                          /* check if conversion to unsigned long is valid
    209                           * This should be eliminated at compile time by dead code elimination
    210                           * if size_t is an alias of unsigned long, or if it is bigger */
    211                          if (child_index > ULONG_MAX)
    212                          {
    213                              cJSON_free(target_pointer);
    214                              return NULL;
    215                          }
    216                          sprintf((char*)full_pointer, "/%lu%s", (unsigned long)child_index, target_pointer); /* /<array_index><path> */
   \   000000AC   98109FE5           LDR      R1,??cJSONUtils_FindPointerFromObjectTo_6  ;; `?<Constant "/%lu%s">`
   \   000000B0   0040A0E1           MOV      R4,R0
   \   000000B4   0530A0E1           MOV      R3,R5
   \   000000B8   0920A0E1           MOV      R2,R9
   \   000000BC   160000EF           SWI      +22
    217                          cJSON_free(target_pointer);
   \   000000C0   1D0000EA           B        ??cJSONUtils_FindPointerFromObjectTo_7
    218          
    219                          return (char*)full_pointer;
    220                      }
    221          
    222                      if (cJSON_IsObject(object))
   \                     ??cJSONUtils_FindPointerFromObjectTo_5:
   \   000000C4   0700A0E1           MOV      R0,R7
   \   000000C8   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0500A0E1           MOV      R0,R5
   \   000000D4   1900000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_8
    223                      {
    224                          unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + pointer_encoded_length((unsigned char*)current_child->string) + 2);
   \   000000D8   1B0000EF           SWI      +27
   \   000000DC   201096E5           LDR      R1,[R6, #+32]
   \   000000E0   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000E4   000052E3           CMP      R2,#+0
   \   000000E8   0700000A           BEQ      ??cJSONUtils_FindPointerFromObjectTo_9
   \                     ??cJSONUtils_FindPointerFromObjectTo_10:
   \   000000EC   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000F0   7E0052E3           CMP      R2,#+126
   \   000000F4   2F005213           CMPNE    R2,#+47
   \   000000F8   0120F1E5           LDRB     R2,[R1, #+1]!
   \   000000FC   01408402           ADDEQ    R4,R4,#+1
   \   00000100   014084E2           ADD      R4,R4,#+1
   \   00000104   000052E3           CMP      R2,#+0
   \   00000108   F7FFFF1A           BNE      ??cJSONUtils_FindPointerFromObjectTo_10
   \                     ??cJSONUtils_FindPointerFromObjectTo_9:
   \   0000010C   000084E0           ADD      R0,R4,R0
   \   00000110   020080E2           ADD      R0,R0,#+2
   \   00000114   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000118   0040A0E1           MOV      R4,R0
    225                          full_pointer[0] = '/';
   \   0000011C   2F00A0E3           MOV      R0,#+47
   \   00000120   0000C4E5           STRB     R0,[R4, #+0]
    226                          encode_string_as_pointer(full_pointer + 1, (unsigned char*)current_child->string);
   \   00000124   201096E5           LDR      R1,[R6, #+32]
   \   00000128   010084E2           ADD      R0,R4,#+1
   \   0000012C   ........           BL       encode_string_as_pointer
    227                          strcat((char*)full_pointer, (char*)target_pointer);
   \   00000130   0510A0E1           MOV      R1,R5
   \   00000134   0400A0E1           MOV      R0,R4
   \   00000138   170000EF           SWI      +23
    228                          cJSON_free(target_pointer);
   \                     ??cJSONUtils_FindPointerFromObjectTo_7:
   \   0000013C   0500A0E1           MOV      R0,R5
   \                     ??cJSONUtils_FindPointerFromObjectTo_8:
   \   00000140   ........           _BLF     cJSON_free,??cJSON_free??rA
    229          
    230                          return (char*)full_pointer;
   \                     ??cJSONUtils_FindPointerFromObjectTo_0:
   \   00000144   0400A0E1           MOV      R0,R4
   \   00000148   F083BDE8           POP      {R4-R9,PC}
   \                     ??cJSONUtils_FindPointerFromObjectTo_6:
   \   0000014C   ........           DC32     `?<Constant "/%lu%s">`
    231                      }
    232          
    233                      /* reached leaf of the tree, found nothing */
    234                      cJSON_free(target_pointer);
    235                      return NULL;
    236                  }
    237              }
    238          
    239              /* not found */
    240              return NULL;
    241          }
    242          
    243          /* non broken version of cJSON_GetArrayItem */
    244          static cJSON *get_array_item(const cJSON *array, size_t item)
    245          {
    246              cJSON *child = array ? array->child : NULL;
    247              while ((child != NULL) && (item > 0))
    248              {
    249                  item--;
    250                  child = child->next;
    251              }
    252          
    253              return child;
    254          }
    255          

   \                                 In segment CODE, align 4, keep-with-next
    256          static cJSON_bool decode_array_index_from_pointer(const unsigned char * const pointer, size_t * const index)
    257          {
   \                     decode_array_index_from_pointer:
   \   00000000   10002DE9           PUSH     {R4}
    258              size_t parsed_index = 0;
    259              size_t position = 0;
    260          
    261              if ((pointer[0] == '0') && ((pointer[1] != '\0') && (pointer[1] != '/')))
   \   00000004   00C0D0E5           LDRB     R12,[R0, #+0]
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   30005CE3           CMP      R12,#+48
   \   00000014   0B00001A           BNE      ??decode_array_index_from_pointer_0
   \   00000018   01C0D0E5           LDRB     R12,[R0, #+1]
   \   0000001C   00005CE3           CMP      R12,#+0
   \   00000020   2F005C13           CMPNE    R12,#+47
   \   00000024   0700000A           BEQ      ??decode_array_index_from_pointer_0
    262              {
    263                  /* leading zeroes are not permitted */
    264                  return 0;
   \                     ??decode_array_index_from_pointer_1:
   \   00000028   1000BDE8           POP      {R4}
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR
    265              }
    266          
    267              for (position = 0; (pointer[position] >= '0') && (pointer[0] <= '9'); position++)
    268              {
    269                  parsed_index = (10 * parsed_index) + (size_t)(pointer[position] - '0');
   \                     ??decode_array_index_from_pointer_2:
   \   00000034   00C0DCE5           LDRB     R12,[R12, #+0]
   \   00000038   0A40A0E3           MOV      R4,#+10
    270          
    271              }
   \   0000003C   013083E2           ADD      R3,R3,#+1
   \   00000040   30C04CE2           SUB      R12,R12,#+48
   \   00000044   94C222E0           MLA      R2,R4,R2,R12
   \                     ??decode_array_index_from_pointer_0:
   \   00000048   00C083E0           ADD      R12,R3,R0
   \   0000004C   0040DCE5           LDRB     R4,[R12, #+0]
   \   00000050   300054E3           CMP      R4,#+48
   \   00000054   0200003A           BCC      ??decode_array_index_from_pointer_3
   \   00000058   0040D0E5           LDRB     R4,[R0, #+0]
   \   0000005C   3A0054E3           CMP      R4,#+58
   \   00000060   F3FFFF3A           BCC      ??decode_array_index_from_pointer_2
    272          
    273              if ((pointer[position] != '\0') && (pointer[position] != '/'))
   \                     ??decode_array_index_from_pointer_3:
   \   00000064   0000DCE5           LDRB     R0,[R12, #+0]
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   2F005013           CMPNE    R0,#+47
   \   00000070   ECFFFF1A           BNE      ??decode_array_index_from_pointer_1
    274              {
    275                  return 0;
    276              }
    277          
    278              *index = parsed_index;
   \   00000074   002081E5           STR      R2,[R1, #+0]
    279          
    280              return 1;
   \   00000078   1000BDE8           POP      {R4}
   \   0000007C   0100A0E3           MOV      R0,#+1
   \   00000080   1EFF2FE1           BX       LR               ;; return
    281          }
    282          

   \                                 In segment CODE, align 4, keep-with-next
    283          static cJSON *get_item_from_pointer(cJSON * const object, const char * pointer, const cJSON_bool case_sensitive)
    284          {
   \                     get_item_from_pointer:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0060A0E1           MOV      R6,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
    285              cJSON *current_element = object;
    286          
    287              if (pointer == NULL)
   \   00000014   000054E3           CMP      R4,#+0
   \   00000018   0070A0E3           MOV      R7,#+0
    288              {
    289                  return NULL;
   \   0000001C   0000A003           MOVEQ    R0,#+0
   \   00000020   F280BD08           POPEQ    {R1,R4-R7,PC}
    290              }
    291          
    292              /* follow path of the pointer */
    293              while ((pointer[0] == '/') && (current_element != NULL))
   \                     ??get_item_from_pointer_0:
   \   00000024   ........           LDRB     R0,[R4], #+1
   \   00000028   2F0050E3           CMP      R0,#+47
   \   0000002C   2C00001A           BNE      ??get_item_from_pointer_1
   \   00000030   000056E3           CMP      R6,#+0
   \   00000034   2A00000A           BEQ      ??get_item_from_pointer_1
    294              {
    295                  pointer++;
    296                  if (cJSON_IsArray(current_element))
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   1100000A           BEQ      ??get_item_from_pointer_2
    297                  {
    298                      size_t index = 0;
   \   00000048   00708DE5           STR      R7,[SP, #+0]
    299                      if (!decode_array_index_from_pointer((const unsigned char*)pointer, &index))
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       decode_array_index_from_pointer
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   F280BD08           POPEQ    {R1,R4-R7,PC}
    300                      {
    301                          return NULL;
    302                      }
    303          
    304                      current_element = get_array_item(current_element, index);
   \   00000060   00009DE5           LDR      R0,[SP, #+0]
   \   00000064   000056E3           CMP      R6,#+0
   \   00000068   1700000A           BEQ      ??get_item_from_pointer_3
   \   0000006C   086096E5           LDR      R6,[R6, #+8]
   \   00000070   010000EA           B        ??get_item_from_pointer_4
   \                     ??get_item_from_pointer_5:
   \   00000074   006096E5           LDR      R6,[R6, #+0]
   \   00000078   010040E2           SUB      R0,R0,#+1
   \                     ??get_item_from_pointer_4:
   \   0000007C   000056E3           CMP      R6,#+0
   \   00000080   1100000A           BEQ      ??get_item_from_pointer_3
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   F9FFFF1A           BNE      ??get_item_from_pointer_5
   \   0000008C   0E0000EA           B        ??get_item_from_pointer_3
    305                  }
    306                  else if (cJSON_IsObject(current_element))
   \                     ??get_item_from_pointer_2:
   \   00000090   0600A0E1           MOV      R0,R6
   \   00000094   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   F280BD08           POPEQ    {R1,R4-R7,PC}
    307                  {
    308                      current_element = current_element->child;
   \   000000A0   086096E5           LDR      R6,[R6, #+8]
   \   000000A4   000000EA           B        ??get_item_from_pointer_6
    309                      /* GetObjectItem. */
    310                      while ((current_element != NULL) && !compare_pointers((unsigned char*)current_element->string, (const unsigned char*)pointer, case_sensitive))
    311                      {
    312                          current_element = current_element->next;
   \                     ??get_item_from_pointer_7:
   \   000000A8   006096E5           LDR      R6,[R6, #+0]
    313                      }
   \                     ??get_item_from_pointer_6:
   \   000000AC   000056E3           CMP      R6,#+0
   \   000000B0   0500000A           BEQ      ??get_item_from_pointer_3
   \   000000B4   200096E5           LDR      R0,[R6, #+32]
   \   000000B8   0520A0E1           MOV      R2,R5
   \   000000BC   0410A0E1           MOV      R1,R4
   \   000000C0   ........           BL       compare_pointers
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   F6FFFF0A           BEQ      ??get_item_from_pointer_7
    314                  }
    315                  else
    316                  {
    317                      return NULL;
    318                  }
    319          
    320                  /* skip to the next path token or end of string */
    321                  while ((pointer[0] != '\0') && (pointer[0] != '/'))
   \                     ??get_item_from_pointer_3:
   \   000000CC   0000D4E5           LDRB     R0,[R4, #+0]
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   2F005013           CMPNE    R0,#+47
   \   000000D8   D1FFFF0A           BEQ      ??get_item_from_pointer_0
    322                  {
    323                      pointer++;
   \   000000DC   014084E2           ADD      R4,R4,#+1
   \   000000E0   F9FFFFEA           B        ??get_item_from_pointer_3
    324                  }
    325              }
    326          
    327              return current_element;
   \                     ??get_item_from_pointer_1:
   \   000000E4   0600A0E1           MOV      R0,R6
   \   000000E8   F280BDE8           POP      {R1,R4-R7,PC}    ;; return
    328          }
    329          

   \                                 In segment CODE, align 4, keep-with-next
    330          CJSON_PUBLIC(cJSON *) cJSONUtils_GetPointer(cJSON * const object, const char *pointer)
    331          {
    332              return get_item_from_pointer(object, pointer, false);
   \                     cJSONUtils_GetPointer:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        get_item_from_pointer  ;; tailcall
    333          }
    334          

   \                                 In segment CODE, align 4, keep-with-next
    335          CJSON_PUBLIC(cJSON *) cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer)
    336          {
    337              return get_item_from_pointer(object, pointer, true);
   \                     cJSONUtils_GetPointerCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        get_item_from_pointer  ;; tailcall
    338          }
    339          
    340          /* JSON Patch implementation. */
    341          static void decode_pointer_inplace(unsigned char *string)
    342          {
    343              unsigned char *decoded_string = string;
    344          
    345              if (string == NULL) {
    346                  return;
    347              }
    348          
    349              for (; *string; (void)decoded_string++, string++)
    350              {
    351                  if (string[0] == '~')
    352                  {
    353                      if (string[1] == '0')
    354                      {
    355                          decoded_string[0] = '~';
    356                      }
    357                      else if (string[1] == '1')
    358                      {
    359                          decoded_string[1] = '/';
    360                      }
    361                      else
    362                      {
    363                          /* invalid escape sequence */
    364                          return;
    365                      }
    366          
    367                      string++;
    368                  }
    369              }
    370          
    371              decoded_string[0] = '\0';
    372          }
    373          
    374          /* non-broken cJSON_DetachItemFromArray */
    375          static cJSON *detach_item_from_array(cJSON *array, size_t which)
    376          {
    377              cJSON *c = array->child;
    378              while (c && (which > 0))
    379              {
    380                  c = c->next;
    381                  which--;
    382              }
    383              if (!c)
    384              {
    385                  /* item doesn't exist */
    386                  return NULL;
    387              }
    388              if (c->prev)
    389              {
    390                  /* not the first element */
    391                  c->prev->next = c->next;
    392              }
    393              if (c->next)
    394              {
    395                  c->next->prev = c->prev;
    396              }
    397              if (c==array->child)
    398              {
    399                  array->child = c->next;
    400              }
    401              /* make sure the detached item doesn't point anywhere anymore */
    402              c->prev = c->next = NULL;
    403          
    404              return c;
    405          }
    406          
    407          /* detach an item at the given path */

   \                                 In segment CODE, align 4, keep-with-next
    408          static cJSON *detach_path(cJSON *object, const unsigned char *path, const cJSON_bool case_sensitive)
    409          {
   \                     detach_path:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0080A0E1           MOV      R8,R0
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0290A0E1           MOV      R9,R2
    410              unsigned char *parent_pointer = NULL;
    411              unsigned char *child_pointer = NULL;
    412              cJSON *parent = NULL;
    413              cJSON *detached_item = NULL;
   \   00000014   0040A0E3           MOV      R4,#+0
   \   00000018   0050A0E3           MOV      R5,#+0
    414          
    415              /* copy path and split it in parent and child */
    416              parent_pointer = cJSONUtils_strdup(path);
   \   0000001C   0700A0E1           MOV      R0,R7
   \   00000020   1B0000EF           SWI      +27
   \   00000024   01A080E2           ADD      R10,R0,#+1
   \   00000028   0A00A0E1           MOV      R0,R10
   \   0000002C   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000030   0060B0E1           MOVS     R6,R0
   \   00000034   5100000A           BEQ      ??detach_path_0
   \   00000038   0A20A0E1           MOV      R2,R10
   \   0000003C   0710A0E1           MOV      R1,R7
   \   00000040   1E0100EF           SWI      +286
    417              if (parent_pointer == NULL) {
    418                  goto cleanup;
    419              }
    420          
    421              child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/'); /* last '/' */
   \   00000044   2F10A0E3           MOV      R1,#+47
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   170100EF           SWI      +279
   \   00000050   0070B0E1           MOVS     R7,R0
    422              if (child_pointer == NULL)
   \   00000054   4700000A           BEQ      ??detach_path_1
    423              {
    424                  goto cleanup;
    425              }
    426              /* split strings */
    427              child_pointer[0] = '\0';
   \   00000058   ........           STRB     R4,[R7], #+1
    428              child_pointer++;
    429          
    430              parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);
   \   0000005C   0920A0E1           MOV      R2,R9
   \   00000060   0610A0E1           MOV      R1,R6
   \   00000064   0800A0E1           MOV      R0,R8
   \   00000068   ........           BL       get_item_from_pointer
   \   0000006C   0080A0E1           MOV      R8,R0
    431              decode_pointer_inplace(child_pointer);
   \   00000070   0700A0E1           MOV      R0,R7
   \   00000074   0010B0E1           MOVS     R1,R0
   \   00000078   0700001A           BNE      ??detach_path_2
   \   0000007C   120000EA           B        ??detach_path_3
   \                     ??detach_path_4:
   \   00000080   310052E3           CMP      R2,#+49
   \   00000084   1000001A           BNE      ??detach_path_3
   \   00000088   2F20A0E3           MOV      R2,#+47
   \   0000008C   0120C1E5           STRB     R2,[R1, #+1]
   \                     ??detach_path_5:
   \   00000090   010080E2           ADD      R0,R0,#+1
   \                     ??detach_path_6:
   \   00000094   011081E2           ADD      R1,R1,#+1
   \   00000098   010080E2           ADD      R0,R0,#+1
   \                     ??detach_path_2:
   \   0000009C   0020D0E5           LDRB     R2,[R0, #+0]
   \   000000A0   000052E3           CMP      R2,#+0
   \   000000A4   0700000A           BEQ      ??detach_path_7
   \   000000A8   7E0052E3           CMP      R2,#+126
   \   000000AC   F8FFFF1A           BNE      ??detach_path_6
   \   000000B0   0120D0E5           LDRB     R2,[R0, #+1]
   \   000000B4   300052E3           CMP      R2,#+48
   \   000000B8   F0FFFF1A           BNE      ??detach_path_4
   \   000000BC   7E20A0E3           MOV      R2,#+126
   \   000000C0   0020C1E5           STRB     R2,[R1, #+0]
   \   000000C4   F1FFFFEA           B        ??detach_path_5
   \                     ??detach_path_7:
   \   000000C8   0040C1E5           STRB     R4,[R1, #+0]
    432          
    433              if (cJSON_IsArray(parent))
   \                     ??detach_path_3:
   \   000000CC   0800A0E1           MOV      R0,R8
   \   000000D0   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   000000D4   000050E3           CMP      R0,#+0
   \   000000D8   1E00000A           BEQ      ??detach_path_8
    434              {
    435                  size_t index = 0;
   \   000000DC   00408DE5           STR      R4,[SP, #+0]
    436                  if (!decode_array_index_from_pointer(child_pointer, &index))
   \   000000E0   0D10A0E1           MOV      R1,SP
   \   000000E4   0700A0E1           MOV      R0,R7
   \   000000E8   ........           BL       decode_array_index_from_pointer
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   2000000A           BEQ      ??detach_path_1
    437                  {
    438                      goto cleanup;
    439                  }
    440                  detached_item = detach_item_from_array(parent, index);
   \   000000F4   00009DE5           LDR      R0,[SP, #+0]
   \   000000F8   081098E5           LDR      R1,[R8, #+8]
   \   000000FC   010000EA           B        ??detach_path_9
   \                     ??detach_path_10:
   \   00000100   001091E5           LDR      R1,[R1, #+0]
   \   00000104   010040E2           SUB      R0,R0,#+1
   \                     ??detach_path_9:
   \   00000108   000051E3           CMP      R1,#+0
   \   0000010C   1900000A           BEQ      ??detach_path_1
   \   00000110   000050E3           CMP      R0,#+0
   \   00000114   F9FFFF1A           BNE      ??detach_path_10
   \   00000118   040091E5           LDR      R0,[R1, #+4]
   \   0000011C   0150A0E1           MOV      R5,R1
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   00209115           LDRNE    R2,[R1, #+0]
   \   00000128   00208015           STRNE    R2,[R0, #+0]
   \   0000012C   000091E5           LDR      R0,[R1, #+0]
   \   00000130   000050E3           CMP      R0,#+0
   \   00000134   04209115           LDRNE    R2,[R1, #+4]
   \   00000138   04208015           STRNE    R2,[R0, #+4]
   \   0000013C   080098E5           LDR      R0,[R8, #+8]
   \   00000140   000051E1           CMP      R1,R0
   \   00000144   00009105           LDREQ    R0,[R1, #+0]
   \   00000148   08008805           STREQ    R0,[R8, #+8]
   \   0000014C   004081E5           STR      R4,[R1, #+0]
   \   00000150   044081E5           STR      R4,[R1, #+4]
   \   00000154   070000EA           B        ??detach_path_1
    441              }
    442              else if (cJSON_IsObject(parent))
   \                     ??detach_path_8:
   \   00000158   0800A0E1           MOV      R0,R8
   \   0000015C   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000160   000050E3           CMP      R0,#+0
   \   00000164   0300000A           BEQ      ??detach_path_1
    443              {
    444                  detached_item = cJSON_DetachItemFromObject(parent, (char*)child_pointer);
   \   00000168   0710A0E1           MOV      R1,R7
   \   0000016C   0800A0E1           MOV      R0,R8
   \   00000170   ........           _BLF     cJSON_DetachItemFromObject,??cJSON_DetachItemFromObject??rA
   \   00000174   0050A0E1           MOV      R5,R0
    445              }
    446              else
    447              {
    448                  /* Couldn't find object to remove child from. */
    449                  goto cleanup;
    450              }
    451          
    452          cleanup:
    453              if (parent_pointer != NULL)
    454              {
    455                  cJSON_free(parent_pointer);
   \                     ??detach_path_1:
   \   00000178   0600A0E1           MOV      R0,R6
   \   0000017C   ........           _BLF     cJSON_free,??cJSON_free??rA
    456              }
    457          
    458              return detached_item;
   \                     ??detach_path_0:
   \   00000180   0500A0E1           MOV      R0,R5
   \   00000184   F287BDE8           POP      {R1,R4-R10,PC}   ;; return
    459          }
    460          
    461          /* sort lists using mergesort */

   \                                 In segment CODE, align 4, keep-with-next
    462          static cJSON *sort_list(cJSON *list, const cJSON_bool case_sensitive)
    463          {
   \                     sort_list:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0080A0E1           MOV      R8,R0
    464              cJSON *first = list;
    465              cJSON *second = list;
   \   0000000C   0870A0E1           MOV      R7,R8
    466              cJSON *current_item = list;
   \   00000010   0890A0E1           MOV      R9,R8
    467              cJSON *result = list;
    468              cJSON *result_tail = NULL;
   \   00000014   0050A0E3           MOV      R5,#+0
   \   00000018   0060A0E3           MOV      R6,#+0
    469          
    470              if ((list == NULL) || (list->next == NULL))
   \   0000001C   000058E3           CMP      R8,#+0
   \   00000020   4500000A           BEQ      ??sort_list_0
   \   00000024   000098E5           LDR      R0,[R8, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0400001A           BNE      ??sort_list_1
    471              {
    472                  /* One entry is sorted already. */
    473                  return result;
   \   00000030   0800A0E1           MOV      R0,R8
   \   00000034   F083BDE8           POP      {R4-R9,PC}
    474              }
    475          
    476              while ((current_item != NULL) && (current_item->next != NULL) && (compare_strings((unsigned char*)current_item->string, (unsigned char*)current_item->next->string, case_sensitive) < 0))
    477              {
    478                  /* Test for list sorted. */
    479                  current_item = current_item->next;
   \                     ??sort_list_2:
   \   00000038   009099E5           LDR      R9,[R9, #+0]
    480              }
   \   0000003C   000059E3           CMP      R9,#+0
   \   00000040   3D00000A           BEQ      ??sort_list_0
   \                     ??sort_list_1:
   \   00000044   000099E5           LDR      R0,[R9, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0500000A           BEQ      ??sort_list_3
   \   00000050   201090E5           LDR      R1,[R0, #+32]
   \   00000054   200099E5           LDR      R0,[R9, #+32]
   \   00000058   0420A0E1           MOV      R2,R4
   \   0000005C   ........           BL       compare_strings
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   F3FFFF4A           BMI      ??sort_list_2
   \                     ??sort_list_3:
   \   00000068   000099E5           LDR      R0,[R9, #+0]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   3100000A           BEQ      ??sort_list_0
    481              if ((current_item == NULL) || (current_item->next == NULL))
    482              {
    483                  /* Leave sorted lists unmodified. */
    484                  return result;
    485              }
    486          
    487              /* reset pointer to the beginning */
    488              current_item = list;
   \   00000074   0890A0E1           MOV      R9,R8
    489              while (current_item != NULL)
    490              {
    491                  /* Walk two pointers to find the middle. */
    492                  second = second->next;
    493                  current_item = current_item->next;
   \                     ??sort_list_4:
   \   00000078   009099E5           LDR      R9,[R9, #+0]
   \   0000007C   007097E5           LDR      R7,[R7, #+0]
    494                  /* advances current_item two steps at a time */
    495                  if (current_item != NULL)
   \   00000080   000059E3           CMP      R9,#+0
    496                  {
    497                      current_item = current_item->next;
   \   00000084   00909915           LDRNE    R9,[R9, #+0]
    498                  }
    499              }
   \   00000088   000059E3           CMP      R9,#+0
   \   0000008C   F9FFFF1A           BNE      ??sort_list_4
    500              if ((second != NULL) && (second->prev != NULL))
   \   00000090   000057E3           CMP      R7,#+0
   \   00000094   04009715           LDRNE    R0,[R7, #+4]
    501              {
    502                  /* Split the lists */
    503                  second->prev->next = NULL;
    504              }
    505          
    506              /* Recursively sort the sub-lists. */
    507              first = sort_list(first, case_sensitive);
   \   00000098   0410A0E1           MOV      R1,R4
   \   0000009C   00005013           CMPNE    R0,#+0
   \   000000A0   00508015           STRNE    R5,[R0, #+0]
   \   000000A4   0800A0E1           MOV      R0,R8
   \   000000A8   D4FFFFEB           BL       sort_list
   \   000000AC   0080A0E1           MOV      R8,R0
    508              second = sort_list(second, case_sensitive);
   \   000000B0   0410A0E1           MOV      R1,R4
   \   000000B4   0700A0E1           MOV      R0,R7
   \   000000B8   D0FFFFEB           BL       sort_list
   \   000000BC   0070A0E1           MOV      R7,R0
    509              result = NULL;
   \   000000C0   020000EA           B        ??sort_list_5
    510          
    511              /* Merge the sub-lists */
    512              while ((first != NULL) && (second != NULL))
    513              {
    514                  cJSON *smaller = NULL;
    515                  if (compare_strings((unsigned char*)first->string, (unsigned char*)second->string, false) < 0)
    516                  {
    517                      smaller = first;
    518                  }
    519                  else
    520                  {
    521                      smaller = second;
    522                  }
    523          
    524                  if (result == NULL)
    525                  {
    526                      /* start merged list with the smaller element */
    527                      result_tail = smaller;
    528                      result = smaller;
    529                  }
    530                  else
    531                  {
    532                      /* add smaller element to the list */
    533                      result_tail->next = smaller;
    534                      smaller->prev = result_tail;
    535                      result_tail = smaller;
    536                  }
    537          
    538                  if (first == smaller)
   \                     ??sort_list_6:
   \   000000C4   000058E1           CMP      R8,R0
   \   000000C8   0800001A           BNE      ??sort_list_7
    539                  {
    540                      first = first->next;
   \   000000CC   008098E5           LDR      R8,[R8, #+0]
    541                  }
   \                     ??sort_list_5:
   \   000000D0   000058E3           CMP      R8,#+0
   \   000000D4   0600001A           BNE      ??sort_list_8
    542                  else
    543                  {
    544                      second = second->next;
    545                  }
    546              }
    547          
    548              if (first != NULL)
    549              {
    550                  /* Append rest of first list. */
    551                  if (result == NULL)
    552                  {
    553                      return first;
    554                  }
    555                  result_tail->next = first;
    556                  first->prev = result_tail;
    557              }
    558              if (second != NULL)
   \   000000D8   000057E3           CMP      R7,#+0
   \   000000DC   1E00000A           BEQ      ??sort_list_9
    559              {
    560                  /* Append rest of second list */
    561                  if (result == NULL)
   \   000000E0   000055E3           CMP      R5,#+0
   \   000000E4   1A00001A           BNE      ??sort_list_10
    562                  {
    563                      return second;
   \   000000E8   0700A0E1           MOV      R0,R7
   \   000000EC   F083BDE8           POP      {R4-R9,PC}
    564                  }
   \                     ??sort_list_7:
   \   000000F0   007097E5           LDR      R7,[R7, #+0]
   \                     ??sort_list_8:
   \   000000F4   000057E3           CMP      R7,#+0
   \   000000F8   0D00000A           BEQ      ??sort_list_11
   \   000000FC   200098E5           LDR      R0,[R8, #+32]
   \   00000100   201097E5           LDR      R1,[R7, #+32]
   \   00000104   0020A0E3           MOV      R2,#+0
   \   00000108   ........           BL       compare_strings
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0800A041           MOVMI    R0,R8
   \   00000114   0700A051           MOVPL    R0,R7
   \   00000118   000055E3           CMP      R5,#+0
   \   0000011C   00008615           STRNE    R0,[R6, #+0]
   \   00000120   04608015           STRNE    R6,[R0, #+4]
   \   00000124   0060A011           MOVNE    R6,R0
   \   00000128   0060A001           MOVEQ    R6,R0
   \   0000012C   0050A001           MOVEQ    R5,R0
   \   00000130   E3FFFFEA           B        ??sort_list_6
   \                     ??sort_list_11:
   \   00000134   000055E3           CMP      R5,#+0
   \   00000138   0100001A           BNE      ??sort_list_12
   \                     ??sort_list_0:
   \   0000013C   0800A0E1           MOV      R0,R8
   \   00000140   F083BDE8           POP      {R4-R9,PC}
   \                     ??sort_list_12:
   \   00000144   008086E5           STR      R8,[R6, #+0]
   \   00000148   046088E5           STR      R6,[R8, #+4]
   \   0000014C   0500A0E1           MOV      R0,R5
   \   00000150   F083BDE8           POP      {R4-R9,PC}
    565                  result_tail->next = second;
   \                     ??sort_list_10:
   \   00000154   007086E5           STR      R7,[R6, #+0]
    566                  second->prev = result_tail;
   \   00000158   046087E5           STR      R6,[R7, #+4]
    567              }
    568          
    569              return result;
   \                     ??sort_list_9:
   \   0000015C   0500A0E1           MOV      R0,R5
   \   00000160   F083BDE8           POP      {R4-R9,PC}       ;; return
    570          }
    571          
    572          static void sort_object(cJSON * const object, const cJSON_bool case_sensitive)
    573          {
    574              if (object == NULL)
    575              {
    576                  return;
    577              }
    578              object->child = sort_list(object->child, case_sensitive);
    579          }
    580          

   \                                 In segment CODE, align 4, keep-with-next
    581          static cJSON_bool compare_json(cJSON *a, cJSON *b, const cJSON_bool case_sensitive)
    582          {
   \                     compare_json:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0260A0E1           MOV      R6,R2
    583              if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   1C00000A           BEQ      ??compare_json_0
   \   0000001C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000020   0C2094E5           LDR      R2,[R4, #+12]
   \   00000024   FF0001E2           AND      R0,R1,#0xFF
   \   00000028   FF2002E2           AND      R2,R2,#0xFF
   \   0000002C   020050E1           CMP      R0,R2
   \   00000030   1600001A           BNE      ??compare_json_0
    584              {
    585                  /* mismatched type. */
    586                  return false;
    587              }
    588              switch (a->type & 0xFF)
   \   00000034   080095E5           LDR      R0,[R5, #+8]
   \   00000038   FF1001E2           AND      R1,R1,#0xFF
   \   0000003C   081051E2           SUBS     R1,R1,#+8
   \   00000040   0700000A           BEQ      ??compare_json_1
   \   00000044   081051E2           SUBS     R1,R1,#+8
   \   00000048   1200000A           BEQ      ??compare_json_2
   \   0000004C   101051E2           SUBS     R1,R1,#+16
   \   00000050   1700000A           BEQ      ??compare_json_3
   \   00000054   201051E2           SUBS     R1,R1,#+32
   \   00000058   2500000A           BEQ      ??compare_json_4
   \   0000005C   0100A0E3           MOV      R0,#+1
   \   00000060   7080BDE8           POP      {R4-R6,PC}
    589              {
    590                  case cJSON_Number:
    591                      /* numeric mismatch. */
    592                      if ((a->valueint != b->valueint) || (a->valuedouble != b->valuedouble))
   \                     ??compare_json_1:
   \   00000064   140095E5           LDR      R0,[R5, #+20]
   \   00000068   141094E5           LDR      R1,[R4, #+20]
   \   0000006C   010050E1           CMP      R0,R1
   \   00000070   0600001A           BNE      ??compare_json_0
   \   00000074   180095E5           LDR      R0,[R5, #+24]
   \   00000078   1C1095E5           LDR      R1,[R5, #+28]
   \   0000007C   182094E5           LDR      R2,[R4, #+24]
   \   00000080   1C3094E5           LDR      R3,[R4, #+28]
   \   00000084   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   0600000A           BEQ      ??compare_json_5
    593                      {
    594                          return false;
   \                     ??compare_json_0:
   \   00000090   0000A0E3           MOV      R0,#+0
   \   00000094   7080BDE8           POP      {R4-R6,PC}
    595                      }
    596                      else
    597                      {
    598                          return true;
    599                      }
    600          
    601                  case cJSON_String:
    602                      /* string mismatch. */
    603                      if (strcmp(a->valuestring, b->valuestring) != 0)
   \                     ??compare_json_2:
   \   00000098   100095E5           LDR      R0,[R5, #+16]
   \   0000009C   101094E5           LDR      R1,[R4, #+16]
   \   000000A0   190000EF           SWI      +25
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   F8FFFF1A           BNE      ??compare_json_0
    604                      {
    605                          return false;
    606                      }
    607                      else
    608                      {
    609                          return true;
   \                     ??compare_json_5:
   \   000000AC   0100A0E3           MOV      R0,#+1
   \   000000B0   7080BDE8           POP      {R4-R6,PC}
    610                      }
    611          
    612                  case cJSON_Array:
    613                      for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)
   \                     ??compare_json_3:
   \   000000B4   084094E5           LDR      R4,[R4, #+8]
   \   000000B8   0050A0E1           MOV      R5,R0
   \   000000BC   010000EA           B        ??compare_json_6
   \                     ??compare_json_7:
   \   000000C0   005095E5           LDR      R5,[R5, #+0]
   \   000000C4   004094E5           LDR      R4,[R4, #+0]
   \                     ??compare_json_6:
   \   000000C8   000055E3           CMP      R5,#+0
   \   000000CC   2500000A           BEQ      ??compare_json_8
   \   000000D0   000054E3           CMP      R4,#+0
   \   000000D4   EDFFFF0A           BEQ      ??compare_json_0
    614                      {
    615                          cJSON_bool identical = compare_json(a, b, case_sensitive);
    616                          if (!identical)
   \   000000D8   0620A0E1           MOV      R2,R6
   \   000000DC   0410A0E1           MOV      R1,R4
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   C5FFFFEB           BL       compare_json
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   F3FFFF1A           BNE      ??compare_json_7
    617                          {
    618                              return false;
   \   000000F0   7080BDE8           POP      {R4-R6,PC}
    619                          }
    620                      }
    621          
    622                      /* array size mismatch? (one of both children is not NULL) */
    623                      if ((a != NULL) || (b != NULL))
    624                      {
    625                          return false;
    626                      }
    627                      else
    628                      {
    629                          return true;
    630                      }
    631          
    632                  case cJSON_Object:
    633                      sort_object(a, case_sensitive);
   \                     ??compare_json_4:
   \   000000F4   0610A0E1           MOV      R1,R6
   \   000000F8   ........           BL       sort_list
   \   000000FC   080085E5           STR      R0,[R5, #+8]
   \   00000100   080094E5           LDR      R0,[R4, #+8]
   \   00000104   0610A0E1           MOV      R1,R6
   \   00000108   ........           BL       sort_list
   \   0000010C   080084E5           STR      R0,[R4, #+8]
    634                      sort_object(b, case_sensitive);
    635                      for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)
   \   00000110   085095E5           LDR      R5,[R5, #+8]
   \   00000114   0040A0E1           MOV      R4,R0
   \   00000118   010000EA           B        ??compare_json_9
   \                     ??compare_json_10:
   \   0000011C   005095E5           LDR      R5,[R5, #+0]
   \   00000120   004094E5           LDR      R4,[R4, #+0]
   \                     ??compare_json_9:
   \   00000124   000055E3           CMP      R5,#+0
   \   00000128   0E00000A           BEQ      ??compare_json_8
   \   0000012C   000054E3           CMP      R4,#+0
   \   00000130   D6FFFF0A           BEQ      ??compare_json_0
    636                      {
    637                          cJSON_bool identical = false;
    638                          /* compare object keys */
    639                          if (compare_strings((unsigned char*)a->string, (unsigned char*)b->string, case_sensitive))
   \   00000134   200095E5           LDR      R0,[R5, #+32]
   \   00000138   201094E5           LDR      R1,[R4, #+32]
   \   0000013C   0620A0E1           MOV      R2,R6
   \   00000140   ........           BL       compare_strings
   \   00000144   000050E3           CMP      R0,#+0
   \   00000148   D0FFFF1A           BNE      ??compare_json_0
    640                          {
    641                              /* missing member */
    642                              return false;
    643                          }
    644                          identical = compare_json(a, b, case_sensitive);
    645                          if (!identical)
   \   0000014C   0620A0E1           MOV      R2,R6
   \   00000150   0410A0E1           MOV      R1,R4
   \   00000154   0500A0E1           MOV      R0,R5
   \   00000158   A8FFFFEB           BL       compare_json
   \   0000015C   000050E3           CMP      R0,#+0
   \   00000160   EDFFFF1A           BNE      ??compare_json_10
    646                          {
    647                              return false;
   \   00000164   7080BDE8           POP      {R4-R6,PC}
    648                          }
    649                      }
    650          
    651                      /* object length mismatch (one of both children is not null) */
    652                      if ((a != NULL) || (b != NULL))
   \                     ??compare_json_8:
   \   00000168   000054E3           CMP      R4,#+0
   \   0000016C   CEFFFF0A           BEQ      ??compare_json_5
    653                      {
    654                          return false;
   \   00000170   0000A0E3           MOV      R0,#+0
   \   00000174   7080BDE8           POP      {R4-R6,PC}
    655                      }
    656                      else
    657                      {
    658                          return true;
    659                      }
    660          
    661                  default:
    662                      break;
    663              }
    664          
    665              /* null, true or false */
    666              return true;
    667          }
    668          
    669          /* non broken version of cJSON_InsertItemInArray */
    670          static cJSON_bool insert_item_in_array(cJSON *array, size_t which, cJSON *newitem)
    671          {
    672              cJSON *child = array->child;
    673              while (child && (which > 0))
    674              {
    675                  child = child->next;
    676                  which--;
    677              }
    678              if (which > 0)
    679              {
    680                  /* item is after the end of the array */
    681                  return 0;
    682              }
    683              if (child == NULL)
    684              {
    685                  cJSON_AddItemToArray(array, newitem);
    686                  return 1;
    687              }
    688          
    689              /* insert into the linked list */
    690              newitem->next = child;
    691              newitem->prev = child->prev;
    692              child->prev = newitem;
    693          
    694              /* was it at the beginning */
    695              if (child == array->child)
    696              {
    697                  array->child = newitem;
    698              }
    699              else
    700              {
    701                  newitem->prev->next = newitem;
    702              }
    703          
    704              return 1;
    705          }
    706          
    707          static cJSON *get_object_item(const cJSON * const object, const char* name, const cJSON_bool case_sensitive)
    708          {
    709              if (case_sensitive)
    710              {
    711                  return cJSON_GetObjectItemCaseSensitive(object, name);
    712              }
    713          
    714              return cJSON_GetObjectItem(object, name);
    715          }
    716          
    717          enum patch_operation { INVALID, ADD, REMOVE, REPLACE, MOVE, COPY, TEST };
    718          
    719          static enum patch_operation decode_patch_operation(const cJSON * const patch, const cJSON_bool case_sensitive)
    720          {
    721              cJSON *operation = get_object_item(patch, "op", case_sensitive);
    722              if (!cJSON_IsString(operation))
    723              {
    724                  return INVALID;
    725              }
    726          
    727              if (strcmp(operation->valuestring, "add") == 0)
    728              {
    729                  return ADD;
    730              }
    731          
    732              if (strcmp(operation->valuestring, "remove") == 0)
    733              {
    734                  return REMOVE;
    735              }
    736          
    737              if (strcmp(operation->valuestring, "replace") == 0)
    738              {
    739                  return REPLACE;
    740              }
    741          
    742              if (strcmp(operation->valuestring, "move") == 0)
    743              {
    744                  return MOVE;
    745              }
    746          
    747              if (strcmp(operation->valuestring, "copy") == 0)
    748              {
    749                  return COPY;
    750              }
    751          
    752              if (strcmp(operation->valuestring, "test") == 0)
    753              {
    754                  return TEST;
    755              }
    756          
    757              return INVALID;
    758          }
    759          
    760          /* overwrite and existing item with another one and free resources on the way */
    761          static void overwrite_item(cJSON * const root, const cJSON replacement)
    762          {
    763              if (root == NULL)
    764              {
    765                  return;
    766              }
    767          
    768              if (root->string != NULL)
    769              {
    770                  cJSON_free(root->string);
    771              }
    772              if (root->valuestring != NULL)
    773              {
    774                  cJSON_free(root->valuestring);
    775              }
    776              if (root->child != NULL)
    777              {
    778                  cJSON_Delete(root->child);
    779              }
    780          
    781              memcpy(root, &replacement, sizeof(cJSON));
    782          }
    783          

   \                                 In segment CODE, align 4, keep-with-next
    784          static int apply_patch(cJSON *object, const cJSON *patch, const cJSON_bool case_sensitive)
    785          {
   \                     apply_patch:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    786              cJSON *path = NULL;
    787              cJSON *value = NULL;
    788              cJSON *parent = NULL;
    789              enum patch_operation opcode = INVALID;
    790              unsigned char *parent_pointer = NULL;
    791              unsigned char *child_pointer = NULL;
    792              int status = 0;
    793          
    794              path = get_object_item(patch, "path", case_sensitive);
   \   00000004   ........           LDR      R10,??DataTable10  ;; ??invalid
   \   00000008   2CD04DE2           SUB      SP,SP,#+44
   \   0000000C   0050A0E1           MOV      R5,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   0080A0E3           MOV      R8,#+0
   \   0000001C   0090A0E3           MOV      R9,#+0
   \   00000020   04808DE5           STR      R8,[SP, #+4]
   \   00000024   0840A0E1           MOV      R4,R8
   \   00000028   000057E3           CMP      R7,#+0
   \   0000002C   4C108AE2           ADD      R1,R10,#+76
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   0100000A           BEQ      ??apply_patch_0
   \   00000038   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   0000003C   000000EA           B        ??apply_patch_1
   \                     ??apply_patch_0:
   \   00000040   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_1:
   \   00000044   00008DE5           STR      R0,[SP, #+0]
    795              if (!cJSON_IsString(path))
   \   00000048   ........           _BLF     cJSON_IsString,??cJSON_IsString??rA
   \   0000004C   000050E3           CMP      R0,#+0
    796              {
    797                  /* malformed patch. */
    798                  status = 2;
   \   00000050   0240A003           MOVEQ    R4,#+2
    799                  goto cleanup;
   \   00000054   7A00000A           BEQ      ??apply_patch_2
    800              }
    801          
    802              opcode = decode_patch_operation(patch, case_sensitive);
   \   00000058   DE1F8FE2           ADR      R1,??apply_patch_3  ;; "op"
   \   0000005C   000057E3           CMP      R7,#+0
   \   00000060   0600A0E1           MOV      R0,R6
   \   00000064   0100000A           BEQ      ??apply_patch_4
   \   00000068   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   0000006C   000000EA           B        ??apply_patch_5
   \                     ??apply_patch_4:
   \   00000070   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_5:
   \   00000074   00B0A0E1           MOV      R11,R0
   \   00000078   ........           _BLF     cJSON_IsString,??cJSON_IsString??rA
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   5500000A           BEQ      ??apply_patch_6
   \   00000084   10009BE5           LDR      R0,[R11, #+16]
   \   00000088   D31F8FE2           ADR      R1,??apply_patch_3+0x4  ;; "add"
   \   0000008C   190000EF           SWI      +25
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   1F00001A           BNE      ??apply_patch_7
   \   00000098   01B0A0E3           MOV      R11,#+1
    803              if (opcode == INVALID)
    804              {
    805                  status = 3;
    806                  goto cleanup;
    807              }
    808              else if (opcode == TEST)
    809              {
    810                  /* compare value: {...} with the given path */
    811                  status = !compare_json(get_item_from_pointer(object, path->valuestring, case_sensitive), get_object_item(patch, "value", case_sensitive), case_sensitive);
    812                  goto cleanup;
    813              }
    814          
    815              /* special case for replacing the root */
    816              if (path->valuestring[0] == '\0')
   \                     ??apply_patch_8:
   \   0000009C   00009DE5           LDR      R0,[SP, #+0]
   \   000000A0   101090E5           LDR      R1,[R0, #+16]
   \   000000A4   0000D1E5           LDRB     R0,[R1, #+0]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   8D00001A           BNE      ??apply_patch_9
    817              {
    818                  if (opcode == REMOVE)
   \   000000B0   02005BE3           CMP      R11,#+2
   \   000000B4   4C00001A           BNE      ??apply_patch_10
    819                  {
    820                      static const cJSON invalid = { NULL, NULL, NULL, cJSON_Invalid, NULL, 0, 0, NULL};
    821          
    822                      overwrite_item(object, invalid);
   \   000000B8   CE00BAE8           LDM      R10!,{R1-R3,R6,R7}
   \   000000BC   08008DE2           ADD      R0,SP,#+8
   \   000000C0   CE00A0E8           STM      R0!,{R1-R3,R6,R7}
   \   000000C4   4E009AE8           LDM      R10,{R1-R3,R6}
   \   000000C8   000055E3           CMP      R5,#+0
   \   000000CC   4E0080E8           STM      R0,{R1-R3,R6}
   \   000000D0   5B00000A           BEQ      ??apply_patch_2
   \   000000D4   200095E5           LDR      R0,[R5, #+32]
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   0000000A           BEQ      ??apply_patch_11
   \   000000E0   ........           _BLF     cJSON_free,??cJSON_free??rA
   \                     ??apply_patch_11:
   \   000000E4   100095E5           LDR      R0,[R5, #+16]
   \   000000E8   000050E3           CMP      R0,#+0
   \   000000EC   0000000A           BEQ      ??apply_patch_12
   \   000000F0   ........           _BLF     cJSON_free,??cJSON_free??rA
   \                     ??apply_patch_12:
   \   000000F4   080095E5           LDR      R0,[R5, #+8]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   0000000A           BEQ      ??apply_patch_13
   \   00000100   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   \                     ??apply_patch_13:
   \   00000104   2420A0E3           MOV      R2,#+36
   \   00000108   08108DE2           ADD      R1,SP,#+8
   \   0000010C   0500A0E1           MOV      R0,R5
   \   00000110   1E0100EF           SWI      +286
   \   00000114   2D0000EA           B        ??apply_patch_14
    823          
    824                      status = 0;
    825                      goto cleanup;
    826                  }
   \                     ??apply_patch_7:
   \   00000118   10009BE5           LDR      R0,[R11, #+16]
   \   0000011C   24108AE2           ADD      R1,R10,#+36
   \   00000120   190000EF           SWI      +25
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   02B0A003           MOVEQ    R11,#+2
   \   0000012C   DAFFFF0A           BEQ      ??apply_patch_8
   \   00000130   10009BE5           LDR      R0,[R11, #+16]
   \   00000134   2C108AE2           ADD      R1,R10,#+44
   \   00000138   190000EF           SWI      +25
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   03B0A003           MOVEQ    R11,#+3
   \   00000144   D4FFFF0A           BEQ      ??apply_patch_8
   \   00000148   10009BE5           LDR      R0,[R11, #+16]
   \   0000014C   34108AE2           ADD      R1,R10,#+52
   \   00000150   190000EF           SWI      +25
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   04B0A003           MOVEQ    R11,#+4
   \   0000015C   CEFFFF0A           BEQ      ??apply_patch_8
   \   00000160   10009BE5           LDR      R0,[R11, #+16]
   \   00000164   3C108AE2           ADD      R1,R10,#+60
   \   00000168   190000EF           SWI      +25
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   05B0A003           MOVEQ    R11,#+5
   \   00000174   C8FFFF0A           BEQ      ??apply_patch_8
   \   00000178   10009BE5           LDR      R0,[R11, #+16]
   \   0000017C   44108AE2           ADD      R1,R10,#+68
   \   00000180   190000EF           SWI      +25
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   1300001A           BNE      ??apply_patch_6
   \   0000018C   000057E3           CMP      R7,#+0
   \   00000190   54108AE2           ADD      R1,R10,#+84
   \   00000194   0600A0E1           MOV      R0,R6
   \   00000198   1100001A           BNE      ??apply_patch_15
   \   0000019C   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_16:
   \   000001A0   0060A0E1           MOV      R6,R0
   \   000001A4   00009DE5           LDR      R0,[SP, #+0]
   \   000001A8   0720A0E1           MOV      R2,R7
   \   000001AC   101090E5           LDR      R1,[R0, #+16]
   \   000001B0   0500A0E1           MOV      R0,R5
   \   000001B4   ........           BL       get_item_from_pointer
   \   000001B8   0720A0E1           MOV      R2,R7
   \   000001BC   0610A0E1           MOV      R1,R6
   \   000001C0   ........           BL       compare_json
   \   000001C4   000050E3           CMP      R0,#+0
   \   000001C8   1D00001A           BNE      ??apply_patch_2
   \   000001CC   0140A0E3           MOV      R4,#+1
   \                     ??apply_patch_14:
   \   000001D0   0400A0E1           MOV      R0,R4
   \   000001D4   2CD08DE2           ADD      SP,SP,#+44
   \   000001D8   F08FBDE8           POP      {R4-R11,PC}
   \                     ??apply_patch_6:
   \   000001DC   0340A0E3           MOV      R4,#+3
   \   000001E0   FAFFFFEA           B        ??apply_patch_14
   \                     ??apply_patch_15:
   \   000001E4   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   000001E8   ECFFFFEA           B        ??apply_patch_16
    827          
    828                  if ((opcode == REPLACE) || (opcode == ADD))
   \                     ??apply_patch_10:
   \   000001EC   03005BE3           CMP      R11,#+3
   \   000001F0   01005B13           CMPNE    R11,#+1
   \   000001F4   3B00001A           BNE      ??apply_patch_9
    829                  {
    830                      value = get_object_item(patch, "value", case_sensitive);
   \   000001F8   000057E3           CMP      R7,#+0
   \   000001FC   54108AE2           ADD      R1,R10,#+84
   \   00000200   0600A0E1           MOV      R0,R6
   \   00000204   0100000A           BEQ      ??apply_patch_17
   \   00000208   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   0000020C   000000EA           B        ??apply_patch_18
   \                     ??apply_patch_17:
   \   00000210   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_18:
   \   00000214   0090A0E1           MOV      R9,R0
    831                      if (value == NULL)
   \   00000218   000059E3           CMP      R9,#+0
   \   0000021C   0B00001A           BNE      ??apply_patch_19
    832                      {
    833                          /* missing "value" for add/replace. */
    834                          status = 7;
   \                     ??apply_patch_20:
   \   00000220   0740A0E3           MOV      R4,#+7
    835                          goto cleanup;
    836                      }
    837          
    838                      value = cJSON_Duplicate(value, 1);
    839                      if (value == NULL)
    840                      {
    841                          /* out of memory for add/replace. */
    842                          status = 8;
    843                          goto cleanup;
    844                      }
    845          
    846                      overwrite_item(object, *value);
    847          
    848                      /* delete the duplicated value */
    849                      cJSON_free(value);
    850                      value = NULL;
    851          
    852                      /* the string "value" isn't needed */
    853                      if (object->string != NULL)
    854                      {
    855                          cJSON_free(object->string);
    856                          object->string = NULL;
    857                      }
    858          
    859                      status = 0;
    860                      goto cleanup;
    861                  }
    862              }
    863          
    864              if ((opcode == REMOVE) || (opcode == REPLACE))
    865              {
    866                  /* Get rid of old. */
    867                  cJSON *old_item = detach_path(object, (unsigned char*)path->valuestring, case_sensitive);
    868                  if (old_item == NULL)
    869                  {
    870                      status = 13;
    871                      goto cleanup;
    872                  }
    873                  cJSON_Delete(old_item);
    874                  if (opcode == REMOVE)
    875                  {
    876                      /* For Remove, this job is done. */
    877                      status = 0;
    878                      goto cleanup;
    879                  }
    880              }
    881          
    882              /* Copy/Move uses "from". */
    883              if ((opcode == MOVE) || (opcode == COPY))
    884              {
    885                  cJSON *from = get_object_item(patch, "from", case_sensitive);
    886                  if (from == NULL)
    887                  {
    888                      /* missing "from" for copy/move. */
    889                      status = 4;
    890                      goto cleanup;
    891                  }
    892          
    893                  if (opcode == MOVE)
    894                  {
    895                      value = detach_path(object, (unsigned char*)from->valuestring, case_sensitive);
    896                  }
    897                  if (opcode == COPY)
    898                  {
    899                      value = get_item_from_pointer(object, from->valuestring, case_sensitive);
    900                  }
    901                  if (value == NULL)
    902                  {
    903                      /* missing "from" for copy/move. */
    904                      status = 5;
    905                      goto cleanup;
    906                  }
    907                  if (opcode == COPY)
    908                  {
    909                      value = cJSON_Duplicate(value, 1);
    910                  }
    911                  if (value == NULL)
    912                  {
    913                      /* out of memory for copy/move. */
    914                      status = 6;
    915                      goto cleanup;
    916                  }
    917              }
    918              else /* Add/Replace uses "value". */
    919              {
    920                  value = get_object_item(patch, "value", case_sensitive);
    921                  if (value == NULL)
    922                  {
    923                      /* missing "value" for add/replace. */
    924                      status = 7;
    925                      goto cleanup;
    926                  }
    927                  value = cJSON_Duplicate(value, 1);
    928                  if (value == NULL)
    929                  {
    930                      /* out of memory for add/replace. */
    931                      status = 8;
    932                      goto cleanup;
    933                  }
    934              }
    935          
    936              /* Now, just add "value" to "path". */
    937          
    938              /* split pointer in parent and child */
    939              parent_pointer = cJSONUtils_strdup((unsigned char*)path->valuestring);
    940              child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/');
    941              if (child_pointer != NULL)
    942              {
    943                  child_pointer[0] = '\0';
    944                  child_pointer++;
    945              }
    946              parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);
    947              decode_pointer_inplace(child_pointer);
    948          
    949              /* add, remove, replace, move, copy, test. */
    950              if ((parent == NULL) || (child_pointer == NULL))
    951              {
    952                  /* Couldn't find object to add to. */
    953                  status = 9;
    954                  goto cleanup;
    955              }
    956              else if (cJSON_IsArray(parent))
    957              {
    958                  if (strcmp((char*)child_pointer, "-") == 0)
    959                  {
    960                      cJSON_AddItemToArray(parent, value);
    961                      value = NULL;
    962                  }
    963                  else
    964                  {
    965                      size_t index = 0;
    966                      if (!decode_array_index_from_pointer(child_pointer, &index))
    967                      {
    968                          status = 11;
    969                          goto cleanup;
    970                      }
    971          
    972                      if (!insert_item_in_array(parent, index, value))
    973                      {
    974                          status = 10;
    975                          goto cleanup;
    976                      }
    977                      value = NULL;
    978                  }
    979              }
    980              else if (cJSON_IsObject(parent))
    981              {
    982                  if (case_sensitive)
    983                  {
    984                      cJSON_DeleteItemFromObjectCaseSensitive(parent, (char*)child_pointer);
    985                  }
    986                  else
    987                  {
    988                      cJSON_DeleteItemFromObject(parent, (char*)child_pointer);
    989                  }
    990                  cJSON_AddItemToObject(parent, (char*)child_pointer, value);
    991                  value = NULL;
    992              }
    993              else /* parent is not an object */
    994              {
    995                  /* Couldn't find object to add to. */
    996                  status = 9;
    997                  goto cleanup;
    998              }
    999          
   1000          cleanup:
   1001              if (value != NULL)
   \                     ??apply_patch_21:
   \   00000224   000059E3           CMP      R9,#+0
   \   00000228   0100000A           BEQ      ??apply_patch_22
   1002              {
   1003                  cJSON_Delete(value);
   \   0000022C   0900A0E1           MOV      R0,R9
   \   00000230   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1004              }
   1005              if (parent_pointer != NULL)
   \                     ??apply_patch_22:
   \   00000234   04009DE5           LDR      R0,[SP, #+4]
   \   00000238   000050E3           CMP      R0,#+0
   \   0000023C   0000000A           BEQ      ??apply_patch_2
   1006              {
   1007                  cJSON_free(parent_pointer);
   \   00000240   ........           _BLF     cJSON_free,??cJSON_free??rA
   1008              }
   1009          
   1010              return status;
   \                     ??apply_patch_2:
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   2CD08DE2           ADD      SP,SP,#+44
   \   0000024C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??apply_patch_19:
   \   00000250   0110A0E3           MOV      R1,#+1
   \   00000254   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000258   0090B0E1           MOVS     R9,R0
   \   0000025C   0100001A           BNE      ??apply_patch_23
   \                     ??apply_patch_24:
   \   00000260   0840A0E3           MOV      R4,#+8
   \   00000264   EEFFFFEA           B        ??apply_patch_21
   \                     ??apply_patch_23:
   \   00000268   08008DE2           ADD      R0,SP,#+8
   \   0000026C   0910A0E1           MOV      R1,R9
   \   00000270   CC04B1E8           LDM      R1!,{R2,R3,R6,R7,R10}
   \   00000274   000055E3           CMP      R5,#+0
   \   00000278   CC04A0E8           STM      R0!,{R2,R3,R6,R7,R10}
   \   0000027C   CC0091E8           LDM      R1,{R2,R3,R6,R7}
   \   00000280   CC0080E8           STM      R0,{R2,R3,R6,R7}
   \   00000284   0F00000A           BEQ      ??apply_patch_25
   \   00000288   200095E5           LDR      R0,[R5, #+32]
   \   0000028C   000050E3           CMP      R0,#+0
   \   00000290   0000000A           BEQ      ??apply_patch_26
   \   00000294   ........           _BLF     cJSON_free,??cJSON_free??rA
   \                     ??apply_patch_26:
   \   00000298   100095E5           LDR      R0,[R5, #+16]
   \   0000029C   000050E3           CMP      R0,#+0
   \   000002A0   0000000A           BEQ      ??apply_patch_27
   \   000002A4   ........           _BLF     cJSON_free,??cJSON_free??rA
   \                     ??apply_patch_27:
   \   000002A8   080095E5           LDR      R0,[R5, #+8]
   \   000002AC   000050E3           CMP      R0,#+0
   \   000002B0   0000000A           BEQ      ??apply_patch_28
   \   000002B4   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   \                     ??apply_patch_28:
   \   000002B8   2420A0E3           MOV      R2,#+36
   \   000002BC   08108DE2           ADD      R1,SP,#+8
   \   000002C0   0500A0E1           MOV      R0,R5
   \   000002C4   1E0100EF           SWI      +286
   \                     ??apply_patch_25:
   \   000002C8   0900A0E1           MOV      R0,R9
   \   000002CC   ........           _BLF     cJSON_free,??cJSON_free??rA
   \   000002D0   200095E5           LDR      R0,[R5, #+32]
   \   000002D4   000050E3           CMP      R0,#+0
   \   000002D8   D9FFFF0A           BEQ      ??apply_patch_2
   \   000002DC   ........           _BLF     cJSON_free,??cJSON_free??rA
   \   000002E0   208085E5           STR      R8,[R5, #+32]
   \   000002E4   B9FFFFEA           B        ??apply_patch_14
   \                     ??apply_patch_9:
   \   000002E8   0B00A0E1           MOV      R0,R11
   \   000002EC   020050E3           CMP      R0,#+2
   \   000002F0   03005013           CMPNE    R0,#+3
   \   000002F4   0900001A           BNE      ??apply_patch_29
   \   000002F8   0720A0E1           MOV      R2,R7
   \   000002FC   0500A0E1           MOV      R0,R5
   \   00000300   ........           BL       detach_path
   \   00000304   000050E3           CMP      R0,#+0
   \   00000308   0D40A003           MOVEQ    R4,#+13
   \   0000030C   CCFFFF0A           BEQ      ??apply_patch_2
   \   00000310   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   \   00000314   0B00A0E1           MOV      R0,R11
   \   00000318   020050E3           CMP      R0,#+2
   \   0000031C   C8FFFF0A           BEQ      ??apply_patch_2
   \                     ??apply_patch_29:
   \   00000320   040050E3           CMP      R0,#+4
   \   00000324   05005013           CMPNE    R0,#+5
   \   00000328   2400001A           BNE      ??apply_patch_30
   \   0000032C   000057E3           CMP      R7,#+0
   \   00000330   5C108AE2           ADD      R1,R10,#+92
   \   00000334   0600A0E1           MOV      R0,R6
   \   00000338   0100000A           BEQ      ??apply_patch_31
   \   0000033C   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   00000340   000000EA           B        ??apply_patch_32
   \                     ??apply_patch_31:
   \   00000344   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_32:
   \   00000348   0060A0E1           MOV      R6,R0
   \   0000034C   000056E3           CMP      R6,#+0
   \   00000350   0440A003           MOVEQ    R4,#+4
   \   00000354   BAFFFF0A           BEQ      ??apply_patch_2
   \   00000358   04005BE3           CMP      R11,#+4
   \   0000035C   0400001A           BNE      ??apply_patch_33
   \   00000360   101096E5           LDR      R1,[R6, #+16]
   \   00000364   0720A0E1           MOV      R2,R7
   \   00000368   0500A0E1           MOV      R0,R5
   \   0000036C   ........           BL       detach_path
   \   00000370   0090A0E1           MOV      R9,R0
   \                     ??apply_patch_33:
   \   00000374   05005BE3           CMP      R11,#+5
   \   00000378   0400001A           BNE      ??apply_patch_34
   \   0000037C   101096E5           LDR      R1,[R6, #+16]
   \   00000380   0720A0E1           MOV      R2,R7
   \   00000384   0500A0E1           MOV      R0,R5
   \   00000388   ........           BL       get_item_from_pointer
   \   0000038C   0090A0E1           MOV      R9,R0
   \                     ??apply_patch_34:
   \   00000390   000059E3           CMP      R9,#+0
   \   00000394   0540A003           MOVEQ    R4,#+5
   \   00000398   A9FFFF0A           BEQ      ??apply_patch_2
   \   0000039C   05005BE3           CMP      R11,#+5
   \   000003A0   1600001A           BNE      ??apply_patch_35
   \   000003A4   0110A0E3           MOV      R1,#+1
   \   000003A8   0900A0E1           MOV      R0,R9
   \   000003AC   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000003B0   0090B0E1           MOVS     R9,R0
   \   000003B4   1100001A           BNE      ??apply_patch_35
   \   000003B8   0640A0E3           MOV      R4,#+6
   \   000003BC   83FFFFEA           B        ??apply_patch_14
   \                     ??apply_patch_30:
   \   000003C0   000057E3           CMP      R7,#+0
   \   000003C4   54108AE2           ADD      R1,R10,#+84
   \   000003C8   0600A0E1           MOV      R0,R6
   \   000003CC   0300000A           BEQ      ??apply_patch_36
   \   000003D0   ........           _BLF     cJSON_GetObjectItemCaseSensitive,??cJSON_GetObjectItemCaseSensitive??rA
   \   000003D4   020000EA           B        ??apply_patch_37
   \                     ??apply_patch_3:
   \   000003D8   6F700000           DC8      "op",+0
   \   000003DC   61646400           DC8      "add"
   \                     ??apply_patch_36:
   \   000003E0   ........           _BLF     cJSON_GetObjectItem,??cJSON_GetObjectItem??rA
   \                     ??apply_patch_37:
   \   000003E4   0090A0E1           MOV      R9,R0
   \   000003E8   000059E3           CMP      R9,#+0
   \   000003EC   8BFFFF0A           BEQ      ??apply_patch_20
   \   000003F0   0110A0E3           MOV      R1,#+1
   \   000003F4   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   000003F8   0090B0E1           MOVS     R9,R0
   \   000003FC   97FFFF0A           BEQ      ??apply_patch_24
   \                     ??apply_patch_35:
   \   00000400   00009DE5           LDR      R0,[SP, #+0]
   \   00000404   10A090E5           LDR      R10,[R0, #+16]
   \   00000408   0A00A0E1           MOV      R0,R10
   \   0000040C   1B0000EF           SWI      +27
   \   00000410   01B080E2           ADD      R11,R0,#+1
   \   00000414   0B00A0E1           MOV      R0,R11
   \   00000418   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   0000041C   0060B0E1           MOVS     R6,R0
   \   00000420   0300000A           BEQ      ??apply_patch_38
   \   00000424   0B20A0E1           MOV      R2,R11
   \   00000428   0A10A0E1           MOV      R1,R10
   \   0000042C   1E0100EF           SWI      +286
   \   00000430   04608DE5           STR      R6,[SP, #+4]
   \                     ??apply_patch_38:
   \   00000434   04009DE5           LDR      R0,[SP, #+4]
   \   00000438   2F10A0E3           MOV      R1,#+47
   \   0000043C   170100EF           SWI      +279
   \   00000440   0060B0E1           MOVS     R6,R0
   \   00000444   ........           STRBNE   R8,[R6], #+1
   \   00000448   04109DE5           LDR      R1,[SP, #+4]
   \   0000044C   0720A0E1           MOV      R2,R7
   \   00000450   0500A0E1           MOV      R0,R5
   \   00000454   ........           BL       get_item_from_pointer
   \   00000458   0050A0E1           MOV      R5,R0
   \   0000045C   0600A0E1           MOV      R0,R6
   \   00000460   0010B0E1           MOVS     R1,R0
   \   00000464   0700001A           BNE      ??apply_patch_39
   \   00000468   120000EA           B        ??apply_patch_40
   \                     ??apply_patch_41:
   \   0000046C   310052E3           CMP      R2,#+49
   \   00000470   1000001A           BNE      ??apply_patch_40
   \   00000474   2F20A0E3           MOV      R2,#+47
   \   00000478   0120C1E5           STRB     R2,[R1, #+1]
   \                     ??apply_patch_42:
   \   0000047C   010080E2           ADD      R0,R0,#+1
   \                     ??apply_patch_43:
   \   00000480   011081E2           ADD      R1,R1,#+1
   \   00000484   010080E2           ADD      R0,R0,#+1
   \                     ??apply_patch_39:
   \   00000488   0020D0E5           LDRB     R2,[R0, #+0]
   \   0000048C   000052E3           CMP      R2,#+0
   \   00000490   0700000A           BEQ      ??apply_patch_44
   \   00000494   7E0052E3           CMP      R2,#+126
   \   00000498   F8FFFF1A           BNE      ??apply_patch_43
   \   0000049C   0120D0E5           LDRB     R2,[R0, #+1]
   \   000004A0   300052E3           CMP      R2,#+48
   \   000004A4   F0FFFF1A           BNE      ??apply_patch_41
   \   000004A8   7E20A0E3           MOV      R2,#+126
   \   000004AC   0020C1E5           STRB     R2,[R1, #+0]
   \   000004B0   F1FFFFEA           B        ??apply_patch_42
   \                     ??apply_patch_44:
   \   000004B4   0080C1E5           STRB     R8,[R1, #+0]
   \                     ??apply_patch_40:
   \   000004B8   000055E3           CMP      R5,#+0
   \   000004BC   00005613           CMPNE    R6,#+0
   \   000004C0   0100001A           BNE      ??apply_patch_45
   \                     ??apply_patch_46:
   \   000004C4   0940A0E3           MOV      R4,#+9
   \   000004C8   55FFFFEA           B        ??apply_patch_21
   \                     ??apply_patch_45:
   \   000004CC   0500A0E1           MOV      R0,R5
   \   000004D0   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   000004D4   000050E3           CMP      R0,#+0
   \   000004D8   2600000A           BEQ      ??apply_patch_47
   \   000004DC   ........           ADR      R1,??DataTable1  ;; "-"
   \   000004E0   0600A0E1           MOV      R0,R6
   \   000004E4   190000EF           SWI      +25
   \   000004E8   000050E3           CMP      R0,#+0
   \   000004EC   0300001A           BNE      ??apply_patch_48
   \                     ??apply_patch_49:
   \   000004F0   0910A0E1           MOV      R1,R9
   \   000004F4   0500A0E1           MOV      R0,R5
   \   000004F8   ........           _BLF     cJSON_AddItemToArray,??cJSON_AddItemToArray??rA
   \   000004FC   4CFFFFEA           B        ??apply_patch_22
   \                     ??apply_patch_48:
   \   00000500   00808DE5           STR      R8,[SP, #+0]
   \   00000504   0D10A0E1           MOV      R1,SP
   \   00000508   0600A0E1           MOV      R0,R6
   \   0000050C   ........           BL       decode_array_index_from_pointer
   \   00000510   000050E3           CMP      R0,#+0
   \   00000514   0B40A003           MOVEQ    R4,#+11
   \   00000518   41FFFF0A           BEQ      ??apply_patch_21
   \   0000051C   00009DE5           LDR      R0,[SP, #+0]
   \   00000520   081095E5           LDR      R1,[R5, #+8]
   \   00000524   010000EA           B        ??apply_patch_50
   \                     ??apply_patch_51:
   \   00000528   001091E5           LDR      R1,[R1, #+0]
   \   0000052C   010040E2           SUB      R0,R0,#+1
   \                     ??apply_patch_50:
   \   00000530   000051E3           CMP      R1,#+0
   \   00000534   00005013           CMPNE    R0,#+0
   \   00000538   FAFFFF1A           BNE      ??apply_patch_51
   \   0000053C   000050E3           CMP      R0,#+0
   \   00000540   0A40A013           MOVNE    R4,#+10
   \   00000544   36FFFF1A           BNE      ??apply_patch_21
   \   00000548   000051E3           CMP      R1,#+0
   \   0000054C   E7FFFF0A           BEQ      ??apply_patch_49
   \   00000550   001089E5           STR      R1,[R9, #+0]
   \   00000554   040091E5           LDR      R0,[R1, #+4]
   \   00000558   040089E5           STR      R0,[R9, #+4]
   \   0000055C   049081E5           STR      R9,[R1, #+4]
   \   00000560   080095E5           LDR      R0,[R5, #+8]
   \   00000564   000051E1           CMP      R1,R0
   \   00000568   04009915           LDRNE    R0,[R9, #+4]
   \   0000056C   08908505           STREQ    R9,[R5, #+8]
   \   00000570   00908015           STRNE    R9,[R0, #+0]
   \   00000574   2EFFFFEA           B        ??apply_patch_22
   \                     ??apply_patch_47:
   \   00000578   0500A0E1           MOV      R0,R5
   \   0000057C   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000580   000050E3           CMP      R0,#+0
   \   00000584   CEFFFF0A           BEQ      ??apply_patch_46
   \   00000588   000057E3           CMP      R7,#+0
   \   0000058C   0610A0E1           MOV      R1,R6
   \   00000590   0500A0E1           MOV      R0,R5
   \   00000594   0100000A           BEQ      ??apply_patch_52
   \   00000598   ........           _BLF     cJSON_DeleteItemFromObjectCaseSensitive,??cJSON_DeleteItemFromObjectCaseSensitive??rA
   \   0000059C   000000EA           B        ??apply_patch_53
   \                     ??apply_patch_52:
   \   000005A0   ........           _BLF     cJSON_DeleteItemFromObject,??cJSON_DeleteItemFromObject??rA
   \                     ??apply_patch_53:
   \   000005A4   0920A0E1           MOV      R2,R9
   \   000005A8   0610A0E1           MOV      R1,R6
   \   000005AC   0500A0E1           MOV      R0,R5
   \   000005B0   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   000005B4   1EFFFFEA           B        ??apply_patch_22
   1011          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     ??invalid:
   \   00000000   000000000000       DC32 0H, 0H, 0H, 0, 0H, 0, 0H, 0H, 0H
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \   00000024   72656D6F7665       DC8 "remove"
   \              00          
   \   0000002B   00                 DC8 0
   \   0000002C   7265706C6163       DC8 "replace"
   \              6500        
   \   00000034   6D6F766500         DC8 "move"
   \   00000039   000000             DC8 0, 0, 0
   \   0000003C   636F707900         DC8 "copy"
   \   00000041   000000             DC8 0, 0, 0
   \   00000044   7465737400         DC8 "test"
   \   00000049   000000             DC8 0, 0, 0
   \   0000004C   7061746800         DC8 "path"
   \   00000051   000000             DC8 0, 0, 0
   \   00000054   76616C756500       DC8 "value"
   \   0000005A   0000               DC8 0, 0
   \   0000005C   66726F6D00         DC8 "from"
   \   00000061   000000             DC8 0, 0, 0
   \   00000064   25732F256C75       DC8 "%s/%lu"
   \              00          
   \   0000006B   00                 DC8 0
   1012          

   \                                 In segment CODE, align 4, keep-with-next
   1013          CJSON_PUBLIC(int) cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches)
   1014          {
   \                     cJSONUtils_ApplyPatches:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1015              const cJSON *current_patch = NULL;
   1016              int status = 0;
   1017          
   1018              if (!cJSON_IsArray(patches))
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000014   000050E3           CMP      R0,#+0
   1019              {
   1020                  /* malformed patches. */
   1021                  return 1;
   \   00000018   0100A003           MOVEQ    R0,#+1
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
   1022              }
   1023          
   1024              if (patches != NULL)
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0B00000A           BEQ      ??cJSONUtils_ApplyPatches_0
   1025              {
   1026                  current_patch = patches->child;
   \   00000028   085095E5           LDR      R5,[R5, #+8]
   \   0000002C   000000EA           B        ??cJSONUtils_ApplyPatches_1
   1027              }
   1028          
   1029              while (current_patch != NULL)
   1030              {
   1031                  status = apply_patch(object, current_patch, false);
   1032                  if (status != 0)
   1033                  {
   1034                      return status;
   1035                  }
   1036                  current_patch = current_patch->next;
   \                     ??cJSONUtils_ApplyPatches_2:
   \   00000030   005095E5           LDR      R5,[R5, #+0]
   \                     ??cJSONUtils_ApplyPatches_1:
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0600000A           BEQ      ??cJSONUtils_ApplyPatches_0
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       apply_patch
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F6FFFF0A           BEQ      ??cJSONUtils_ApplyPatches_2
   \   00000054   3080BDE8           POP      {R4,R5,PC}
   1037              }
   1038          
   1039              return 0;
   \                     ??cJSONUtils_ApplyPatches_0:
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1040          }
   1041          

   \                                 In segment CODE, align 4, keep-with-next
   1042          CJSON_PUBLIC(int) cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches)
   1043          {
   \                     cJSONUtils_ApplyPatchesCaseSensitive:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1044              const cJSON *current_patch = NULL;
   1045              int status = 0;
   1046          
   1047              if (!cJSON_IsArray(patches))
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     cJSON_IsArray,??cJSON_IsArray??rA
   \   00000014   000050E3           CMP      R0,#+0
   1048              {
   1049                  /* malformed patches. */
   1050                  return 1;
   \   00000018   0100A003           MOVEQ    R0,#+1
   \   0000001C   3080BD08           POPEQ    {R4,R5,PC}
   1051              }
   1052          
   1053              if (patches != NULL)
   \   00000020   000055E3           CMP      R5,#+0
   \   00000024   0B00000A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_0
   1054              {
   1055                  current_patch = patches->child;
   \   00000028   085095E5           LDR      R5,[R5, #+8]
   \   0000002C   000000EA           B        ??cJSONUtils_ApplyPatchesCaseSensitive_1
   1056              }
   1057          
   1058              while (current_patch != NULL)
   1059              {
   1060                  status = apply_patch(object, current_patch, true);
   1061                  if (status != 0)
   1062                  {
   1063                      return status;
   1064                  }
   1065                  current_patch = current_patch->next;
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_2:
   \   00000030   005095E5           LDR      R5,[R5, #+0]
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_1:
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0600000A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_0
   \   0000003C   0120A0E3           MOV      R2,#+1
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           BL       apply_patch
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F6FFFF0A           BEQ      ??cJSONUtils_ApplyPatchesCaseSensitive_2
   \   00000054   3080BDE8           POP      {R4,R5,PC}
   1066              }
   1067          
   1068              return 0;
   \                     ??cJSONUtils_ApplyPatchesCaseSensitive_0:
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   3080BDE8           POP      {R4,R5,PC}       ;; return
   1069          }
   1070          

   \                                 In segment CODE, align 4, keep-with-next
   1071          static void compose_patch(cJSON * const patches, const unsigned char * const operation, const unsigned char * const path, const unsigned char *suffix, const cJSON * const value)
   1072          {
   \                     compose_patch:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24709DE5           LDR      R7,[SP, #+36]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0290A0E1           MOV      R9,R2
   \   00000014   03A0A0E1           MOV      R10,R3
   1073              cJSON *patch = NULL;
   1074          
   1075              if ((patches == NULL) || (operation == NULL) || (path == NULL))
   \   00000018   000054E3           CMP      R4,#+0
   \   0000001C   00005613           CMPNE    R6,#+0
   \   00000020   00005913           CMPNE    R9,#+0
   \   00000024   F08FBD08           POPEQ    {R4-R11,PC}
   1076              {
   1077                  return;
   1078              }
   1079          
   1080              patch = cJSON_CreateObject();
   \   00000028   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   0000002C   0050B0E1           MOVS     R5,R0
   1081              if (patch == NULL)
   \   00000030   F08FBD08           POPEQ    {R4-R11,PC}
   1082              {
   1083                  return;
   1084              }
   1085              cJSON_AddItemToObject(patch, "op", cJSON_CreateString((const char*)operation));
   \   00000034   0600A0E1           MOV      R0,R6
   1086          
   1087              if (suffix == NULL)
   \   00000038   ........           LDR      R6,??DataTable10  ;; ??invalid
   \   0000003C   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   00000040   0020A0E1           MOV      R2,R0
   \   00000044   ........           ADR      R1,??DataTable3  ;; "op"
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   00000050   00005AE3           CMP      R10,#+0
   \   00000054   0600001A           BNE      ??compose_patch_0
   1088              {
   1089                  cJSON_AddItemToObject(patch, "path", cJSON_CreateString((const char*)path));
   \   00000058   0900A0E1           MOV      R0,R9
   \   0000005C   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   00000060   0020A0E1           MOV      R2,R0
   \   00000064   4C1086E2           ADD      R1,R6,#+76
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \   00000070   220000EA           B        ??compose_patch_1
   1090              }
   1091              else
   1092              {
   1093                  size_t suffix_length = pointer_encoded_length(suffix);
   \                     ??compose_patch_0:
   \   00000074   0A00A0E1           MOV      R0,R10
   \   00000078   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000007C   0080A0E3           MOV      R8,#+0
   \   00000080   000051E3           CMP      R1,#+0
   \   00000084   0700000A           BEQ      ??compose_patch_2
   \                     ??compose_patch_3:
   \   00000088   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000008C   7E0051E3           CMP      R1,#+126
   \   00000090   2F005113           CMPNE    R1,#+47
   \   00000094   0110F0E5           LDRB     R1,[R0, #+1]!
   \   00000098   01808802           ADDEQ    R8,R8,#+1
   \   0000009C   018088E2           ADD      R8,R8,#+1
   \   000000A0   000051E3           CMP      R1,#+0
   \   000000A4   F7FFFF1A           BNE      ??compose_patch_3
   1094                  size_t path_length = strlen((const char*)path);
   \                     ??compose_patch_2:
   \   000000A8   0900A0E1           MOV      R0,R9
   \   000000AC   1B0000EF           SWI      +27
   \   000000B0   00B0A0E1           MOV      R11,R0
   1095                  unsigned char *full_path = (unsigned char*)cJSON_malloc(path_length + suffix_length + sizeof("/"));
   \   000000B4   0B0088E0           ADD      R0,R8,R11
   \   000000B8   020080E2           ADD      R0,R0,#+2
   \   000000BC   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   000000C0   0080A0E1           MOV      R8,R0
   1096          
   1097                  sprintf((char*)full_path, "%s/", (const char*)path);
   \   000000C4   0920A0E1           MOV      R2,R9
   \   000000C8   ........           ADR      R1,??DataTable8  ;; "%s/"
   \   000000CC   160000EF           SWI      +22
   1098                  encode_string_as_pointer(full_path + path_length + 1, suffix);
   \   000000D0   0A10A0E1           MOV      R1,R10
   \   000000D4   08008BE0           ADD      R0,R11,R8
   \   000000D8   010080E2           ADD      R0,R0,#+1
   \   000000DC   ........           BL       encode_string_as_pointer
   1099          
   1100                  cJSON_AddItemToObject(patch, "path", cJSON_CreateString((const char*)full_path));
   \   000000E0   0800A0E1           MOV      R0,R8
   \   000000E4   ........           _BLF     cJSON_CreateString,??cJSON_CreateString??rA
   \   000000E8   0020A0E1           MOV      R2,R0
   \   000000EC   4C1086E2           ADD      R1,R6,#+76
   \   000000F0   0500A0E1           MOV      R0,R5
   \   000000F4   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1101                  cJSON_free(full_path);
   \   000000F8   0800A0E1           MOV      R0,R8
   \   000000FC   ........           _BLF     cJSON_free,??cJSON_free??rA
   1102              }
   1103          
   1104              if (value != NULL)
   \                     ??compose_patch_1:
   \   00000100   000057E3           CMP      R7,#+0
   \   00000104   0600000A           BEQ      ??compose_patch_4
   1105              {
   1106                  cJSON_AddItemToObject(patch, "value", cJSON_Duplicate(value, 1));
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   0700A0E1           MOV      R0,R7
   \   00000110   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000114   0020A0E1           MOV      R2,R0
   \   00000118   541086E2           ADD      R1,R6,#+84
   \   0000011C   0500A0E1           MOV      R0,R5
   \   00000120   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1107              }
   1108              cJSON_AddItemToArray(patches, patch);
   \                     ??compose_patch_4:
   \   00000124   0510A0E1           MOV      R1,R5
   \   00000128   0400A0E1           MOV      R0,R4
   \   0000012C   ........           _BLF     cJSON_AddItemToArray,??cJSON_AddItemToArray??rA
   1109          }
   \   00000130   F08FBDE8           POP      {R4-R11,PC}      ;; return
   1110          

   \                                 In segment CODE, align 4, keep-with-next
   1111          CJSON_PUBLIC(void) cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value)
   1112          {
   \                     cJSONUtils_AddPatchToArray:
   \   00000000   00402DE9           PUSH     {LR}
   1113              compose_patch(array, (const unsigned char*)operation, (const unsigned char*)path, NULL, value);
   \   00000004   08002DE9           PUSH     {R3}
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   ........           BL       compose_patch
   1114          }
   \   00000010   0180BDE8           POP      {R0,PC}          ;; return
   1115          

   \                                 In segment CODE, align 4, keep-with-next
   1116          static void create_patches(cJSON * const patches, const unsigned char * const path, cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)
   1117          {
   \                     create_patches:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   24909DE5           LDR      R9,[SP, #+36]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0360A0E1           MOV      R6,R3
   1118              if ((from == NULL) || (to == NULL))
   \   00000018   000058E3           CMP      R8,#+0
   \   0000001C   00005613           CMPNE    R6,#+0
   \   00000020   F08FBD08           POPEQ    {R4-R11,PC}
   1119              {
   1120                  return;
   1121              }
   1122          
   1123              if ((from->type & 0xFF) != (to->type & 0xFF))
   \   00000024   0C1098E5           LDR      R1,[R8, #+12]
   \   00000028   0C2096E5           LDR      R2,[R6, #+12]
   \   0000002C   ........           LDR      R7,??DataTable10  ;; ??invalid
   \   00000030   FF0001E2           AND      R0,R1,#0xFF
   \   00000034   FF2002E2           AND      R2,R2,#0xFF
   \   00000038   020050E1           CMP      R0,R2
   \   0000003C   1900001A           BNE      ??create_patches_0
   1124              {
   1125                  compose_patch(patches, (const unsigned char*)"replace", path, 0, to);
   1126                  return;
   1127              }
   1128          
   1129              switch (from->type & 0xFF)
   \                     ??create_patches_1:
   \   00000040   080098E5           LDR      R0,[R8, #+8]
   \   00000044   FF1001E2           AND      R1,R1,#0xFF
   \   00000048   081051E2           SUBS     R1,R1,#+8
   \   0000004C   0600000A           BEQ      ??create_patches_2
   \   00000050   081051E2           SUBS     R1,R1,#+8
   \   00000054   0E00000A           BEQ      ??create_patches_3
   \   00000058   101051E2           SUBS     R1,R1,#+16
   \   0000005C   1900000A           BEQ      ??create_patches_4
   \   00000060   201051E2           SUBS     R1,R1,#+32
   \   00000064   5200000A           BEQ      ??create_patches_5
   \   00000068   F08FBDE8           POP      {R4-R11,PC}
   1130              {
   1131                  case cJSON_Number:
   1132                      if ((from->valueint != to->valueint) || (from->valuedouble != to->valuedouble))
   \                     ??create_patches_2:
   \   0000006C   140098E5           LDR      R0,[R8, #+20]
   \   00000070   141096E5           LDR      R1,[R6, #+20]
   \   00000074   010050E1           CMP      R0,R1
   \   00000078   0A00001A           BNE      ??create_patches_0
   \   0000007C   180098E5           LDR      R0,[R8, #+24]
   \   00000080   1C1098E5           LDR      R1,[R8, #+28]
   \   00000084   182096E5           LDR      R2,[R6, #+24]
   \   00000088   1C3096E5           LDR      R3,[R6, #+28]
   \   0000008C   ........           _BLF     __dNotEqual,??__dNotEqual??rA
   \   00000090   020000EA           B        ??create_patches_6
   1133                      {
   1134                          compose_patch(patches, (const unsigned char*)"replace", path, NULL, to);
   1135                      }
   1136                      return;
   1137          
   1138                  case cJSON_String:
   1139                      if (strcmp(from->valuestring, to->valuestring) != 0)
   \                     ??create_patches_3:
   \   00000094   100098E5           LDR      R0,[R8, #+16]
   \   00000098   101096E5           LDR      R1,[R6, #+16]
   \   0000009C   190000EF           SWI      +25
   \                     ??create_patches_6:
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   F08FBD08           POPEQ    {R4-R11,PC}
   1140                      {
   1141                          compose_patch(patches, (const unsigned char*)"replace", path, NULL, to);
   \                     ??create_patches_0:
   \   000000A8   40002DE9           PUSH     {R6}
   \   000000AC   0030A0E3           MOV      R3,#+0
   \   000000B0   0520A0E1           MOV      R2,R5
   \   000000B4   2C1087E2           ADD      R1,R7,#+44
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       compose_patch
   \   000000C0   04D08DE2           ADD      SP,SP,#+4
   \   000000C4   F08FBDE8           POP      {R4-R11,PC}
   1142                      }
   1143                      return;
   1144          
   1145                  case cJSON_Array:
   1146                  {
   1147                      size_t index = 0;
   1148                      cJSON *from_child = from->child;
   1149                      cJSON *to_child = to->child;
   \                     ??create_patches_4:
   \   000000C8   086096E5           LDR      R6,[R6, #+8]
   \   000000CC   0080A0E1           MOV      R8,R0
   1150                      unsigned char *new_path = (unsigned char*)cJSON_malloc(strlen((const char*)path) + 20 + sizeof("/")); /* Allow space for 64bit int. log10(2^64) = 20 */
   \   000000D0   0500A0E1           MOV      R0,R5
   \   000000D4   1B0000EF           SWI      +27
   \   000000D8   160080E2           ADD      R0,R0,#+22
   \   000000DC   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   000000E0   00A0A0E1           MOV      R10,R0
   1151          
   1152                      /* generate patches for all array elements that exist in both "from" and "to" */
   1153                      for (index = 0; (from_child != NULL) && (to_child != NULL); (void)(from_child = from_child->next), (void)(to_child = to_child->next), index++)
   \   000000E4   00B0A0E3           MOV      R11,#+0
   \   000000E8   110000EA           B        ??create_patches_7
   \                     ??create_patches_8:
   \   000000EC   000056E3           CMP      R6,#+0
   \   000000F0   1300000A           BEQ      ??create_patches_9
   1154                      {
   1155                          /* check if conversion to unsigned long is valid
   1156                           * This should be eliminated at compile time by dead code elimination
   1157                           * if size_t is an alias of unsigned long, or if it is bigger */
   1158                          if (index > ULONG_MAX)
   1159                          {
   1160                              cJSON_free(new_path);
   1161                              return;
   1162                          }
   1163                          sprintf((char*)new_path, "%s/%lu", path, (unsigned long)index); /* path of the current array element */
   \   000000F4   0B30A0E1           MOV      R3,R11
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   641087E2           ADD      R1,R7,#+100
   \   00000100   0A00A0E1           MOV      R0,R10
   \   00000104   160000EF           SWI      +22
   1164                          create_patches(patches, new_path, from_child, to_child, case_sensitive);
   \   00000108   0900A0E1           MOV      R0,R9
   \   0000010C   01002DE9           PUSH     {R0}
   \   00000110   0630A0E1           MOV      R3,R6
   \   00000114   0820A0E1           MOV      R2,R8
   \   00000118   0A10A0E1           MOV      R1,R10
   \   0000011C   0400A0E1           MOV      R0,R4
   \   00000120   B6FFFFEB           BL       create_patches
   1165                      }
   \   00000124   008098E5           LDR      R8,[R8, #+0]
   \   00000128   006096E5           LDR      R6,[R6, #+0]
   \   0000012C   01B08BE2           ADD      R11,R11,#+1
   \   00000130   04D08DE2           ADD      SP,SP,#+4
   \                     ??create_patches_7:
   \   00000134   000058E3           CMP      R8,#+0
   \   00000138   EBFFFF1A           BNE      ??create_patches_8
   1166          
   1167                      /* remove leftover elements from 'from' that are not in 'to' */
   1168                      for (; (from_child != NULL); (void)(from_child = from_child->next))
   \                     ??create_patches_10:
   \   0000013C   000058E3           CMP      R8,#+0
   \   00000140   1600000A           BEQ      ??create_patches_11
   1169                      {
   1170                          /* check if conversion to unsigned long is valid
   1171                           * This should be eliminated at compile time by dead code elimination
   1172                           * if size_t is an alias of unsigned long, or if it is bigger */
   1173                          if (index > ULONG_MAX)
   1174                          {
   1175                              cJSON_free(new_path);
   1176                              return;
   1177                          }
   1178                          sprintf((char*)new_path, "%lu", (unsigned long)index);
   \                     ??create_patches_9:
   \   00000144   0B20A0E1           MOV      R2,R11
   \   00000148   681F8FE2           ADR      R1,??create_patches_12  ;; "%lu"
   \   0000014C   0A00A0E1           MOV      R0,R10
   \   00000150   160000EF           SWI      +22
   1179                          compose_patch(patches, (const unsigned char*)"remove", path, new_path, NULL);
   \   00000154   0000A0E3           MOV      R0,#+0
   \   00000158   01002DE9           PUSH     {R0}
   \   0000015C   0A30A0E1           MOV      R3,R10
   \   00000160   0520A0E1           MOV      R2,R5
   \   00000164   241087E2           ADD      R1,R7,#+36
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           BL       compose_patch
   1180                      }
   \   00000170   008098E5           LDR      R8,[R8, #+0]
   \   00000174   04D08DE2           ADD      SP,SP,#+4
   \   00000178   EFFFFFEA           B        ??create_patches_10
   1181                      /* add new elements in 'to' that were not in 'from' */
   1182                      for (; (to_child != NULL); (void)(to_child = to_child->next), index++)
   1183                      {
   1184                          compose_patch(patches, (const unsigned char*)"add", path, (const unsigned char*)"-", to_child);
   \                     ??create_patches_13:
   \   0000017C   0600A0E1           MOV      R0,R6
   \   00000180   01002DE9           PUSH     {R0}
   \   00000184   ........           ADR      R3,??DataTable6  ;; "-"
   \   00000188   0520A0E1           MOV      R2,R5
   \   0000018C   ........           ADR      R1,??DataTable9  ;; "add"
   \   00000190   0400A0E1           MOV      R0,R4
   \   00000194   ........           BL       compose_patch
   1185                      }
   \   00000198   006096E5           LDR      R6,[R6, #+0]
   \   0000019C   04D08DE2           ADD      SP,SP,#+4
   \                     ??create_patches_11:
   \   000001A0   000056E3           CMP      R6,#+0
   \   000001A4   F4FFFF1A           BNE      ??create_patches_13
   1186                      cJSON_free(new_path);
   \   000001A8   0A00A0E1           MOV      R0,R10
   \   000001AC   ........           _BLF     cJSON_free,??cJSON_free??rA
   1187                      return;
   \   000001B0   F08FBDE8           POP      {R4-R11,PC}
   1188                  }
   1189          
   1190                  case cJSON_Object:
   1191                  {
   1192                      cJSON *from_child = NULL;
   1193                      cJSON *to_child = NULL;
   1194                      sort_object(from, case_sensitive);
   \                     ??create_patches_5:
   \   000001B4   0910A0E1           MOV      R1,R9
   \   000001B8   ........           BL       sort_list
   \   000001BC   080088E5           STR      R0,[R8, #+8]
   \   000001C0   080096E5           LDR      R0,[R6, #+8]
   \   000001C4   0910A0E1           MOV      R1,R9
   \   000001C8   ........           BL       sort_list
   \   000001CC   080086E5           STR      R0,[R6, #+8]
   1195                      sort_object(to, case_sensitive);
   1196          
   1197                      from_child = from->child;
   \   000001D0   088098E5           LDR      R8,[R8, #+8]
   1198                      to_child = to->child;
   \   000001D4   0060A0E1           MOV      R6,R0
   \   000001D8   260000EA           B        ??create_patches_14
   1199                      /* for all object values in the object with more of them */
   1200                      while ((from_child != NULL) || (to_child != NULL))
   1201                      {
   1202                          int diff;
   1203                          if (from_child == NULL)
   1204                          {
   1205                              diff = 1;
   1206                          }
   1207                          else if (to_child == NULL)
   1208                          {
   1209                              diff = -1;
   1210                          }
   1211                          else
   1212                          {
   1213                              diff = compare_strings((unsigned char*)from_child->string, (unsigned char*)to_child->string, case_sensitive);
   1214                          }
   1215          
   1216                          if (diff == 0)
   1217                          {
   1218                              /* both object keys are the same */
   1219                              size_t path_length = strlen((const char*)path);
   \                     ??create_patches_15:
   \   000001DC   0500A0E1           MOV      R0,R5
   \   000001E0   1B0000EF           SWI      +27
   \   000001E4   00A0A0E1           MOV      R10,R0
   1220                              size_t from_child_name_length = pointer_encoded_length((unsigned char*)from_child->string);
   \   000001E8   200098E5           LDR      R0,[R8, #+32]
   \   000001EC   0010A0E3           MOV      R1,#+0
   \   000001F0   0020D0E5           LDRB     R2,[R0, #+0]
   \   000001F4   000052E3           CMP      R2,#+0
   \   000001F8   0700000A           BEQ      ??create_patches_16
   \                     ??create_patches_17:
   \   000001FC   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000200   7E0052E3           CMP      R2,#+126
   \   00000204   2F005213           CMPNE    R2,#+47
   \   00000208   0120F0E5           LDRB     R2,[R0, #+1]!
   \   0000020C   01108102           ADDEQ    R1,R1,#+1
   \   00000210   011081E2           ADD      R1,R1,#+1
   \   00000214   000052E3           CMP      R2,#+0
   \   00000218   F7FFFF1A           BNE      ??create_patches_17
   1221                              unsigned char *new_path = (unsigned char*)cJSON_malloc(path_length + from_child_name_length + sizeof("/"));
   \                     ??create_patches_16:
   \   0000021C   01008AE0           ADD      R0,R10,R1
   \   00000220   020080E2           ADD      R0,R0,#+2
   \   00000224   ........           _BLF     cJSON_malloc,??cJSON_malloc??rA
   \   00000228   00B0A0E1           MOV      R11,R0
   1222          
   1223                              sprintf((char*)new_path, "%s/", path);
   \   0000022C   0520A0E1           MOV      R2,R5
   \   00000230   ........           ADR      R1,??DataTable8  ;; "%s/"
   \   00000234   160000EF           SWI      +22
   1224                              encode_string_as_pointer(new_path + path_length + 1, (unsigned char*)from_child->string);
   \   00000238   201098E5           LDR      R1,[R8, #+32]
   \   0000023C   0B008AE0           ADD      R0,R10,R11
   \   00000240   010080E2           ADD      R0,R0,#+1
   \   00000244   ........           BL       encode_string_as_pointer
   1225          
   1226                              /* create a patch for the element */
   1227                              create_patches(patches, new_path, from_child, to_child, case_sensitive);
   \   00000248   0900A0E1           MOV      R0,R9
   \   0000024C   01002DE9           PUSH     {R0}
   \   00000250   0630A0E1           MOV      R3,R6
   \   00000254   0820A0E1           MOV      R2,R8
   \   00000258   0B10A0E1           MOV      R1,R11
   \   0000025C   0400A0E1           MOV      R0,R4
   \   00000260   66FFFFEB           BL       create_patches
   1228                              cJSON_free(new_path);
   \   00000264   0B00A0E1           MOV      R0,R11
   \   00000268   ........           _BLF     cJSON_free,??cJSON_free??rA
   1229          
   1230                              from_child = from_child->next;
   \   0000026C   008098E5           LDR      R8,[R8, #+0]
   1231                              to_child = to_child->next;
   \                     ??create_patches_18:
   \   00000270   006096E5           LDR      R6,[R6, #+0]
   \                     ??create_patches_19:
   \   00000274   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   1232                          }
   \                     ??create_patches_14:
   \   00000278   000058E3           CMP      R8,#+0
   \   0000027C   0900001A           BNE      ??create_patches_20
   \   00000280   000056E3           CMP      R6,#+0
   \   00000284   F08FBD08           POPEQ    {R4-R11,PC}
   1233                          else if (diff < 0)
   1234                          {
   1235                              /* object element doesn't exist in 'to' --> remove it */
   1236                              compose_patch(patches, (const unsigned char*)"remove", path, (unsigned char*)from_child->string, NULL);
   1237          
   1238                              from_child = from_child->next;
   1239                          }
   1240                          else
   1241                          {
   1242                              /* object element doesn't exist in 'from' --> add it */
   1243                              compose_patch(patches, (const unsigned char*)"add", path, (unsigned char*)to_child->string, to_child);
   \                     ??create_patches_21:
   \   00000288   0600A0E1           MOV      R0,R6
   \   0000028C   01002DE9           PUSH     {R0}
   \   00000290   203096E5           LDR      R3,[R6, #+32]
   \   00000294   0520A0E1           MOV      R2,R5
   \   00000298   ........           ADR      R1,??DataTable9  ;; "add"
   \   0000029C   0400A0E1           MOV      R0,R4
   \   000002A0   ........           BL       compose_patch
   1244          
   1245                              to_child = to_child->next;
   \   000002A4   F1FFFFEA           B        ??create_patches_18
   1246                          }
   \                     ??create_patches_20:
   \   000002A8   000056E3           CMP      R6,#+0
   \   000002AC   0600000A           BEQ      ??create_patches_22
   \   000002B0   200098E5           LDR      R0,[R8, #+32]
   \   000002B4   201096E5           LDR      R1,[R6, #+32]
   \   000002B8   0920A0E1           MOV      R2,R9
   \   000002BC   ........           BL       compare_strings
   \   000002C0   000050E3           CMP      R0,#+0
   \   000002C4   C4FFFF0A           BEQ      ??create_patches_15
   \   000002C8   EEFFFF5A           BPL      ??create_patches_21
   \                     ??create_patches_22:
   \   000002CC   0000A0E3           MOV      R0,#+0
   \   000002D0   01002DE9           PUSH     {R0}
   \   000002D4   203098E5           LDR      R3,[R8, #+32]
   \   000002D8   0520A0E1           MOV      R2,R5
   \   000002DC   241087E2           ADD      R1,R7,#+36
   \   000002E0   0400A0E1           MOV      R0,R4
   \   000002E4   ........           BL       compose_patch
   \   000002E8   008098E5           LDR      R8,[R8, #+0]
   \   000002EC   E0FFFFEA           B        ??create_patches_19
   \                     ??create_patches_12:
   \   000002F0   256C7500           DC8      "%lu"
   1247                      }
   1248                      return;
   1249                  }
   1250          
   1251                  default:
   1252                      break;
   1253              }
   1254          }
   1255          

   \                                 In segment CODE, align 4, keep-with-next
   1256          CJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to)
   1257          {
   \                     cJSONUtils_GeneratePatches:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1258              cJSON *patches = NULL;
   1259          
   1260              if ((from == NULL) || (to == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   1261              {
   1262                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
   1263              }
   1264          
   1265              patches = cJSON_CreateArray();
   \   0000001C   ........           _BLF     cJSON_CreateArray,??cJSON_CreateArray??rA
   \   00000020   0060A0E1           MOV      R6,R0
   1266              create_patches(patches, (const unsigned char*)"", from, to, false);
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   0530A0E1           MOV      R3,R5
   \   00000030   0420A0E1           MOV      R2,R4
   \   00000034   ........           ADR      R1,??DataTable12  ;; ""
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           BL       create_patches
   1267          
   1268              return patches;
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1269          }
   1270          

   \                                 In segment CODE, align 4, keep-with-next
   1271          CJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to)
   1272          {
   \                     cJSONUtils_GeneratePatchesCaseSensitive:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   1273              cJSON *patches = NULL;
   1274          
   1275              if ((from == NULL) || (to == NULL))
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00005513           CMPNE    R5,#+0
   1276              {
   1277                  return NULL;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   7080BD08           POPEQ    {R4-R6,PC}
   1278              }
   1279          
   1280              patches = cJSON_CreateArray();
   \   0000001C   ........           _BLF     cJSON_CreateArray,??cJSON_CreateArray??rA
   \   00000020   0060A0E1           MOV      R6,R0
   1281              create_patches(patches, (const unsigned char*)"", from, to, true);
   \   00000024   0100A0E3           MOV      R0,#+1
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   0530A0E1           MOV      R3,R5
   \   00000030   0420A0E1           MOV      R2,R4
   \   00000034   ........           ADR      R1,??DataTable12  ;; ""
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   ........           BL       create_patches
   1282          
   1283              return patches;
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   04D08DE2           ADD      SP,SP,#+4
   \   00000048   7080BDE8           POP      {R4-R6,PC}       ;; return
   1284          }
   1285          

   \                                 In segment CODE, align 4, keep-with-next
   1286          CJSON_PUBLIC(void) cJSONUtils_SortObject(cJSON * const object)
   1287          {
   \                     cJSONUtils_SortObject:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   1288              sort_object(object, false);
   \   00000008   1080BD08           POPEQ    {R4,PC}
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   ........           BL       sort_list
   \   00000018   080084E5           STR      R0,[R4, #+8]
   1289          }
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
   1290          

   \                                 In segment CODE, align 4, keep-with-next
   1291          CJSON_PUBLIC(void) cJSONUtils_SortObjectCaseSensitive(cJSON * const object)
   1292          {
   \                     cJSONUtils_SortObjectCaseSensitive:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   1293              sort_object(object, true);
   \   00000008   1080BD08           POPEQ    {R4,PC}
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   0110A0E3           MOV      R1,#+1
   \   00000014   ........           BL       sort_list
   \   00000018   080084E5           STR      R0,[R4, #+8]
   1294          }
   \   0000001C   1080BDE8           POP      {R4,PC}          ;; return
   1295          

   \                                 In segment CODE, align 4, keep-with-next
   1296          static cJSON *merge_patch(cJSON *target, const cJSON * const patch, const cJSON_bool case_sensitive)
   1297          {
   \                     merge_patch:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1298              cJSON *patch_child = NULL;
   1299          
   1300              if (!cJSON_IsObject(patch))
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   0400001A           BNE      ??merge_patch_0
   1301              {
   1302                  /* scalar value, array or NULL, just duplicate */
   1303                  cJSON_Delete(target);
   \   00000024   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1304                  return cJSON_Duplicate(patch, 1);
   \   00000028   0110A0E3           MOV      R1,#+1
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000034   7080BDE8           POP      {R4-R6,PC}
   1305              }
   1306          
   1307              if (!cJSON_IsObject(target))
   \                     ??merge_patch_0:
   \   00000038   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0300001A           BNE      ??merge_patch_1
   1308              {
   1309                  cJSON_Delete(target);
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1310                  target = cJSON_CreateObject();
   \   0000004C   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   00000050   0040A0E1           MOV      R4,R0
   1311              }
   1312          
   1313              patch_child = patch->child;
   \                     ??merge_patch_1:
   \   00000054   085095E5           LDR      R5,[R5, #+8]
   \   00000058   040000EA           B        ??merge_patch_2
   1314              while (patch_child != NULL)
   1315              {
   1316                  if (cJSON_IsNull(patch_child))
   1317                  {
   1318                      /* NULL is the indicator to remove a value, see RFC7396 */
   1319                      if (case_sensitive)
   1320                      {
   1321                          cJSON_DeleteItemFromObjectCaseSensitive(target, patch_child->string);
   1322                      }
   1323                      else
   1324                      {
   1325                          cJSON_DeleteItemFromObject(target, patch_child->string);
   1326                      }
   1327                  }
   1328                  else
   1329                  {
   1330                      cJSON *replace_me = NULL;
   1331                      cJSON *replacement = NULL;
   1332          
   1333                      if (case_sensitive)
   1334                      {
   1335                          replace_me = cJSON_DetachItemFromObjectCaseSensitive(target, patch_child->string);
   1336                      }
   1337                      else
   1338                      {
   1339                          replace_me = cJSON_DetachItemFromObject(target, patch_child->string);
   1340                      }
   1341          
   1342                      replacement = merge_patch(replace_me, patch_child, case_sensitive);
   1343                      if (replacement == NULL)
   1344                      {
   1345                          return NULL;
   1346                      }
   1347          
   1348                      cJSON_AddItemToObject(target, patch_child->string, replacement);
   \                     ??merge_patch_3:
   \   0000005C   201095E5           LDR      R1,[R5, #+32]
   \   00000060   0020A0E1           MOV      R2,R0
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1349                  }
   1350                  patch_child = patch_child->next;
   \                     ??merge_patch_4:
   \   0000006C   005095E5           LDR      R5,[R5, #+0]
   \                     ??merge_patch_2:
   \   00000070   000055E3           CMP      R5,#+0
   \   00000074   1700000A           BEQ      ??merge_patch_5
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           _BLF     cJSON_IsNull,??cJSON_IsNull??rA
   \   00000080   201095E5           LDR      R1,[R5, #+32]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0600000A           BEQ      ??merge_patch_6
   \   0000008C   000056E3           CMP      R6,#+0
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   0100000A           BEQ      ??merge_patch_7
   \   00000098   ........           _BLF     cJSON_DeleteItemFromObjectCaseSensitive,??cJSON_DeleteItemFromObjectCaseSensitive??rA
   \   0000009C   F2FFFFEA           B        ??merge_patch_4
   \                     ??merge_patch_7:
   \   000000A0   ........           _BLF     cJSON_DeleteItemFromObject,??cJSON_DeleteItemFromObject??rA
   \   000000A4   F0FFFFEA           B        ??merge_patch_4
   \                     ??merge_patch_6:
   \   000000A8   000056E3           CMP      R6,#+0
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   0100000A           BEQ      ??merge_patch_8
   \   000000B4   ........           _BLF     cJSON_DetachItemFromObjectCaseSensitive,??cJSON_DetachItemFromObjectCaseSensitive??rA
   \   000000B8   000000EA           B        ??merge_patch_9
   \                     ??merge_patch_8:
   \   000000BC   ........           _BLF     cJSON_DetachItemFromObject,??cJSON_DetachItemFromObject??rA
   \                     ??merge_patch_9:
   \   000000C0   0620A0E1           MOV      R2,R6
   \   000000C4   0510A0E1           MOV      R1,R5
   \   000000C8   CCFFFFEB           BL       merge_patch
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   E1FFFF1A           BNE      ??merge_patch_3
   \   000000D4   7080BDE8           POP      {R4-R6,PC}
   1351              }
   1352              return target;
   \                     ??merge_patch_5:
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   7080BDE8           POP      {R4-R6,PC}       ;; return
   1353          }
   1354          

   \                                 In segment CODE, align 4, keep-with-next
   1355          CJSON_PUBLIC(cJSON *) cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch)
   1356          {
   1357              return merge_patch(target, patch, false);
   \                     cJSONUtils_MergePatch:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        merge_patch      ;; tailcall
   1358          }
   1359          

   \                                 In segment CODE, align 4, keep-with-next
   1360          CJSON_PUBLIC(cJSON *) cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch)
   1361          {
   1362              return merge_patch(target, patch, true);
   \                     cJSONUtils_MergePatchCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        merge_patch      ;; tailcall
   1363          }
   1364          

   \                                 In segment CODE, align 4, keep-with-next
   1365          static cJSON *generate_merge_patch(cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)
   1366          {
   \                     generate_merge_patch:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   1367              cJSON *from_child = NULL;
   1368              cJSON *to_child = NULL;
   1369              cJSON *patch = NULL;
   1370              if (to == NULL)
   \   00000010   000055E3           CMP      R5,#+0
   \   00000014   0100001A           BNE      ??generate_merge_patch_0
   1371              {
   1372                  /* patch to delete everything */
   1373                  return cJSON_CreateNull();
   \   00000018   ........           _BLF     cJSON_CreateNull,??cJSON_CreateNull??rA
   \   0000001C   F080BDE8           POP      {R4-R7,PC}
   1374              }
   1375              if (!cJSON_IsObject(to) || !cJSON_IsObject(from))
   \                     ??generate_merge_patch_0:
   \   00000020   0500A0E1           MOV      R0,R5
   \   00000024   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0300000A           BEQ      ??generate_merge_patch_1
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     cJSON_IsObject,??cJSON_IsObject??rA
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0300001A           BNE      ??generate_merge_patch_2
   1376              {
   1377                  return cJSON_Duplicate(to, 1);
   \                     ??generate_merge_patch_1:
   \   00000040   0110A0E3           MOV      R1,#+1
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   0000004C   F080BDE8           POP      {R4-R7,PC}
   1378              }
   1379          
   1380              sort_object(from, case_sensitive);
   \                     ??generate_merge_patch_2:
   \   00000050   000054E3           CMP      R4,#+0
   \   00000054   0300000A           BEQ      ??generate_merge_patch_3
   \   00000058   080094E5           LDR      R0,[R4, #+8]
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   ........           BL       sort_list
   \   00000064   080084E5           STR      R0,[R4, #+8]
   \                     ??generate_merge_patch_3:
   \   00000068   080095E5           LDR      R0,[R5, #+8]
   \   0000006C   0610A0E1           MOV      R1,R6
   \   00000070   ........           BL       sort_list
   \   00000074   080085E5           STR      R0,[R5, #+8]
   1381              sort_object(to, case_sensitive);
   1382          
   1383              from_child = from->child;
   \   00000078   084094E5           LDR      R4,[R4, #+8]
   1384              to_child = to->child;
   \   0000007C   0050A0E1           MOV      R5,R0
   1385              patch = cJSON_CreateObject();
   \   00000080   ........           _BLF     cJSON_CreateObject,??cJSON_CreateObject??rA
   \   00000084   0070A0E1           MOV      R7,R0
   \   00000088   050000EA           B        ??generate_merge_patch_4
   1386              while (from_child || to_child)
   1387              {
   1388                  int diff;
   1389                  if (from_child != NULL)
   1390                  {
   1391                      if (to_child != NULL)
   1392                      {
   1393                          diff = strcmp(from_child->string, to_child->string);
   1394                      }
   1395                      else
   1396                      {
   1397                          diff = -1;
   1398                      }
   1399                  }
   1400                  else
   1401                  {
   1402                      diff = 1;
   1403                  }
   1404          
   1405                  if (diff < 0)
   1406                  {
   1407                      /* from has a value that to doesn't have -> remove */
   1408                      cJSON_AddItemToObject(patch, from_child->string, cJSON_CreateNull());
   \                     ??generate_merge_patch_5:
   \   0000008C   ........           _BLF     cJSON_CreateNull,??cJSON_CreateNull??rA
   \   00000090   201094E5           LDR      R1,[R4, #+32]
   \   00000094   0020A0E1           MOV      R2,R0
   \   00000098   0700A0E1           MOV      R0,R7
   \   0000009C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   1409          
   1410                      from_child = from_child->next;
   \   000000A0   004094E5           LDR      R4,[R4, #+0]
   1411                  }
   \                     ??generate_merge_patch_4:
   \   000000A4   000054E3           CMP      R4,#+0
   \   000000A8   0800001A           BNE      ??generate_merge_patch_6
   \   000000AC   000055E3           CMP      R5,#+0
   \   000000B0   0F00001A           BNE      ??generate_merge_patch_7
   1412                  else if (diff > 0)
   1413                  {
   1414                      /* to has a value that from doesn't have -> add to patch */
   1415                      cJSON_AddItemToObject(patch, to_child->string, cJSON_Duplicate(to_child, 1));
   1416          
   1417                      to_child = to_child->next;
   1418                  }
   1419                  else
   1420                  {
   1421                      /* object key exists in both objects */
   1422                      if (!compare_json(from_child, to_child, case_sensitive))
   1423                      {
   1424                          /* not identical --> generate a patch */
   1425                          cJSON_AddItemToObject(patch, to_child->string, cJSONUtils_GenerateMergePatch(from_child, to_child));
   1426                      }
   1427          
   1428                      /* next key in the object */
   1429                      from_child = from_child->next;
   1430                      to_child = to_child->next;
   1431                  }
   1432              }
   1433              if (patch->child == NULL)
   \   000000B4   080097E5           LDR      R0,[R7, #+8]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0700A0E1           MOV      R0,R7
   \   000000C0   F080BD18           POPNE    {R4-R7,PC}
   1434              {
   1435                  /* no patch generated */
   1436                  cJSON_Delete(patch);
   \   000000C4   ........           _BLF     cJSON_Delete,??cJSON_Delete??rA
   1437                  return NULL;
   \   000000C8   0000A0E3           MOV      R0,#+0
   \   000000CC   F080BDE8           POP      {R4-R7,PC}
   1438              }
   \                     ??generate_merge_patch_6:
   \   000000D0   000055E3           CMP      R5,#+0
   \   000000D4   ECFFFF0A           BEQ      ??generate_merge_patch_5
   \   000000D8   200094E5           LDR      R0,[R4, #+32]
   \   000000DC   201095E5           LDR      R1,[R5, #+32]
   \   000000E0   190000EF           SWI      +25
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   E7FFFF4A           BMI      ??generate_merge_patch_5
   \   000000EC   010050E3           CMP      R0,#+1
   \   000000F0   080000BA           BLT      ??generate_merge_patch_8
   \                     ??generate_merge_patch_7:
   \   000000F4   0110A0E3           MOV      R1,#+1
   \   000000F8   0500A0E1           MOV      R0,R5
   \   000000FC   ........           _BLF     cJSON_Duplicate,??cJSON_Duplicate??rA
   \   00000100   201095E5           LDR      R1,[R5, #+32]
   \   00000104   0020A0E1           MOV      R2,R0
   \   00000108   0700A0E1           MOV      R0,R7
   \   0000010C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \                     ??generate_merge_patch_9:
   \   00000110   005095E5           LDR      R5,[R5, #+0]
   \   00000114   E2FFFFEA           B        ??generate_merge_patch_4
   \                     ??generate_merge_patch_8:
   \   00000118   0620A0E1           MOV      R2,R6
   \   0000011C   0510A0E1           MOV      R1,R5
   \   00000120   0400A0E1           MOV      R0,R4
   \   00000124   ........           BL       compare_json
   \   00000128   000050E3           CMP      R0,#+0
   \   0000012C   0700001A           BNE      ??generate_merge_patch_10
   \   00000130   0020A0E3           MOV      R2,#+0
   \   00000134   0510A0E1           MOV      R1,R5
   \   00000138   0400A0E1           MOV      R0,R4
   \   0000013C   AFFFFFEB           BL       generate_merge_patch
   \   00000140   201095E5           LDR      R1,[R5, #+32]
   \   00000144   0020A0E1           MOV      R2,R0
   \   00000148   0700A0E1           MOV      R0,R7
   \   0000014C   ........           _BLF     cJSON_AddItemToObject,??cJSON_AddItemToObject??rA
   \                     ??generate_merge_patch_10:
   \   00000150   004094E5           LDR      R4,[R4, #+0]
   \   00000154   EDFFFFEA           B        ??generate_merge_patch_9
   1439          
   1440              return patch;
   1441          }
   1442          

   \                                 In segment CODE, align 4, keep-with-next
   1443          CJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to)
   1444          {
   1445              return generate_merge_patch(from, to, false);
   \                     cJSONUtils_GenerateMergePatch:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   ........           B        generate_merge_patch  ;; tailcall
   1446          }
   1447          

   \                                 In segment CODE, align 4, keep-with-next
   1448          CJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to)
   1449          {
   1450              return generate_merge_patch(from, to, true);
   \                     cJSONUtils_GenerateMergePatchCaseSensitive:
   \   00000000   0120A0E3           MOV      R2,#+1
   \   00000004   ........           B        generate_merge_patch  ;; tailcall
   1451          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   2D000000           DC8      "-",+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   6F700000           DC8      "op",+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   2D000000           DC8      "-",+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   25732F00           DC8      "%s/"

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   61646400           DC8      "add"

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     ??invalid

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "/%lu%s">`:
   \   00000000   2F256C752573       DC8 "/%lu%s"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   6F7000             DC8 "op"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   61646400           DC8 "add"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   2D00               DC8 "-"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   25732F00           DC8 "%s/"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   256C7500           DC8 "%lu"

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     apply_patch                       80
     cJSONUtils_AddPatchToArray         8
     cJSONUtils_ApplyPatches           12
     cJSONUtils_ApplyPatchesCaseSensitive
                                       12
     cJSONUtils_FindPointerFromObjectTo
                                       28
     cJSONUtils_GenerateMergePatch      4
     cJSONUtils_GenerateMergePatchCaseSensitive
                                        4
     cJSONUtils_GeneratePatches        20
     cJSONUtils_GeneratePatchesCaseSensitive
                                       20
     cJSONUtils_GetPointer              4
     cJSONUtils_GetPointerCaseSensitive
                                        4
     cJSONUtils_MergePatch              4
     cJSONUtils_MergePatchCaseSensitive
                                        4
     cJSONUtils_SortObject              8
     cJSONUtils_SortObjectCaseSensitive
                                        8
     compare_json                      16
     compare_pointers                   0
     compare_strings                    4
     compose_patch                     36
     create_patches                    40
     decode_array_index_from_pointer
                                        4
     detach_path                       36
     encode_string_as_pointer           0
     generate_merge_patch              20
     get_item_from_pointer             24
     merge_patch                       16
     sort_list                         28


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     compare_strings                 164
     compare_pointers                208
     encode_string_as_pointer         80
     cJSONUtils_FindPointerFromObjectTo
                                     336
     decode_array_index_from_pointer
                                     132
     get_item_from_pointer           236
     cJSONUtils_GetPointer             8
     cJSONUtils_GetPointerCaseSensitive
                                       8
     detach_path                     392
     sort_list                       356
     compare_json                    376
     apply_patch                    1464
     invalid                         108
     cJSONUtils_ApplyPatches          96
     cJSONUtils_ApplyPatchesCaseSensitive
                                      96
     compose_patch                   308
     cJSONUtils_AddPatchToArray       20
     create_patches                  756
     cJSONUtils_GeneratePatches       76
     cJSONUtils_GeneratePatchesCaseSensitive
                                      76
     cJSONUtils_SortObject            32
     cJSONUtils_SortObjectCaseSensitive
                                      32
     merge_patch                     224
     cJSONUtils_MergePatch             8
     cJSONUtils_MergePatchCaseSensitive
                                       8
     generate_merge_patch            344
     cJSONUtils_GenerateMergePatch     8
     cJSONUtils_GenerateMergePatchCaseSensitive
                                       8
     ??DataTable0                      4
     ??DataTable1                      4
     ??DataTable3                      4
     ??DataTable6                      4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable10                     4
     ??DataTable12                     4
     ?<Constant "">                    1
     ?<Constant "/%lu%s">              8
     ?<Constant "op">                  3
     ?<Constant "add">                 4
     ?<Constant "-">                   2
     ?<Constant "%s/">                 4
     ?<Constant "%lu">                 4
      Others                         360

 
 6 244 bytes in segment CODE
   134 bytes in segment DATA_C
 
 5 884 bytes of CODE  memory (+ 360 bytes shared)
   134 bytes of CONST memory

Errors: none
Warnings: 3
