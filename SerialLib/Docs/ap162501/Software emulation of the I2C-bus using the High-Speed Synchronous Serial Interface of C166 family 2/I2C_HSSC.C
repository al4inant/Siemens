/******************************************************************************/
/*                                                      		      */
/*                      SIEMENS Standard Software                     	      */
/*                                                                     	      */
/*                      Unauthorized copying prohibited               	      */
/*                                                                            */
/*============================================================================*/
/*      	Programmer: 	Tan Choon Hock                                */
/*      	Department: 	Siemens SCPL HLM                              */
/*      	Revision  : 	1.0 					      */
/*			                                                      */
/*============================================================================*/
/*     	Description: 	This module is a standard I2c bus single master       */
/*     			prococol by using HS-SSC.   	                      */
/*                                     	                                      */
/*      The clock frequency is 100KHz with 20 MHz CPU clock of C16X family    */    
/*	that is generated by the High-Speed Synchronous Serial Channel.       */
/*									      */
/*	Subroutines can be called from main program: I2cInit, I2cStart,       */
/*	I2cMasterWrite, I2cMasterRead, I2cStop.	  		  	      */
/*									      */
/*	Requirement: In application program, the include files called 	      */
/*	I2C_HSSC.H must be attached to the program.          		      */
/*                                                                            */
/*	In case there is a fault on the bus, for instance, the SDA line is    */
/*      shorted to ground or pulled down to LOW by the slave device. This     */
/*      module will generate clock pulses until the line is released and the  */
/*      time-out is 10 ms before returning a "HIGH" value from the I2cInit or */
/*      I2cStop. For SCL line, it will monitor until the line is released and */
/*      the time-out is 10 ms. The return value of I2cInit or I2cStop will be */
/*      checked in the main program to take an appropriate action.	      */
/*                                                                            */
/*      Input and output parameters of those subroutines:		      */
/*      (1) I2cInit: no input		                                      */
/*	             output = "0" - no error, "1" - error		      */
/* 									      */
/*      (2) I2cStart: no input, no output                                     */
/* 									      */
/*      (3) I2cMasterWrite: input = one byte of data to be sent to slave      */
/*				    device.				      */
/* 			    output = acknowledge bit.  			      */
/*                          (0 - received, 1 - not received)		      */
/* 									      */
/*	(4) I2cMasterRead: input = "1"/"0" of acknowledge bit to slave device */
/*			   (send on 9th clock pulse of data received)	      */	
/*                         output = A byte of data from slave device.	      */
/*									      */
/*	(5) I2cStop: no input						      */
/* 		     output = "0" - no error, "1" - error		      */
/*									      */
/*============================================================================*/
/*      History:          						      */
/*			08/11/96: Start of the module   		      */
/*            								      */
/******************************************************************************/   

#include <reg165.h>

sbit	SCL = P3^13;         	/* P3.13 = SCL */
sbit	DSCL = DP3^13;

sbit 	SDAI = P3^8;            /* P3.8 & P3.9 = SDA */
sbit 	DSDAI = DP3^8;

sbit	SDAO = P3^9;
sbit 	DSDAO = DP3^9;


void Delay(unsigned int count);
unsigned char Check_SCL();
unsigned char I2cInit();
void I2cStart();
unsigned char I2cMasterWrite(unsigned char input_byte);
unsigned char I2cMasterRead(unsigned char ack);
unsigned char I2cStop();

#define period 20000		/* 10 ms time out for bus faulty */

unsigned int time_out;




/******************************************************************************/
/*      Subroutine:	Delay	  					      */
/*                                                                            */
/*      Description:    This routine is to generate START and STOP condition, */
/*			and 9th clock pulse. It will loop until the 'count'   */
/*			becomes zero.		 		      	      */     															
/*                                                                            */
/*      Input:	        1 count = 400ns			   		      */
/*                                                                            */
/*      Return:		None						      */
/*                                                                            */
/******************************************************************************/

void Delay(unsigned int count)
{
	while (count--);
}



/******************************************************************************/
/*	Subroutine:	Check_SCL 				    	      */
/*			                             			      */
/*	Description:	Send HIGH and read the SCL line. It will wait until   */
/* 			the line has been released from slave device with the */
/* 			time out of 10 ms.				      */	
/*                                                                            */
/*      Input:	    	None						      */
/*                       	                                              */
/*      Return:		"0" - SCL line is OK			       	      */
/*			"1" - SCL line is faulty			      */
/*                                                                            */
/******************************************************************************/

unsigned char Check_SCL()
{

	time_out = period;

	SCL = 1;                /* set clock to high */

 	DSCL = 0;      		/* configure SCL as an input */ 

	while (time_out--)	
	{
 	   if (SCL)      /* wait if SCL is pulled down to LOW by slave device */
	   {
	      DSCL = 1;    	/* configure SCL as an output */ 
 	      return (0);
	   }
       	}

	return (1);   		/* ERROR: SCL line is stuck to low */

}


/******************************************************************************/
/*	Subroutine:	I2cInit 				    	      */
/*			                             			      */
/*	Description:	Initialize the I2C bus. 			      */	
/*			P3.8 - MRST, P3.9 - MTSR, P3.13 - SCL.    	      */
/*                      The MRST and MTSR are connected together for I2C      */
/*			operation. Configure the High-Speed Synchronous       */
/*			Serial interface to generate 100Kbaud clock frequency */
/*			and set the control register to produce a 8 bit data  */
/*			with MSB first, in master mode, shift transmit data   */
/*			the leading clock edge, latch on trailing edge, idle  */
/*			clock line is low, and leading clock edge is          */
/*			low-to-high transition. It also check the condition   */
/*			of the clock and data line.			      */	
/*					                                      */
/*      Input:	    	None						      */
/*                       	                                              */
/*      Return:		"0" - bus line is OK   			       	      */
/*			"1" - bus line is faulty			      */
/*                                                                            */
/******************************************************************************/

unsigned char I2cInit()
{

	ODP3 |= 0x2200;		/* open drain for SCL and MTSR */
        P3 |= 0x2200; 		/* p9,p13 = 1 */

	SSCBR = 0x0063;		/* set-up the baud rate generator to 100 KBaud 
				   or 10 us bit time */

        SSCCON = 0x4017;   	/* control register of SSC */
				/* 8 bit data with MSB first, master mode,
				   data changes on clock low */  
    	
	DSDAO = 1;		/* configure SDAO as an output */
	DSDAI = 0; 		/* configure SDAI as an input */
	DSCL = 0;               /* configure SCL as an input */

	if (!SDAI)   		/* if lines are low, set them to high */
	  if (I2cStop())
		return (1);

    	if (!SCL) 
	  if (I2cStop())
		return (1);
	
	return (0);

}
		

/******************************************************************************/
/*	Subroutine:	I2cStart     					      */
/*			                              			      */
/*	Description:	Generate a START condition on I2C bus		      */	
/*                                                                            */
/*      Input:	    	None						      */
/*                                                                            */
/*      Return:		None						      */
/*                                                                            */
/******************************************************************************/

void I2cStart()
{

	SDAO = 1;        /* to make sure the SDA and SCL are both high */
	SCL = 1;

	DSCL = 1;        /* configure SCL as an output */

        Delay(5);

	SDAO = 0;
	Delay(6);
	SCL = 0;
 
}


/******************************************************************************/
/*	Subroutine:	I2cMasterWrite			 		      */
/*			                                 		      */
/*	Description:	Output one byte of data to slave device.  	      */	
/*                                                                            */
/*      Input:	    	one byte of data to be sent to slave device.	      */
/*                                                                            */
/*      Return:		acknowledgement from slave:         		      */
/*		        0 = acknowledge is received			      */
/*	       	 	1 = no acknowledge is received			      */                       
/*                                                                    	      */
/******************************************************************************/

unsigned char I2cMasterWrite(unsigned char input_byte)
{
       
       	unsigned char mask;    


	SSCEN = 1;		/* enable SSC transmission */
 
        SCL = 1;                /* in order to use the alternate function (HSSC) */
	SDAO = 1;

	SSCTIR = 0;             /* clear transmit interrupt flag */
 
        SSCTB = input_byte;	/* write data into transmit buffer register */

	while (!SSCTIR);        /* wait for transmission buffer to be empty */

 	while (SSCBSY);        	/* wait for transmission to be completed */
	
	SSCEN = 0;              /* disable transmission */
 
	SCL = 1;                /* generate 9th clock pulse */
	
	Delay(0);
                          
	mask = SDAI;		/* read acknowledge */

	Delay(1);

	SCL = 0;

	Delay(6);		/* to avoid short pulse transition on SDA line */
	
	return (mask);
}	
						     			


/******************************************************************************/
/*	Subroutine:	I2cMasterRead			 		      */
/*			                                 		      */
/*	Description:	Read one byte from the I2C bus		     	      */	
/*                                                                            */
/*      Input:	     	Acknowledge require:				      */
/*			0 - generate LOW output after a byte is received      */
/*			1 - generate HIGH output after a byte is received     */
/*                                                                            */
/*      Return:  	received one data byte from slave device	      */
/*		        						      */                       
/*                                                                    	      */
/******************************************************************************/
				
unsigned char I2cMasterRead(unsigned char ack)
{

	unsigned char rec_data;
    
    

	SSCEN = 1;		/* enable SSC transmission */
 
        SCL = 1;                /* in order to use the alternate function (HSSC) */
	SDAO = 1;

        SSCRIR = 0;     	/* clear transmit interrupt flag  */

      	SSCTB = 0xFF;           /* dummy write */

	while (!SSCRIR);        /* check for the completion of reception */

 	if (ack)          	/* prepare for acknowledge bit */
	   SDAO = 1;           
	else SDAO = 0;

	rec_data = SSCRB;       /* store the received data into rec_data */

 	while (SSCBSY);        	/* wait for transmission to be completed */

	Delay(0);               /* to avoid short data transition on SDA line */
 
	SSCEN = 0;              /* disable transmission, the SCL=1 */

	SCL = 1;                /* generate 9th clock pulse */

	Delay(5);

	SCL = 0;

	Delay(6);		/* to avoid short pulse transition on SDA line */

	return (rec_data);      /* return received data */
}	



/******************************************************************************/
/*	Subroutine:	I2cStop				 		      */
/*			                                 		      */
/*	Description:	generate stop condition on the I2C bus	     	      */	
/*                                                                            */
/*      Input:	     	none                                                  */
/*                                                                            */
/*      Return:  	"0" - the bus line is OK		              */
/*		        "1" - the bus line has been pulled down to low for    */                       
/*			more than 10ms					      */
/*                                                                    	      */
/******************************************************************************/
				
unsigned char I2cStop()
{

	time_out = period;

	while (time_out --)
	{
	   if (!SDAI)                  	/* check SDA line */
	   {
	       	SCL = 1;  
			/* generate a clock pulse if SDA is pull down to low */
	    	Delay(6);
	    	SCL = 0;
	    	Delay(6);
	   }
	   else                 	/* check SCL line */
           {
	       	SDAO  = 0;

        	if (Check_SCL())     	/* to generate STOP condition */
	   	   return (1);     	/* ERROR: SCL line is stuck to low */
		
		Delay(0);

		SDAO = 1;
		return (0);
	   }
        }

        return (1);   	       		/* ERROR: SDA line is stuck to low */

}


